package org.eclipse.cdt.csharp.core.parser;

import lpg.lpgjavaruntime.*;

public class CSharpParser extends PrsStream implements RuleAction
{
    private static ParseTable prs = new CSharpParserprs();
    private BacktrackingParser btParser;

    public BacktrackingParser getParser() { return btParser; }
    private void setResult(Object object) { btParser.setSym1(object); }
    public Object getRhsSym(int i) { return btParser.getSym(i); }

    public int getRhsTokenIndex(int i) { return btParser.getToken(i); }
    public IToken getRhsIToken(int i) { return super.getIToken(getRhsTokenIndex(i)); }
    
    public int getRhsFirstTokenIndex(int i) { return btParser.getFirstToken(i); }
    public IToken getRhsFirstIToken(int i) { return super.getIToken(getRhsFirstTokenIndex(i)); }

    public int getRhsLastTokenIndex(int i) { return btParser.getLastToken(i); }
    public IToken getRhsLastIToken(int i) { return super.getIToken(getRhsLastTokenIndex(i)); }

    public int getLeftSpan() { return btParser.getFirstToken(); }
    public IToken getLeftIToken()  { return super.getIToken(getLeftSpan()); }

    public int getRightSpan() { return btParser.getLastToken(); }
    public IToken getRightIToken() { return super.getIToken(getRightSpan()); }

    public int getRhsErrorTokenIndex(int i)
    {
        int index = btParser.getToken(i);
        IToken err = super.getIToken(index);
        return (err instanceof ErrorToken ? index : 0);
    }
    public ErrorToken getRhsErrorIToken(int i)
    {
        int index = btParser.getToken(i);
        IToken err = super.getIToken(index);
        return (ErrorToken) (err instanceof ErrorToken ? err : null);
    }

    public CSharpParser(LexStream lexStream)
    {
        super(lexStream);

        try
        {
            super.remapTerminalSymbols(orderedTerminalSymbols(), CSharpParserprs.EOFT_SYMBOL);
        }
        catch(NullExportedSymbolsException e) {
        }
        catch(NullTerminalSymbolsException e) {
        }
        catch(UnimplementedTerminalsException e)
        {
            java.util.ArrayList unimplemented_symbols = e.getSymbols();
            System.out.println("The Lexer will not scan the following token(s):");
            for (int i = 0; i < unimplemented_symbols.size(); i++)
            {
                Integer id = (Integer) unimplemented_symbols.get(i);
                System.out.println("    " + CSharpParsersym.orderedTerminalSymbols[id.intValue()]);               
            }
            System.out.println();                        
        }
        catch(UndefinedEofSymbolException e)
        {
            throw new Error(new UndefinedEofSymbolException
                                ("The Lexer does not implement the Eof symbol " +
                                 CSharpParsersym.orderedTerminalSymbols[CSharpParserprs.EOFT_SYMBOL]));
        } 
    }

    public String[] orderedTerminalSymbols() { return CSharpParsersym.orderedTerminalSymbols; }
    public String getTokenKindName(int kind) { return CSharpParsersym.orderedTerminalSymbols[kind]; }
    public int getEOFTokenKind() { return CSharpParserprs.EOFT_SYMBOL; }
    public PrsStream getParseStream() { return (PrsStream) this; }
    
    //
    // Report error message for given error_token.
    //
    public final void reportErrorTokenMessage(int error_token, String msg)
    {
        int firsttok = super.getFirstErrorToken(error_token),
            lasttok = super.getLastErrorToken(error_token);
        String location = super.getFileName() + ':' +
                          (firsttok > lasttok
                                    ? (super.getEndLine(lasttok) + ":" + super.getEndColumn(lasttok))
                                    : (super.getLine(error_token) + ":" +
                                       super.getColumn(error_token) + ":" +
                                       super.getEndLine(error_token) + ":" +
                                       super.getEndColumn(error_token)))
                          + ": ";
        super.reportError((firsttok > lasttok ? ParseErrorCodes.INSERTION_CODE : ParseErrorCodes.SUBSTITUTION_CODE), location, msg);
    }

    public Ast parser()
    {
        return parser(null, 0);
    }
    
    public Ast parser(Monitor monitor)
    {
        return parser(monitor, 0);
    }
    
    public Ast parser(int error_repair_count)
    {
        return parser(null, error_repair_count);
    }

    public Ast parser(Monitor monitor, int error_repair_count)
    {
        try
        {
            btParser = new BacktrackingParser(monitor, (TokenStream) this, prs, (RuleAction) this);
        }
        catch (NotBacktrackParseTableException e)
        {
            throw new Error(new NotBacktrackParseTableException
                                ("Regenerate CSharpParserprs.java with -BACKTRACK option"));
        }
        catch (BadParseSymFileException e)
        {
            throw new Error(new BadParseSymFileException("Bad Parser Symbol File -- CSharpParsersym.java"));
        }

        try
        {
            return (Ast) btParser.parse(error_repair_count);
        }
        catch (BadParseException e)
        {
            reset(e.error_token); // point to error token
            DiagnoseParser diagnoseParser = new DiagnoseParser(this, prs);
            diagnoseParser.diagnose(e.error_token);
        }

        return null;
    }

    static public abstract class Ast
    {
        protected IToken leftIToken,
                         rightIToken;
        public IToken getLeftIToken() { return leftIToken; }
        public IToken getRightIToken() { return rightIToken; }
        public IToken[] getPrecedingAdjuncts() { return leftIToken.getPrecedingAdjuncts(); }
        public IToken[] getFollowingAdjuncts() { return rightIToken.getPrecedingAdjuncts(); }
        public String toString()
        {
            PrsStream prsStream = leftIToken.getPrsStream();
            return new String(prsStream.getInputChars(),
                              leftIToken.getStartOffset(),
                              rightIToken.getEndOffset() - leftIToken.getStartOffset() + 1);
        }
        public Ast(IToken token) { this.leftIToken = this.rightIToken = token; }
        public Ast(IToken leftIToken, IToken rightIToken)
        {
            this.leftIToken = leftIToken;
            this.rightIToken = rightIToken;
        }
        void initialize() {}
        /**
     * Since the Ast type has no children, any two instances of it are equal.
     */
    public boolean equals(Object o) { return o instanceof Ast; }
        public abstract int hashCode();
        public abstract void accept(Visitor v);
        public abstract void accept(ArgumentVisitor v, Object o);
        public abstract Object accept(ResultVisitor v);
        public abstract Object accept(ResultArgumentVisitor v, Object o);
    }

    static public abstract class AstList extends Ast
    {
        private boolean leftRecursive;
        private java.util.ArrayList list;
        public int size() { return list.size(); }
        public Ast getElementAt(int i) { return (Ast) list.get(leftRecursive ? i : list.size() - 1 - i); }
        public java.util.ArrayList getArrayList()
        {
            if (! leftRecursive) // reverse the list 
            {
                for (int i = 0, n = list.size() - 1; i < n; i++, n--)
                {
                    Object ith = list.get(i),
                           nth = list.get(n);
                    list.set(i, nth);
                    list.set(n, ith);
                }
                leftRecursive = true;
            }
            return list;
        }
        public void add(Ast element)
        {
            list.add(element);
            if (leftRecursive)
                 rightIToken = element.getRightIToken();
            else leftIToken = element.getLeftIToken();
        }

        public AstList(IToken leftIToken, IToken rightIToken, boolean leftRecursive)
        {
            super(leftIToken, rightIToken);
            this.leftRecursive = leftRecursive;
            list = new java.util.ArrayList();
        }

        public AstList(Ast element, boolean leftRecursive)
        {
            this(element.getLeftIToken(), element.getRightIToken(), leftRecursive);
            list.add(element);
        }
    
    public abstract boolean equals(Object o);
        public abstract int hashCode();
    }

    static public class AstToken extends Ast implements IAstToken
    {
        public AstToken(IToken token) { super(token); }
        public IToken getIToken() { return leftIToken; }
        public String toString() { return leftIToken.toString(); }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            if (! (o instanceof AstToken)) return false;
            AstToken other = (AstToken    ) o;
            return toString().equals(other.toString());
        }

        public int hashCode()
        {
            int hash = 7;
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by:
     *<b>
     *<ul>
     *<li>SemiOpt
     *<li>ExternOpt
     *<li>NewOpt
     *<li>PartialOpt
     *<li>IdentifierOpt
     *<li>Type
     *<li>SimpleType
     *<li>NumericType
     *<li>NullableType
     *<li>ThisAccess
     *<li>Block
     *<li>EmptyStatement
     *<li>MethodBody
     *<li>AccessorBody
     *<li>OperatorBody
     *<li>ConstructorBody
     *<li>FinalizerBody
     *<li>ArrayType
     *<li>AttributeTarget
     *<li>TypeParameter
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>NonNamedType0
     *<li>NonNamedType1
     *<li>IntegralType0
     *<li>IntegralType1
     *<li>IntegralType2
     *<li>IntegralType3
     *<li>IntegralType4
     *<li>IntegralType5
     *<li>IntegralType6
     *<li>IntegralType7
     *<li>IntegralType8
     *<li>FloatingPointType0
     *<li>FloatingPointType1
     *<li>ClassType0
     *<li>ClassType1
     *<li>PredefinedType0
     *<li>PredefinedType1
     *<li>PredefinedType2
     *<li>PredefinedType3
     *<li>PredefinedType4
     *<li>PredefinedType5
     *<li>PredefinedType6
     *<li>PredefinedType7
     *<li>PredefinedType8
     *<li>PredefinedType9
     *<li>PredefinedType10
     *<li>PredefinedType11
     *<li>PredefinedType12
     *<li>PredefinedType13
     *<li>PredefinedType14
     *<li>Commas0
     *<li>Commas1
     *<li>AssignmentOperator0
     *<li>AssignmentOperator1
     *<li>AssignmentOperator2
     *<li>AssignmentOperator3
     *<li>AssignmentOperator4
     *<li>AssignmentOperator5
     *<li>AssignmentOperator6
     *<li>AssignmentOperator7
     *<li>AssignmentOperator8
     *<li>AssignmentOperator9
     *<li>AssignmentOperator10
     *<li>LocalVariableDeclarator0
     *<li>LocalVariableDeclarator1
     *<li>Modifier0
     *<li>Modifier1
     *<li>Modifier2
     *<li>Modifier3
     *<li>Modifier4
     *<li>Modifier5
     *<li>Modifier6
     *<li>Modifier7
     *<li>Modifier8
     *<li>Modifier9
     *<li>Modifier10
     *<li>Modifier11
     *<li>Modifier12
     *<li>VariableDeclarator0
     *<li>VariableDeclarator1
     *<li>ParameterModifier0
     *<li>ParameterModifier1
     *<li>AccessorModifier0
     *<li>AccessorModifier1
     *<li>AccessorModifier2
     *<li>AccessorModifier3
     *<li>AccessorModifier4
     *<li>OverloadableOperator0
     *<li>OverloadableOperator1
     *<li>OverloadableOperator2
     *<li>OverloadableOperator3
     *<li>OverloadableOperator4
     *<li>OverloadableOperator5
     *<li>OverloadableOperator6
     *<li>OverloadableOperator7
     *<li>OverloadableOperator8
     *<li>OverloadableOperator9
     *<li>OverloadableOperator10
     *<li>OverloadableOperator11
     *<li>OverloadableOperator12
     *<li>OverloadableOperator13
     *<li>OverloadableOperator14
     *<li>OverloadableOperator15
     *<li>OverloadableOperator16
     *<li>OverloadableOperator17
     *<li>OverloadableOperator18
     *<li>OverloadableOperator19
     *<li>OverloadableOperator20
     *<li>OverloadableOperator21
     *<li>DimSeparators0
     *<li>DimSeparators1
     *<li>Keyword0
     *<li>Keyword1
     *<li>Keyword2
     *<li>Keyword3
     *<li>Keyword4
     *<li>Keyword5
     *<li>Keyword6
     *<li>Keyword7
     *<li>Keyword8
     *<li>Keyword9
     *<li>Keyword10
     *<li>Keyword11
     *<li>Keyword12
     *<li>Keyword13
     *<li>Keyword14
     *<li>Keyword15
     *<li>Keyword16
     *<li>Keyword17
     *<li>Keyword18
     *<li>Keyword19
     *<li>Keyword20
     *<li>Keyword21
     *<li>Keyword22
     *<li>Keyword23
     *<li>Keyword24
     *<li>Keyword25
     *<li>Keyword26
     *<li>Keyword27
     *<li>Keyword28
     *<li>Keyword29
     *<li>Keyword30
     *<li>Keyword31
     *<li>Keyword32
     *<li>Keyword33
     *<li>Keyword34
     *<li>Keyword35
     *<li>Keyword36
     *<li>Keyword37
     *<li>Keyword38
     *<li>Keyword39
     *<li>Keyword40
     *<li>Keyword41
     *<li>Keyword42
     *<li>Keyword43
     *<li>Keyword44
     *<li>Keyword45
     *<li>Keyword46
     *<li>Keyword47
     *<li>Keyword48
     *<li>Keyword49
     *<li>Keyword50
     *<li>Keyword51
     *<li>Keyword52
     *<li>Keyword53
     *<li>Keyword54
     *<li>Keyword55
     *<li>Keyword56
     *<li>Keyword57
     *<li>Keyword58
     *<li>Keyword59
     *<li>Keyword60
     *<li>Keyword61
     *<li>Keyword62
     *<li>Keyword63
     *<li>Keyword64
     *<li>Keyword65
     *<li>Keyword66
     *<li>Keyword67
     *<li>Keyword68
     *<li>Keyword69
     *<li>Keyword70
     *<li>Keyword71
     *<li>Keyword72
     *<li>Keyword73
     *<li>Keyword74
     *<li>Keyword75
     *<li>Keyword76
     *<li>Keyword77
     *<li>Keyword78
     *<li>Keyword79
     *<li>Keyword80
     *<li>Keyword81
     *<li>Keyword82
     *<li>Keyword83
     *<li>Keyword84
     *<li>Constraint0
     *<li>Constraint1
     *</ul>
     *</b>
     */
    public interface IAstToken
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>CompilationUnit</b>
     */
    public interface ICompilationUnit
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by <b>SemiOpt</b>
     */
    public interface ISemiOpt extends IAstToken {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by <b>ExternOpt</b>
     */
    public interface IExternOpt extends IAstToken {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by <b>NewOpt</b>
     */
    public interface INewOpt extends IAstToken {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by <b>PartialOpt</b>
     */
    public interface IPartialOpt extends IAstToken {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by <b>IdentifierOpt</b>
     */
    public interface IIdentifierOpt extends IAstToken {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by:
     *<b>
     *<ul>
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *</ul>
     *</b>
     */
    public interface ILiteral extends IPrimaryNoArrayCreationExpression {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by:
     *<b>
     *<ul>
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *</ul>
     *</b>
     */
    public interface IBooleanLiteral extends ILiteral, IAstToken {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ExternAliasDirectives
     *<li>ExternAliasDirective
     *</ul>
     *</b>
     */
    public interface IExternAliasDirectivesOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>UsingDirectives
     *<li>UsingAliasDirective
     *<li>UsingNamespaceDirective
     *</ul>
     *</b>
     */
    public interface IUsingDirectivesOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>NamespaceDeclaration
     *<li>NamespaceMemberDeclarations
     *<li>ClassDeclaration
     *<li>StructDeclaration
     *<li>InterfaceDeclaration
     *<li>EnumDeclaration
     *<li>DelegateDeclaration
     *</ul>
     *</b>
     */
    public interface INamespaceMemberDeclarationsOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *</ul>
     *</b>
     */
    public interface IName extends IClassType, IPrimaryExpression, IInterfaceBase, IAttributeName {}

    /**
     * is implemented by <b>TypeArgumentList</b>
     */
    public interface ITypeArgumentListOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Type
     *<li>SimpleType
     *<li>NumericType
     *<li>NullableType
     *<li>ArrayType
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>IntegralType0
     *<li>IntegralType1
     *<li>IntegralType2
     *<li>IntegralType3
     *<li>IntegralType4
     *<li>IntegralType5
     *<li>IntegralType6
     *<li>IntegralType7
     *<li>IntegralType8
     *<li>FloatingPointType0
     *<li>FloatingPointType1
     *<li>ClassType0
     *<li>ClassType1
     *</ul>
     *</b>
     */
    public interface IType extends IAstToken, ITypeArgument {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by:
     *<b>
     *<ul>
     *<li>SimpleType
     *<li>NumericType
     *<li>IntegralType0
     *<li>IntegralType1
     *<li>IntegralType2
     *<li>IntegralType3
     *<li>IntegralType4
     *<li>IntegralType5
     *<li>IntegralType6
     *<li>IntegralType7
     *<li>IntegralType8
     *<li>FloatingPointType0
     *<li>FloatingPointType1
     *</ul>
     *</b>
     */
    public interface ISimpleType extends IType, INonNamedType, IAstToken, INonArrayType {}

    /**
     * is implemented by <b>NullableType</b>
     */
    public interface INullableType extends IType, INonNamedType, INonArrayType {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>ClassType0
     *<li>ClassType1
     *</ul>
     *</b>
     */
    public interface IClassType extends IType, IAstToken, IClassBase, IStructInterfaces, INonArrayType, IConstraint {}

    /**
     * is implemented by <b>ArrayType</b>
     */
    public interface IArrayType extends IType, INonNamedType {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>SimpleType
     *<li>NumericType
     *<li>NullableType
     *<li>ArrayType
     *<li>NonNamedType0
     *<li>NonNamedType1
     *<li>IntegralType0
     *<li>IntegralType1
     *<li>IntegralType2
     *<li>IntegralType3
     *<li>IntegralType4
     *<li>IntegralType5
     *<li>IntegralType6
     *<li>IntegralType7
     *<li>IntegralType8
     *<li>FloatingPointType0
     *<li>FloatingPointType1
     *</ul>
     *</b>
     */
    public interface INonNamedType extends IAstToken {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by:
     *<b>
     *<ul>
     *<li>NumericType
     *<li>IntegralType0
     *<li>IntegralType1
     *<li>IntegralType2
     *<li>IntegralType3
     *<li>IntegralType4
     *<li>IntegralType5
     *<li>IntegralType6
     *<li>IntegralType7
     *<li>IntegralType8
     *<li>FloatingPointType0
     *<li>FloatingPointType1
     *</ul>
     *</b>
     */
    public interface INumericType extends ISimpleType, IAstToken {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by:
     *<b>
     *<ul>
     *<li>IntegralType0
     *<li>IntegralType1
     *<li>IntegralType2
     *<li>IntegralType3
     *<li>IntegralType4
     *<li>IntegralType5
     *<li>IntegralType6
     *<li>IntegralType7
     *<li>IntegralType8
     *</ul>
     *</b>
     */
    public interface IIntegralType extends INumericType, IAstToken {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by:
     *<b>
     *<ul>
     *<li>FloatingPointType0
     *<li>FloatingPointType1
     *</ul>
     *</b>
     */
    public interface IFloatingPointType extends INumericType, IAstToken {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IVariableReference
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IExpression extends IVariableReference, IArgument, IExpressionList, IExpressionOpt, IConstantExpression, IBooleanExpression, ILocalVariableInitializer, IResourceAcquisition, IVariableInitializer, IAttributeArgumentExpression {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ArgumentList
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>Argument0
     *<li>Argument1
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IArgumentListOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ArgumentList
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>Argument0
     *<li>Argument1
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IArgumentList extends IArgumentListOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>Argument0
     *<li>Argument1
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IArgument extends IArgumentList {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *</ul>
     *</b>
     */
    public interface IPrimaryExpression extends IUnaryExpression {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *</ul>
     *</b>
     */
    public interface IArrayCreationExpression extends IPrimaryExpression {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *</ul>
     *</b>
     */
    public interface IPrimaryNoArrayCreationExpression extends IPrimaryExpression {}

    /**
     * is implemented by <b>ParenthesizedExpression</b>
     */
    public interface IParenthesizedExpression extends IPrimaryNoArrayCreationExpression {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *</ul>
     *</b>
     */
    public interface IMemberAccess extends IPrimaryNoArrayCreationExpression {}

    /**
     * is implemented by <b>InvocationExpression</b>
     */
    public interface IInvocationExpression extends IPrimaryNoArrayCreationExpression, IStatementExpression {}

    /**
     * is implemented by <b>ElementAccess</b>
     */
    public interface IElementAccess extends IPrimaryNoArrayCreationExpression {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by <b>ThisAccess</b>
     */
    public interface IThisAccess extends IPrimaryNoArrayCreationExpression, IAstToken {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>BaseAccess0
     *<li>BaseAccess1
     *</ul>
     *</b>
     */
    public interface IBaseAccess extends IPrimaryNoArrayCreationExpression {}

    /**
     * is implemented by <b>PostIncrementExpression</b>
     */
    public interface IPostIncrementExpression extends IPrimaryNoArrayCreationExpression, IStatementExpression {}

    /**
     * is implemented by <b>PostDecrementExpression</b>
     */
    public interface IPostDecrementExpression extends IPrimaryNoArrayCreationExpression, IStatementExpression {}

    /**
     * is implemented by <b>ObjectCreationExpression</b>
     */
    public interface IObjectCreationExpression extends IPrimaryNoArrayCreationExpression, IStatementExpression {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *</ul>
     *</b>
     */
    public interface ITypeofExpression extends IPrimaryNoArrayCreationExpression {}

    /**
     * is implemented by <b>CheckedExpression</b>
     */
    public interface ICheckedExpression extends IPrimaryNoArrayCreationExpression {}

    /**
     * is implemented by <b>UncheckedExpression</b>
     */
    public interface IUncheckedExpression extends IPrimaryNoArrayCreationExpression {}

    /**
     * is implemented by <b>DefaultValueExpression</b>
     */
    public interface IDefaultValueExpression extends IPrimaryNoArrayCreationExpression {}

    /**
     * is implemented by <b>AnonymousMethodExpression</b>
     */
    public interface IAnonymousMethodExpression extends IPrimaryNoArrayCreationExpression {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by:
     *<b>
     *<ul>
     *<li>PredefinedType0
     *<li>PredefinedType1
     *<li>PredefinedType2
     *<li>PredefinedType3
     *<li>PredefinedType4
     *<li>PredefinedType5
     *<li>PredefinedType6
     *<li>PredefinedType7
     *<li>PredefinedType8
     *<li>PredefinedType9
     *<li>PredefinedType10
     *<li>PredefinedType11
     *<li>PredefinedType12
     *<li>PredefinedType13
     *<li>PredefinedType14
     *</ul>
     *</b>
     */
    public interface IPredefinedType extends IAstToken {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ExpressionList
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IExpressionList
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>SimpleType
     *<li>NumericType
     *<li>NullableType
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>IntegralType0
     *<li>IntegralType1
     *<li>IntegralType2
     *<li>IntegralType3
     *<li>IntegralType4
     *<li>IntegralType5
     *<li>IntegralType6
     *<li>IntegralType7
     *<li>IntegralType8
     *<li>FloatingPointType0
     *<li>FloatingPointType1
     *<li>ClassType0
     *<li>ClassType1
     *</ul>
     *</b>
     */
    public interface INonArrayType
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>RankSpecifiers
     *<li>RankSpecifier
     *</ul>
     *</b>
     */
    public interface IRankSpecifiersOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ArrayInitializer0
     *<li>ArrayInitializer1
     *</ul>
     *</b>
     */
    public interface IArrayInitializerOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ArrayInitializer0
     *<li>ArrayInitializer1
     *</ul>
     *</b>
     */
    public interface IArrayInitializer extends ILocalVariableInitializer, IVariableInitializer, IArrayInitializerOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>UnboundTypeName0
     *<li>UnboundTypeName1
     *<li>UnboundTypeName2
     *</ul>
     *</b>
     */
    public interface IUnboundTypeName
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>GenericDimensionSpecifier</b>
     */
    public interface IGenericDimensionSpecifierOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>GenericDimensionSpecifier</b>
     */
    public interface IGenericDimensionSpecifier extends IGenericDimensionSpecifierOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Commas0
     *<li>Commas1
     *</ul>
     *</b>
     */
    public interface ICommasOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Commas0
     *<li>Commas1
     *</ul>
     *</b>
     */
    public interface ICommas extends ICommasOpt, IAstToken {}

    /**
     * is implemented by <b>AnonymousMethodSignature</b>
     */
    public interface IAnonymousMethodSignatureOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>Block</b>
     */
    public interface IBlock extends IEmbeddedStatement, IMethodBody, IAccessorBody, IOperatorBody, IConstructorBody, IFinalizerBody {}

    /**
     * is implemented by <b>AnonymousMethodSignature</b>
     */
    public interface IAnonymousMethodSignature extends IAnonymousMethodSignatureOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>AnonymousMethodParameterList
     *<li>AnonymousMethodParameter
     *</ul>
     *</b>
     */
    public interface IAnonymousMethodParameterListOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>AnonymousMethodParameterList
     *<li>AnonymousMethodParameter
     *</ul>
     *</b>
     */
    public interface IAnonymousMethodParameterList extends IAnonymousMethodParameterListOpt {}

    /**
     * is implemented by <b>AnonymousMethodParameter</b>
     */
    public interface IAnonymousMethodParameter extends IAnonymousMethodParameterList {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by:
     *<b>
     *<ul>
     *<li>ParameterModifier0
     *<li>ParameterModifier1
     *</ul>
     *</b>
     */
    public interface IParameterModifierOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *</ul>
     *</b>
     */
    public interface IUnaryExpression extends IMultiplicativeExpression {}

    /**
     * is implemented by <b>PreIncrementExpression</b>
     */
    public interface IPreIncrementExpression extends IUnaryExpression, IStatementExpression {}

    /**
     * is implemented by <b>PreDecrementExpression</b>
     */
    public interface IPreDecrementExpression extends IUnaryExpression, IStatementExpression {}

    /**
     * is implemented by <b>CastExpression</b>
     */
    public interface ICastExpression extends IUnaryExpression {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *</ul>
     *</b>
     */
    public interface IMultiplicativeExpression extends IAdditiveExpression {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *</ul>
     *</b>
     */
    public interface IAdditiveExpression extends IShiftExpression {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *</ul>
     *</b>
     */
    public interface IShiftExpression extends IRelationalExpression {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *</ul>
     *</b>
     */
    public interface IRelationalExpression extends IEqualityExpression {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IEqualityExpression extends IAndExpression {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IAndExpression extends IExclusiveOrExpression {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IExclusiveOrExpression extends IInclusiveOrExpression {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IInclusiveOrExpression extends IConditionalAndExpression {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IConditionalAndExpression extends IConditionalOrExpression {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IConditionalOrExpression extends INullCoalescingExpression {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface INullCoalescingExpression extends IConditionalExpression {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IConditionalExpression extends IExpression {}

    /**
     * is implemented by <b>Assignment</b>
     */
    public interface IAssignment extends IExpression, IStatementExpression {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by:
     *<b>
     *<ul>
     *<li>AssignmentOperator0
     *<li>AssignmentOperator1
     *<li>AssignmentOperator2
     *<li>AssignmentOperator3
     *<li>AssignmentOperator4
     *<li>AssignmentOperator5
     *<li>AssignmentOperator6
     *<li>AssignmentOperator7
     *<li>AssignmentOperator8
     *<li>AssignmentOperator9
     *<li>AssignmentOperator10
     *</ul>
     *</b>
     */
    public interface IAssignmentOperator extends IAstToken {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IExpressionOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IConstantExpression
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IBooleanExpression extends IForCondition {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Block
     *<li>EmptyStatement
     *<li>LabeledStatement
     *<li>ExpressionStatement
     *<li>IfStatement
     *<li>ElseStatement
     *<li>SwitchStatement
     *<li>WhileStatement
     *<li>DoStatement
     *<li>ForStatement
     *<li>ForeachStatement
     *<li>BreakStatement
     *<li>ContinueStatement
     *<li>ReturnStatement
     *<li>ThrowStatement
     *<li>CheckedStatement
     *<li>UncheckedStatement
     *<li>LockStatement
     *<li>UsingStatement
     *<li>DeclarationStatement0
     *<li>DeclarationStatement1
     *<li>GotoStatement0
     *<li>GotoStatement1
     *<li>GotoStatement2
     *<li>TryStatement0
     *<li>TryStatement1
     *<li>YieldStatement0
     *<li>YieldStatement1
     *</ul>
     *</b>
     */
    public interface IStatement extends IStatementList {}

    /**
     * is implemented by <b>LabeledStatement</b>
     */
    public interface ILabeledStatement extends IStatement {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>DeclarationStatement0
     *<li>DeclarationStatement1
     *</ul>
     *</b>
     */
    public interface IDeclarationStatement extends IStatement {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Block
     *<li>EmptyStatement
     *<li>ExpressionStatement
     *<li>IfStatement
     *<li>ElseStatement
     *<li>SwitchStatement
     *<li>WhileStatement
     *<li>DoStatement
     *<li>ForStatement
     *<li>ForeachStatement
     *<li>BreakStatement
     *<li>ContinueStatement
     *<li>ReturnStatement
     *<li>ThrowStatement
     *<li>CheckedStatement
     *<li>UncheckedStatement
     *<li>LockStatement
     *<li>UsingStatement
     *<li>GotoStatement0
     *<li>GotoStatement1
     *<li>GotoStatement2
     *<li>TryStatement0
     *<li>TryStatement1
     *<li>YieldStatement0
     *<li>YieldStatement1
     *</ul>
     *</b>
     */
    public interface IEmbeddedStatement extends IStatement {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by <b>EmptyStatement</b>
     */
    public interface IEmptyStatement extends IEmbeddedStatement, IAstToken {}

    /**
     * is implemented by <b>ExpressionStatement</b>
     */
    public interface IExpressionStatement extends IEmbeddedStatement {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>IfStatement
     *<li>ElseStatement
     *<li>SwitchStatement
     *</ul>
     *</b>
     */
    public interface ISelectionStatement extends IEmbeddedStatement {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>WhileStatement
     *<li>DoStatement
     *<li>ForStatement
     *<li>ForeachStatement
     *</ul>
     *</b>
     */
    public interface IIterationStatement extends IEmbeddedStatement {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>BreakStatement
     *<li>ContinueStatement
     *<li>ReturnStatement
     *<li>ThrowStatement
     *<li>GotoStatement0
     *<li>GotoStatement1
     *<li>GotoStatement2
     *</ul>
     *</b>
     */
    public interface IJumpStatement extends IEmbeddedStatement {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>TryStatement0
     *<li>TryStatement1
     *</ul>
     *</b>
     */
    public interface ITryStatement extends IEmbeddedStatement {}

    /**
     * is implemented by <b>CheckedStatement</b>
     */
    public interface ICheckedStatement extends IEmbeddedStatement {}

    /**
     * is implemented by <b>UncheckedStatement</b>
     */
    public interface IUncheckedStatement extends IEmbeddedStatement {}

    /**
     * is implemented by <b>LockStatement</b>
     */
    public interface ILockStatement extends IEmbeddedStatement {}

    /**
     * is implemented by <b>UsingStatement</b>
     */
    public interface IUsingStatement extends IEmbeddedStatement {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>YieldStatement0
     *<li>YieldStatement1
     *</ul>
     *</b>
     */
    public interface IYieldStatement extends IEmbeddedStatement {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Block
     *<li>StatementList
     *<li>EmptyStatement
     *<li>LabeledStatement
     *<li>ExpressionStatement
     *<li>IfStatement
     *<li>ElseStatement
     *<li>SwitchStatement
     *<li>WhileStatement
     *<li>DoStatement
     *<li>ForStatement
     *<li>ForeachStatement
     *<li>BreakStatement
     *<li>ContinueStatement
     *<li>ReturnStatement
     *<li>ThrowStatement
     *<li>CheckedStatement
     *<li>UncheckedStatement
     *<li>LockStatement
     *<li>UsingStatement
     *<li>DeclarationStatement0
     *<li>DeclarationStatement1
     *<li>GotoStatement0
     *<li>GotoStatement1
     *<li>GotoStatement2
     *<li>TryStatement0
     *<li>TryStatement1
     *<li>YieldStatement0
     *<li>YieldStatement1
     *</ul>
     *</b>
     */
    public interface IStatementListOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Block
     *<li>StatementList
     *<li>EmptyStatement
     *<li>LabeledStatement
     *<li>ExpressionStatement
     *<li>IfStatement
     *<li>ElseStatement
     *<li>SwitchStatement
     *<li>WhileStatement
     *<li>DoStatement
     *<li>ForStatement
     *<li>ForeachStatement
     *<li>BreakStatement
     *<li>ContinueStatement
     *<li>ReturnStatement
     *<li>ThrowStatement
     *<li>CheckedStatement
     *<li>UncheckedStatement
     *<li>LockStatement
     *<li>UsingStatement
     *<li>DeclarationStatement0
     *<li>DeclarationStatement1
     *<li>GotoStatement0
     *<li>GotoStatement1
     *<li>GotoStatement2
     *<li>TryStatement0
     *<li>TryStatement1
     *<li>YieldStatement0
     *<li>YieldStatement1
     *</ul>
     *</b>
     */
    public interface IStatementList extends IStatementListOpt {}

    /**
     * is implemented by <b>LocalVariableDeclaration</b>
     */
    public interface ILocalVariableDeclaration extends IForInitializer, IResourceAcquisition {}

    /**
     * is implemented by <b>LocalConstantDeclaration</b>
     */
    public interface ILocalConstantDeclaration
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>LocalVariableDeclarators
     *<li>LocalVariableDeclarator0
     *<li>LocalVariableDeclarator1
     *</ul>
     *</b>
     */
    public interface ILocalVariableDeclarators
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>LocalVariableDeclarator0
     *<li>LocalVariableDeclarator1
     *</ul>
     *</b>
     */
    public interface ILocalVariableDeclarator extends ILocalVariableDeclarators, IAstToken {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *<li>ArrayInitializer0
     *<li>ArrayInitializer1
     *</ul>
     *</b>
     */
    public interface ILocalVariableInitializer
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ConstantDeclarators
     *<li>ConstantDeclarator
     *</ul>
     *</b>
     */
    public interface IConstantDeclarators
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>InvocationExpression
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>Assignment
     *</ul>
     *</b>
     */
    public interface IStatementExpression extends IStatementExpressionList {}

    /**
     * is implemented by <b>IfStatement</b>
     */
    public interface IIfStatement extends ISelectionStatement {}

    /**
     * is implemented by <b>ElseStatement</b>
     */
    public interface IElseStatement extends ISelectionStatement {}

    /**
     * is implemented by <b>SwitchStatement</b>
     */
    public interface ISwitchStatement extends ISelectionStatement {}

    /**
     * is implemented by <b>SwitchBlock</b>
     */
    public interface ISwitchBlock
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>SwitchSections
     *<li>SwitchSection
     *</ul>
     *</b>
     */
    public interface ISwitchSectionsOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>SwitchSections
     *<li>SwitchSection
     *</ul>
     *</b>
     */
    public interface ISwitchSections extends ISwitchSectionsOpt {}

    /**
     * is implemented by <b>SwitchSection</b>
     */
    public interface ISwitchSection extends ISwitchSections {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>SwitchLabels
     *<li>SwitchLabel0
     *<li>SwitchLabel1
     *</ul>
     *</b>
     */
    public interface ISwitchLabels
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>SwitchLabel0
     *<li>SwitchLabel1
     *</ul>
     *</b>
     */
    public interface ISwitchLabel extends ISwitchLabels {}

    /**
     * is implemented by <b>WhileStatement</b>
     */
    public interface IWhileStatement extends IIterationStatement {}

    /**
     * is implemented by <b>DoStatement</b>
     */
    public interface IDoStatement extends IIterationStatement {}

    /**
     * is implemented by <b>ForStatement</b>
     */
    public interface IForStatement extends IIterationStatement {}

    /**
     * is implemented by <b>ForeachStatement</b>
     */
    public interface IForeachStatement extends IIterationStatement {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>InvocationExpression
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>Assignment
     *<li>LocalVariableDeclaration
     *<li>StatementExpressionList
     *</ul>
     *</b>
     */
    public interface IForInitializerOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IForConditionOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>InvocationExpression
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>Assignment
     *<li>StatementExpressionList
     *</ul>
     *</b>
     */
    public interface IForIteratorOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>InvocationExpression
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>Assignment
     *<li>LocalVariableDeclaration
     *<li>StatementExpressionList
     *</ul>
     *</b>
     */
    public interface IForInitializer extends IForInitializerOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>InvocationExpression
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>Assignment
     *<li>StatementExpressionList
     *</ul>
     *</b>
     */
    public interface IStatementExpressionList extends IForInitializer, IForIterator {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IForCondition extends IForConditionOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>InvocationExpression
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>Assignment
     *<li>StatementExpressionList
     *</ul>
     *</b>
     */
    public interface IForIterator extends IForIteratorOpt {}

    /**
     * is implemented by <b>BreakStatement</b>
     */
    public interface IBreakStatement extends IJumpStatement {}

    /**
     * is implemented by <b>ContinueStatement</b>
     */
    public interface IContinueStatement extends IJumpStatement {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>GotoStatement0
     *<li>GotoStatement1
     *<li>GotoStatement2
     *</ul>
     *</b>
     */
    public interface IGotoStatement extends IJumpStatement {}

    /**
     * is implemented by <b>ReturnStatement</b>
     */
    public interface IReturnStatement extends IJumpStatement {}

    /**
     * is implemented by <b>ThrowStatement</b>
     */
    public interface IThrowStatement extends IJumpStatement {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>CatchClauses
     *<li>SpecificCatchClauses
     *<li>SpecificCatchClause
     *</ul>
     *</b>
     */
    public interface ICatchClauses extends ICatchClausesOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>CatchClauses
     *<li>SpecificCatchClauses
     *<li>SpecificCatchClause
     *</ul>
     *</b>
     */
    public interface ICatchClausesOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>FinallyClause</b>
     */
    public interface IFinallyClause
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>SpecificCatchClauses
     *<li>SpecificCatchClause
     *</ul>
     *</b>
     */
    public interface ISpecificCatchClauses extends ICatchClauses, ISpecificCatchClausesOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>SpecificCatchClauses
     *<li>SpecificCatchClause
     *</ul>
     *</b>
     */
    public interface ISpecificCatchClausesOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>GeneralCatchClause</b>
     */
    public interface IGeneralCatchClause
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>SpecificCatchClause</b>
     */
    public interface ISpecificCatchClause extends ISpecificCatchClauses {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>LocalVariableDeclaration
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IResourceAcquisition
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>NamespaceDeclaration</b>
     */
    public interface INamespaceDeclaration extends INamespaceMemberDeclaration {}

    /**
     * is implemented by <b>NamespaceBody</b>
     */
    public interface INamespaceBody
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ExternAliasDirectives
     *<li>ExternAliasDirective
     *</ul>
     *</b>
     */
    public interface IExternAliasDirectives extends IExternAliasDirectivesOpt {}

    /**
     * is implemented by <b>ExternAliasDirective</b>
     */
    public interface IExternAliasDirective extends IExternAliasDirectives {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>UsingDirectives
     *<li>UsingAliasDirective
     *<li>UsingNamespaceDirective
     *</ul>
     *</b>
     */
    public interface IUsingDirectives extends IUsingDirectivesOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>UsingAliasDirective
     *<li>UsingNamespaceDirective
     *</ul>
     *</b>
     */
    public interface IUsingDirective extends IUsingDirectives {}

    /**
     * is implemented by <b>UsingAliasDirective</b>
     */
    public interface IUsingAliasDirective extends IUsingDirective {}

    /**
     * is implemented by <b>UsingNamespaceDirective</b>
     */
    public interface IUsingNamespaceDirective extends IUsingDirective {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>NamespaceDeclaration
     *<li>NamespaceMemberDeclarations
     *<li>ClassDeclaration
     *<li>StructDeclaration
     *<li>InterfaceDeclaration
     *<li>EnumDeclaration
     *<li>DelegateDeclaration
     *</ul>
     *</b>
     */
    public interface INamespaceMemberDeclarations extends INamespaceMemberDeclarationsOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>NamespaceDeclaration
     *<li>ClassDeclaration
     *<li>StructDeclaration
     *<li>InterfaceDeclaration
     *<li>EnumDeclaration
     *<li>DelegateDeclaration
     *</ul>
     *</b>
     */
    public interface INamespaceMemberDeclaration extends INamespaceMemberDeclarations {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ClassDeclaration
     *<li>StructDeclaration
     *<li>InterfaceDeclaration
     *<li>EnumDeclaration
     *<li>DelegateDeclaration
     *</ul>
     *</b>
     */
    public interface ITypeDeclaration extends INamespaceMemberDeclaration, IClassMemberDeclaration, IStructMemberDeclaration {}

    /**
     * is implemented by <b>ClassDeclaration</b>
     */
    public interface IClassDeclaration extends ITypeDeclaration {}

    /**
     * is implemented by <b>StructDeclaration</b>
     */
    public interface IStructDeclaration extends ITypeDeclaration {}

    /**
     * is implemented by <b>InterfaceDeclaration</b>
     */
    public interface IInterfaceDeclaration extends ITypeDeclaration {}

    /**
     * is implemented by <b>EnumDeclaration</b>
     */
    public interface IEnumDeclaration extends ITypeDeclaration {}

    /**
     * is implemented by <b>DelegateDeclaration</b>
     */
    public interface IDelegateDeclaration extends ITypeDeclaration {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Modifiers
     *<li>Modifier0
     *<li>Modifier1
     *<li>Modifier2
     *<li>Modifier3
     *<li>Modifier4
     *<li>Modifier5
     *<li>Modifier6
     *<li>Modifier7
     *<li>Modifier8
     *<li>Modifier9
     *<li>Modifier10
     *<li>Modifier11
     *<li>Modifier12
     *</ul>
     *</b>
     */
    public interface IModifiersOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Modifiers
     *<li>Modifier0
     *<li>Modifier1
     *<li>Modifier2
     *<li>Modifier3
     *<li>Modifier4
     *<li>Modifier5
     *<li>Modifier6
     *<li>Modifier7
     *<li>Modifier8
     *<li>Modifier9
     *<li>Modifier10
     *<li>Modifier11
     *<li>Modifier12
     *</ul>
     *</b>
     */
    public interface IModifiers extends IModifiersOpt {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by:
     *<b>
     *<ul>
     *<li>Modifier0
     *<li>Modifier1
     *<li>Modifier2
     *<li>Modifier3
     *<li>Modifier4
     *<li>Modifier5
     *<li>Modifier6
     *<li>Modifier7
     *<li>Modifier8
     *<li>Modifier9
     *<li>Modifier10
     *<li>Modifier11
     *<li>Modifier12
     *</ul>
     *</b>
     */
    public interface IModifier extends IModifiers, IAstToken {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>AttributeSections
     *<li>AttributeSection0
     *<li>AttributeSection1
     *</ul>
     *</b>
     */
    public interface IAttributesOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>TypeParameterList</b>
     */
    public interface ITypeParameterListOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>ClassBaseOpt</b>
     */
    public interface IClassBaseOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>TypeParameterConstraintsClauses
     *<li>TypeParameterConstraintsClause
     *</ul>
     *</b>
     */
    public interface ITypeParameterConstraintsClausesOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>ClassBody</b>
     */
    public interface IClassBody
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ClassBase
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>ClassType0
     *<li>ClassType1
     *</ul>
     *</b>
     */
    public interface IClassBase
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ClassDeclaration
     *<li>ClassMemberDeclarations
     *<li>ConstantDeclaration
     *<li>FieldDeclaration
     *<li>MethodDeclaration
     *<li>PropertyDeclaration
     *<li>IndexerDeclaration
     *<li>OperatorDeclaration
     *<li>ConstructorDeclaration
     *<li>FinalizerDeclaration
     *<li>StructDeclaration
     *<li>InterfaceDeclaration
     *<li>EnumDeclaration
     *<li>DelegateDeclaration
     *<li>EventDeclaration0
     *<li>EventDeclaration1
     *</ul>
     *</b>
     */
    public interface IClassMemberDeclarationsOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ClassDeclaration
     *<li>ClassMemberDeclarations
     *<li>ConstantDeclaration
     *<li>FieldDeclaration
     *<li>MethodDeclaration
     *<li>PropertyDeclaration
     *<li>IndexerDeclaration
     *<li>OperatorDeclaration
     *<li>ConstructorDeclaration
     *<li>FinalizerDeclaration
     *<li>StructDeclaration
     *<li>InterfaceDeclaration
     *<li>EnumDeclaration
     *<li>DelegateDeclaration
     *<li>EventDeclaration0
     *<li>EventDeclaration1
     *</ul>
     *</b>
     */
    public interface IClassMemberDeclarations extends IClassMemberDeclarationsOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ClassDeclaration
     *<li>ConstantDeclaration
     *<li>FieldDeclaration
     *<li>MethodDeclaration
     *<li>PropertyDeclaration
     *<li>IndexerDeclaration
     *<li>OperatorDeclaration
     *<li>ConstructorDeclaration
     *<li>FinalizerDeclaration
     *<li>StructDeclaration
     *<li>InterfaceDeclaration
     *<li>EnumDeclaration
     *<li>DelegateDeclaration
     *<li>EventDeclaration0
     *<li>EventDeclaration1
     *</ul>
     *</b>
     */
    public interface IClassMemberDeclaration extends IClassMemberDeclarations {}

    /**
     * is implemented by <b>ConstantDeclaration</b>
     */
    public interface IConstantDeclaration extends IClassMemberDeclaration, IStructMemberDeclaration {}

    /**
     * is implemented by <b>FieldDeclaration</b>
     */
    public interface IFieldDeclaration extends IClassMemberDeclaration, IStructMemberDeclaration {}

    /**
     * is implemented by <b>MethodDeclaration</b>
     */
    public interface IMethodDeclaration extends IClassMemberDeclaration, IStructMemberDeclaration {}

    /**
     * is implemented by <b>PropertyDeclaration</b>
     */
    public interface IPropertyDeclaration extends IClassMemberDeclaration, IStructMemberDeclaration {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>EventDeclaration0
     *<li>EventDeclaration1
     *</ul>
     *</b>
     */
    public interface IEventDeclaration extends IClassMemberDeclaration, IStructMemberDeclaration {}

    /**
     * is implemented by <b>IndexerDeclaration</b>
     */
    public interface IIndexerDeclaration extends IClassMemberDeclaration, IStructMemberDeclaration {}

    /**
     * is implemented by <b>OperatorDeclaration</b>
     */
    public interface IOperatorDeclaration extends IClassMemberDeclaration, IStructMemberDeclaration {}

    /**
     * is implemented by <b>ConstructorDeclaration</b>
     */
    public interface IConstructorDeclaration extends IClassMemberDeclaration, IStructMemberDeclaration {}

    /**
     * is implemented by <b>FinalizerDeclaration</b>
     */
    public interface IFinalizerDeclaration extends IClassMemberDeclaration {}

    /**
     * is implemented by <b>ConstantDeclarator</b>
     */
    public interface IConstantDeclarator extends IConstantDeclarators {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>VariableDeclarators
     *<li>VariableDeclarator0
     *<li>VariableDeclarator1
     *</ul>
     *</b>
     */
    public interface IVariableDeclarators
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>VariableDeclarator0
     *<li>VariableDeclarator1
     *</ul>
     *</b>
     */
    public interface IVariableDeclarator extends IVariableDeclarators, IAstToken {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *<li>ArrayInitializer0
     *<li>ArrayInitializer1
     *</ul>
     *</b>
     */
    public interface IVariableInitializer extends IVariableInitializerList {}

    /**
     * is implemented by <b>MethodHeader</b>
     */
    public interface IMethodHeader
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Block
     *<li>MethodBody
     *</ul>
     *</b>
     */
    public interface IMethodBody extends IAstToken {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>FormalParameterList
     *<li>FixedParameters
     *<li>FixedParameter
     *<li>ParameterArray
     *</ul>
     *</b>
     */
    public interface IFormalParameterListOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>FormalParameterList
     *<li>FixedParameters
     *<li>FixedParameter
     *<li>ParameterArray
     *</ul>
     *</b>
     */
    public interface IFormalParameterList extends IFormalParameterListOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>FixedParameters
     *<li>FixedParameter
     *</ul>
     *</b>
     */
    public interface IFixedParameters extends IFormalParameterList {}

    /**
     * is implemented by <b>ParameterArray</b>
     */
    public interface IParameterArray extends IFormalParameterList {}

    /**
     * is implemented by <b>FixedParameter</b>
     */
    public interface IFixedParameter extends IFixedParameters {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by:
     *<b>
     *<ul>
     *<li>ParameterModifier0
     *<li>ParameterModifier1
     *</ul>
     *</b>
     */
    public interface IParameterModifier extends IParameterModifierOpt, IAstToken {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>AccessorDeclarations0
     *<li>AccessorDeclarations1
     *</ul>
     *</b>
     */
    public interface IAccessorDeclarations
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>GetAccessorDeclaration</b>
     */
    public interface IGetAccessorDeclaration extends IGetAccessorDeclarationOpt {}

    /**
     * is implemented by <b>SetAccessorDeclaration</b>
     */
    public interface ISetAccessorDeclarationOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>SetAccessorDeclaration</b>
     */
    public interface ISetAccessorDeclaration extends ISetAccessorDeclarationOpt {}

    /**
     * is implemented by <b>GetAccessorDeclaration</b>
     */
    public interface IGetAccessorDeclarationOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>AccessorModifier0
     *<li>AccessorModifier1
     *<li>AccessorModifier2
     *<li>AccessorModifier3
     *<li>AccessorModifier4
     *</ul>
     *</b>
     */
    public interface IAccessorModifierOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Block
     *<li>AccessorBody
     *</ul>
     *</b>
     */
    public interface IAccessorBody extends IAstToken {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>AccessorModifier0
     *<li>AccessorModifier1
     *<li>AccessorModifier2
     *<li>AccessorModifier3
     *<li>AccessorModifier4
     *</ul>
     *</b>
     */
    public interface IAccessorModifier extends IAccessorModifierOpt, IAstToken {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>EventAccessorDeclarations0
     *<li>EventAccessorDeclarations1
     *</ul>
     *</b>
     */
    public interface IEventAccessorDeclarations
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>AddAccessorDeclaration</b>
     */
    public interface IAddAccessorDeclaration
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>RemoveAccessorDeclaration</b>
     */
    public interface IRemoveAccessorDeclaration
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>IndexerDeclarator0
     *<li>IndexerDeclarator1
     *</ul>
     *</b>
     */
    public interface IIndexerDeclarator
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>SymbolOperatorDeclarator
     *<li>ConversionOperatorDeclarator0
     *<li>ConversionOperatorDeclarator1
     *</ul>
     *</b>
     */
    public interface IOperatorDeclarator
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Block
     *<li>OperatorBody
     *</ul>
     *</b>
     */
    public interface IOperatorBody extends IAstToken {}

    /**
     * is implemented by <b>SymbolOperatorDeclarator</b>
     */
    public interface ISymbolOperatorDeclarator extends IOperatorDeclarator {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ConversionOperatorDeclarator0
     *<li>ConversionOperatorDeclarator1
     *</ul>
     *</b>
     */
    public interface IConversionOperatorDeclarator extends IOperatorDeclarator {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by:
     *<b>
     *<ul>
     *<li>OverloadableOperator0
     *<li>OverloadableOperator1
     *<li>OverloadableOperator2
     *<li>OverloadableOperator3
     *<li>OverloadableOperator4
     *<li>OverloadableOperator5
     *<li>OverloadableOperator6
     *<li>OverloadableOperator7
     *<li>OverloadableOperator8
     *<li>OverloadableOperator9
     *<li>OverloadableOperator10
     *<li>OverloadableOperator11
     *<li>OverloadableOperator12
     *<li>OverloadableOperator13
     *<li>OverloadableOperator14
     *<li>OverloadableOperator15
     *<li>OverloadableOperator16
     *<li>OverloadableOperator17
     *<li>OverloadableOperator18
     *<li>OverloadableOperator19
     *<li>OverloadableOperator20
     *<li>OverloadableOperator21
     *</ul>
     *</b>
     */
    public interface IOverloadableOperator extends IAstToken {}

    /**
     * is implemented by <b>ConstructorDeclarator</b>
     */
    public interface IConstructorDeclarator
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Block
     *<li>ConstructorBody
     *</ul>
     *</b>
     */
    public interface IConstructorBody extends IAstToken {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ConstructorInitializer0
     *<li>ConstructorInitializer1
     *</ul>
     *</b>
     */
    public interface IConstructorInitializerOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ConstructorInitializer0
     *<li>ConstructorInitializer1
     *</ul>
     *</b>
     */
    public interface IConstructorInitializer extends IConstructorInitializerOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Block
     *<li>FinalizerBody
     *</ul>
     *</b>
     */
    public interface IFinalizerBody extends IAstToken {}

    /**
     * is implemented by <b>StructInterfacesOpt</b>
     */
    public interface IStructInterfacesOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>StructBody</b>
     */
    public interface IStructBody
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>StructInterfaces
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>ClassType0
     *<li>ClassType1
     *</ul>
     *</b>
     */
    public interface IStructInterfaces
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ClassDeclaration
     *<li>ConstantDeclaration
     *<li>FieldDeclaration
     *<li>MethodDeclaration
     *<li>PropertyDeclaration
     *<li>IndexerDeclaration
     *<li>OperatorDeclaration
     *<li>ConstructorDeclaration
     *<li>StructDeclaration
     *<li>StructMemberDeclarations
     *<li>InterfaceDeclaration
     *<li>EnumDeclaration
     *<li>DelegateDeclaration
     *<li>EventDeclaration0
     *<li>EventDeclaration1
     *</ul>
     *</b>
     */
    public interface IStructMemberDeclarationsOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ClassDeclaration
     *<li>ConstantDeclaration
     *<li>FieldDeclaration
     *<li>MethodDeclaration
     *<li>PropertyDeclaration
     *<li>IndexerDeclaration
     *<li>OperatorDeclaration
     *<li>ConstructorDeclaration
     *<li>StructDeclaration
     *<li>StructMemberDeclarations
     *<li>InterfaceDeclaration
     *<li>EnumDeclaration
     *<li>DelegateDeclaration
     *<li>EventDeclaration0
     *<li>EventDeclaration1
     *</ul>
     *</b>
     */
    public interface IStructMemberDeclarations extends IStructMemberDeclarationsOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ClassDeclaration
     *<li>ConstantDeclaration
     *<li>FieldDeclaration
     *<li>MethodDeclaration
     *<li>PropertyDeclaration
     *<li>IndexerDeclaration
     *<li>OperatorDeclaration
     *<li>ConstructorDeclaration
     *<li>StructDeclaration
     *<li>InterfaceDeclaration
     *<li>EnumDeclaration
     *<li>DelegateDeclaration
     *<li>EventDeclaration0
     *<li>EventDeclaration1
     *</ul>
     *</b>
     */
    public interface IStructMemberDeclaration extends IStructMemberDeclarations {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>RankSpecifiers
     *<li>RankSpecifier
     *</ul>
     *</b>
     */
    public interface IRankSpecifiers extends IRankSpecifiersOpt {}

    /**
     * is implemented by <b>RankSpecifier</b>
     */
    public interface IRankSpecifier extends IRankSpecifiers {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>DimSeparators0
     *<li>DimSeparators1
     *</ul>
     *</b>
     */
    public interface IDimSeparatorsOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>DimSeparators0
     *<li>DimSeparators1
     *</ul>
     *</b>
     */
    public interface IDimSeparators extends IDimSeparatorsOpt, IAstToken {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>VariableInitializerList
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *<li>ArrayInitializer0
     *<li>ArrayInitializer1
     *</ul>
     *</b>
     */
    public interface IVariableInitializerListOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>VariableInitializerList
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *<li>ArrayInitializer0
     *<li>ArrayInitializer1
     *</ul>
     *</b>
     */
    public interface IVariableInitializerList extends IVariableInitializerListOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>InterfaceBase
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *</ul>
     *</b>
     */
    public interface IInterfaceBaseOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>InterfaceBody</b>
     */
    public interface IInterfaceBody
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>InterfaceBase
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *</ul>
     *</b>
     */
    public interface IInterfaceBase extends IInterfaceBaseOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>InterfaceMemberDeclarations
     *<li>InterfaceMethodDeclaration
     *<li>InterfacePropertyDeclaration
     *<li>InterfaceEventDeclaration
     *<li>InterfaceIndexerDeclaration
     *</ul>
     *</b>
     */
    public interface IInterfaceMemberDeclarationsOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>InterfaceMemberDeclarations
     *<li>InterfaceMethodDeclaration
     *<li>InterfacePropertyDeclaration
     *<li>InterfaceEventDeclaration
     *<li>InterfaceIndexerDeclaration
     *</ul>
     *</b>
     */
    public interface IInterfaceMemberDeclarations extends IInterfaceMemberDeclarationsOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>InterfaceMethodDeclaration
     *<li>InterfacePropertyDeclaration
     *<li>InterfaceEventDeclaration
     *<li>InterfaceIndexerDeclaration
     *</ul>
     *</b>
     */
    public interface IInterfaceMemberDeclaration extends IInterfaceMemberDeclarations {}

    /**
     * is implemented by <b>InterfaceMethodDeclaration</b>
     */
    public interface IInterfaceMethodDeclaration extends IInterfaceMemberDeclaration {}

    /**
     * is implemented by <b>InterfacePropertyDeclaration</b>
     */
    public interface IInterfacePropertyDeclaration extends IInterfaceMemberDeclaration {}

    /**
     * is implemented by <b>InterfaceEventDeclaration</b>
     */
    public interface IInterfaceEventDeclaration extends IInterfaceMemberDeclaration {}

    /**
     * is implemented by <b>InterfaceIndexerDeclaration</b>
     */
    public interface IInterfaceIndexerDeclaration extends IInterfaceMemberDeclaration {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>InterfaceAccessors0
     *<li>InterfaceAccessors1
     *<li>InterfaceAccessors2
     *<li>InterfaceAccessors3
     *</ul>
     *</b>
     */
    public interface IInterfaceAccessors
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>EnumBase</b>
     */
    public interface IEnumBaseOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>EnumBody0
     *<li>EnumBody1
     *</ul>
     *</b>
     */
    public interface IEnumBody
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>EnumBase</b>
     */
    public interface IEnumBase extends IEnumBaseOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>EnumMemberDeclarations
     *<li>EnumMemberDeclaration0
     *<li>EnumMemberDeclaration1
     *</ul>
     *</b>
     */
    public interface IEnumMemberDeclarationsOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>EnumMemberDeclarations
     *<li>EnumMemberDeclaration0
     *<li>EnumMemberDeclaration1
     *</ul>
     *</b>
     */
    public interface IEnumMemberDeclarations extends IEnumMemberDeclarationsOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>EnumMemberDeclaration0
     *<li>EnumMemberDeclaration1
     *</ul>
     *</b>
     */
    public interface IEnumMemberDeclaration extends IEnumMemberDeclarations {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>AttributeSections
     *<li>AttributeSection0
     *<li>AttributeSection1
     *</ul>
     *</b>
     */
    public interface IAttributes extends IAttributesOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>AttributeSections
     *<li>AttributeSection0
     *<li>AttributeSection1
     *</ul>
     *</b>
     */
    public interface IAttributeSections extends IAttributes {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>AttributeSection0
     *<li>AttributeSection1
     *</ul>
     *</b>
     */
    public interface IAttributeSection extends IAttributeSections {}

    /**
     * is implemented by <b>AttributeTargetSpecifier</b>
     */
    public interface IAttributeTargetSpecifierOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>AttributeList
     *<li>Attribute
     *</ul>
     *</b>
     */
    public interface IAttributeList
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by <b>AttributeTargetSpecifier</b>
     */
    public interface IAttributeTargetSpecifier extends IAttributeTargetSpecifierOpt {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by:
     *<b>
     *<ul>
     *<li>AttributeTarget
     *<li>Keyword0
     *<li>Keyword1
     *<li>Keyword2
     *<li>Keyword3
     *<li>Keyword4
     *<li>Keyword5
     *<li>Keyword6
     *<li>Keyword7
     *<li>Keyword8
     *<li>Keyword9
     *<li>Keyword10
     *<li>Keyword11
     *<li>Keyword12
     *<li>Keyword13
     *<li>Keyword14
     *<li>Keyword15
     *<li>Keyword16
     *<li>Keyword17
     *<li>Keyword18
     *<li>Keyword19
     *<li>Keyword20
     *<li>Keyword21
     *<li>Keyword22
     *<li>Keyword23
     *<li>Keyword24
     *<li>Keyword25
     *<li>Keyword26
     *<li>Keyword27
     *<li>Keyword28
     *<li>Keyword29
     *<li>Keyword30
     *<li>Keyword31
     *<li>Keyword32
     *<li>Keyword33
     *<li>Keyword34
     *<li>Keyword35
     *<li>Keyword36
     *<li>Keyword37
     *<li>Keyword38
     *<li>Keyword39
     *<li>Keyword40
     *<li>Keyword41
     *<li>Keyword42
     *<li>Keyword43
     *<li>Keyword44
     *<li>Keyword45
     *<li>Keyword46
     *<li>Keyword47
     *<li>Keyword48
     *<li>Keyword49
     *<li>Keyword50
     *<li>Keyword51
     *<li>Keyword52
     *<li>Keyword53
     *<li>Keyword54
     *<li>Keyword55
     *<li>Keyword56
     *<li>Keyword57
     *<li>Keyword58
     *<li>Keyword59
     *<li>Keyword60
     *<li>Keyword61
     *<li>Keyword62
     *<li>Keyword63
     *<li>Keyword64
     *<li>Keyword65
     *<li>Keyword66
     *<li>Keyword67
     *<li>Keyword68
     *<li>Keyword69
     *<li>Keyword70
     *<li>Keyword71
     *<li>Keyword72
     *<li>Keyword73
     *<li>Keyword74
     *<li>Keyword75
     *<li>Keyword76
     *<li>Keyword77
     *<li>Keyword78
     *<li>Keyword79
     *<li>Keyword80
     *<li>Keyword81
     *<li>Keyword82
     *<li>Keyword83
     *<li>Keyword84
     *</ul>
     *</b>
     */
    public interface IAttributeTarget extends IAstToken {}

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by:
     *<b>
     *<ul>
     *<li>Keyword0
     *<li>Keyword1
     *<li>Keyword2
     *<li>Keyword3
     *<li>Keyword4
     *<li>Keyword5
     *<li>Keyword6
     *<li>Keyword7
     *<li>Keyword8
     *<li>Keyword9
     *<li>Keyword10
     *<li>Keyword11
     *<li>Keyword12
     *<li>Keyword13
     *<li>Keyword14
     *<li>Keyword15
     *<li>Keyword16
     *<li>Keyword17
     *<li>Keyword18
     *<li>Keyword19
     *<li>Keyword20
     *<li>Keyword21
     *<li>Keyword22
     *<li>Keyword23
     *<li>Keyword24
     *<li>Keyword25
     *<li>Keyword26
     *<li>Keyword27
     *<li>Keyword28
     *<li>Keyword29
     *<li>Keyword30
     *<li>Keyword31
     *<li>Keyword32
     *<li>Keyword33
     *<li>Keyword34
     *<li>Keyword35
     *<li>Keyword36
     *<li>Keyword37
     *<li>Keyword38
     *<li>Keyword39
     *<li>Keyword40
     *<li>Keyword41
     *<li>Keyword42
     *<li>Keyword43
     *<li>Keyword44
     *<li>Keyword45
     *<li>Keyword46
     *<li>Keyword47
     *<li>Keyword48
     *<li>Keyword49
     *<li>Keyword50
     *<li>Keyword51
     *<li>Keyword52
     *<li>Keyword53
     *<li>Keyword54
     *<li>Keyword55
     *<li>Keyword56
     *<li>Keyword57
     *<li>Keyword58
     *<li>Keyword59
     *<li>Keyword60
     *<li>Keyword61
     *<li>Keyword62
     *<li>Keyword63
     *<li>Keyword64
     *<li>Keyword65
     *<li>Keyword66
     *<li>Keyword67
     *<li>Keyword68
     *<li>Keyword69
     *<li>Keyword70
     *<li>Keyword71
     *<li>Keyword72
     *<li>Keyword73
     *<li>Keyword74
     *<li>Keyword75
     *<li>Keyword76
     *<li>Keyword77
     *<li>Keyword78
     *<li>Keyword79
     *<li>Keyword80
     *<li>Keyword81
     *<li>Keyword82
     *<li>Keyword83
     *<li>Keyword84
     *</ul>
     *</b>
     */
    public interface IKeyword extends IAttributeTarget, IAstToken {}

    /**
     * is implemented by <b>Attribute</b>
     */
    public interface IAttribute extends IAttributeList {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *</ul>
     *</b>
     */
    public interface IAttributeName
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>AttributeArguments0
     *<li>AttributeArguments1
     *<li>AttributeArguments2
     *</ul>
     *</b>
     */
    public interface IAttributeArgumentsOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>AttributeArguments0
     *<li>AttributeArguments1
     *<li>AttributeArguments2
     *</ul>
     *</b>
     */
    public interface IAttributeArguments extends IAttributeArgumentsOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>PositionalArgumentList
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IPositionalArgumentListOpt
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>PositionalArgumentList
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IPositionalArgumentList extends IPositionalArgumentListOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>NamedArgumentList
     *<li>NamedArgument
     *</ul>
     *</b>
     */
    public interface INamedArgumentList
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IPositionalArgument extends IPositionalArgumentList {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>ParenthesizedExpression
     *<li>InvocationExpression
     *<li>ElementAccess
     *<li>ThisAccess
     *<li>PostIncrementExpression
     *<li>PostDecrementExpression
     *<li>ObjectCreationExpression
     *<li>CheckedExpression
     *<li>UncheckedExpression
     *<li>DefaultValueExpression
     *<li>AnonymousMethodExpression
     *<li>PreIncrementExpression
     *<li>PreDecrementExpression
     *<li>CastExpression
     *<li>AndExpression
     *<li>ExclusiveOrExpression
     *<li>InclusiveOrExpression
     *<li>ConditionalAndExpression
     *<li>ConditionalOrExpression
     *<li>NullCoalescingExpression
     *<li>ConditionalExpression
     *<li>Assignment
     *<li>BooleanLiteral0
     *<li>BooleanLiteral1
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>MemberAccess0
     *<li>MemberAccess1
     *<li>MemberAccess2
     *<li>BaseAccess0
     *<li>BaseAccess1
     *<li>ArrayCreationExpression0
     *<li>ArrayCreationExpression1
     *<li>TypeofExpression0
     *<li>TypeofExpression1
     *<li>UnaryExpression0
     *<li>UnaryExpression1
     *<li>UnaryExpression2
     *<li>UnaryExpression3
     *<li>MultiplicativeExpression0
     *<li>MultiplicativeExpression1
     *<li>MultiplicativeExpression2
     *<li>AdditiveExpression0
     *<li>AdditiveExpression1
     *<li>ShiftExpression0
     *<li>ShiftExpression1
     *<li>RelationalExpression0
     *<li>RelationalExpression1
     *<li>RelationalExpression2
     *<li>RelationalExpression3
     *<li>RelationalExpression4
     *<li>RelationalExpression5
     *<li>EqualityExpression0
     *<li>EqualityExpression1
     *</ul>
     *</b>
     */
    public interface IAttributeArgumentExpression extends IPositionalArgument {}

    /**
     * is implemented by <b>NamedArgument</b>
     */
    public interface INamedArgument extends INamedArgumentList {}

    /**
     * is implemented by <b>TypeParameterList</b>
     */
    public interface ITypeParameterList extends ITypeParameterListOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>TypeParameters0
     *<li>TypeParameters1
     *</ul>
     *</b>
     */
    public interface ITypeParameters
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is always implemented by <b>AstToken</b>. It is also implemented by <b>TypeParameter</b>
     */
    public interface ITypeParameter extends IAstToken {}

    /**
     * is implemented by <b>TypeArgumentList</b>
     */
    public interface ITypeArgumentList extends ITypeArgumentListOpt {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Type
     *<li>SimpleType
     *<li>NumericType
     *<li>NullableType
     *<li>ArrayType
     *<li>TypeArguments
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>IntegralType0
     *<li>IntegralType1
     *<li>IntegralType2
     *<li>IntegralType3
     *<li>IntegralType4
     *<li>IntegralType5
     *<li>IntegralType6
     *<li>IntegralType7
     *<li>IntegralType8
     *<li>FloatingPointType0
     *<li>FloatingPointType1
     *<li>ClassType0
     *<li>ClassType1
     *</ul>
     *</b>
     */
    public interface ITypeArguments
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Type
     *<li>SimpleType
     *<li>NumericType
     *<li>NullableType
     *<li>ArrayType
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>IntegralType0
     *<li>IntegralType1
     *<li>IntegralType2
     *<li>IntegralType3
     *<li>IntegralType4
     *<li>IntegralType5
     *<li>IntegralType6
     *<li>IntegralType7
     *<li>IntegralType8
     *<li>FloatingPointType0
     *<li>FloatingPointType1
     *<li>ClassType0
     *<li>ClassType1
     *</ul>
     *</b>
     */
    public interface ITypeArgument extends ITypeArguments {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>TypeParameterConstraintsClauses
     *<li>TypeParameterConstraintsClause
     *</ul>
     *</b>
     */
    public interface ITypeParameterConstraintsClauses extends ITypeParameterConstraintsClausesOpt {}

    /**
     * is implemented by <b>TypeParameterConstraintsClause</b>
     */
    public interface ITypeParameterConstraintsClause extends ITypeParameterConstraintsClauses {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>TypeParameterConstraints
     *<li>Constraints
     *<li>ConstructorConstraint
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>ClassType0
     *<li>ClassType1
     *<li>Constraint0
     *<li>Constraint1
     *</ul>
     *</b>
     */
    public interface ITypeParameterConstraints
    {
        public IToken getLeftIToken();
        public IToken getRightIToken();

        void accept(Visitor v);
        void accept(ArgumentVisitor v, Object o);
        Object accept(ResultVisitor v);
        Object accept(ResultArgumentVisitor v, Object o);
    }

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Constraints
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>ClassType0
     *<li>ClassType1
     *<li>Constraint0
     *<li>Constraint1
     *</ul>
     *</b>
     */
    public interface IConstraints extends ITypeParameterConstraints {}

    /**
     * is implemented by <b>ConstructorConstraint</b>
     */
    public interface IConstructorConstraint extends ITypeParameterConstraints {}

    /**
     * is implemented by:
     *<b>
     *<ul>
     *<li>Name0
     *<li>Name1
     *<li>Name2
     *<li>ClassType0
     *<li>ClassType1
     *<li>Constraint0
     *<li>Constraint1
     *</ul>
     *</b>
     */
    public interface IConstraint extends IConstraints, IAstToken {}

    /**
     *<em>
     *<li>Rule 1:  SemiOpt ::= $Empty
     *</em>
     *<p>
     *<b>
     *<li>Rule 2:  SemiOpt ::= ;
     *</b>
     */
    static public class SemiOpt extends AstToken implements ISemiOpt
    {
        public SemiOpt(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 3:  ExternOpt ::= $Empty
     *</em>
     *<p>
     *<b>
     *<li>Rule 4:  ExternOpt ::= extern
     *</b>
     */
    static public class ExternOpt extends AstToken implements IExternOpt
    {
        public ExternOpt(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 5:  NewOpt ::= $Empty
     *</em>
     *<p>
     *<b>
     *<li>Rule 6:  NewOpt ::= new
     *</b>
     */
    static public class NewOpt extends AstToken implements INewOpt
    {
        public NewOpt(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 7:  PartialOpt ::= $Empty
     *</em>
     *<p>
     *<b>
     *<li>Rule 8:  PartialOpt ::= partial
     *</b>
     */
    static public class PartialOpt extends AstToken implements IPartialOpt
    {
        public PartialOpt(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 9:  IdentifierOpt ::= $Empty
     *</em>
     *<p>
     *<b>
     *<li>Rule 10:  IdentifierOpt ::= identifier
     *</b>
     */
    static public class IdentifierOpt extends AstToken implements IIdentifierOpt
    {
        public IdentifierOpt(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 14:  CompilationUnit ::= ExternAliasDirectivesOpt UsingDirectivesOpt NamespaceMemberDeclarationsOpt
     *</b>
     */
    static public class CompilationUnit extends Ast implements ICompilationUnit
    {
        private IExternAliasDirectivesOpt _ExternAliasDirectivesOpt;
        private IUsingDirectivesOpt _UsingDirectivesOpt;
        private INamespaceMemberDeclarationsOpt _NamespaceMemberDeclarationsOpt;

        /**
         * The value returned by <b>getExternAliasDirectivesOpt</b> may be <b>null</b>
         */
        public IExternAliasDirectivesOpt getExternAliasDirectivesOpt() { return _ExternAliasDirectivesOpt; }
        /**
         * The value returned by <b>getUsingDirectivesOpt</b> may be <b>null</b>
         */
        public IUsingDirectivesOpt getUsingDirectivesOpt() { return _UsingDirectivesOpt; }
        /**
         * The value returned by <b>getNamespaceMemberDeclarationsOpt</b> may be <b>null</b>
         */
        public INamespaceMemberDeclarationsOpt getNamespaceMemberDeclarationsOpt() { return _NamespaceMemberDeclarationsOpt; }

        public CompilationUnit(IToken leftIToken, IToken rightIToken,
                               IExternAliasDirectivesOpt _ExternAliasDirectivesOpt,
                               IUsingDirectivesOpt _UsingDirectivesOpt,
                               INamespaceMemberDeclarationsOpt _NamespaceMemberDeclarationsOpt)
        {
            super(leftIToken, rightIToken);

            this._ExternAliasDirectivesOpt = _ExternAliasDirectivesOpt;
            this._UsingDirectivesOpt = _UsingDirectivesOpt;
            this._NamespaceMemberDeclarationsOpt = _NamespaceMemberDeclarationsOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof CompilationUnit)) return false;
            CompilationUnit other = (CompilationUnit    ) o;
            if (_ExternAliasDirectivesOpt == null && other.getExternAliasDirectivesOpt() != null) return false;
            else if (! _ExternAliasDirectivesOpt.equals(other.getExternAliasDirectivesOpt())) return false;
            if (_UsingDirectivesOpt == null && other.getUsingDirectivesOpt() != null) return false;
            else if (! _UsingDirectivesOpt.equals(other.getUsingDirectivesOpt())) return false;
            if (_NamespaceMemberDeclarationsOpt == null && other.getNamespaceMemberDeclarationsOpt() != null) return false;
            else if (! _NamespaceMemberDeclarationsOpt.equals(other.getNamespaceMemberDeclarationsOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getExternAliasDirectivesOpt() == null ? 0 : getExternAliasDirectivesOpt().hashCode());
            hash = hash * 31 + (getUsingDirectivesOpt() == null ? 0 : getUsingDirectivesOpt().hashCode());
            hash = hash * 31 + (getNamespaceMemberDeclarationsOpt() == null ? 0 : getNamespaceMemberDeclarationsOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 18:  Type ::= SimpleType
     *<li>Rule 19:  Type ::= NullableType
     *<li>Rule 20:  Type ::= ClassType
     *<li>Rule 21:  Type ::= ArrayType
     *</em>
     *<p>
     *<b>
     *<li>Rule 22:  Type ::= void
     *</b>
     */
    static public class Type extends AstToken implements IType
    {
        public Type(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 28:  SimpleType ::= NumericType
     *</em>
     *<p>
     *<b>
     *<li>Rule 29:  SimpleType ::= bool
     *</b>
     */
    static public class SimpleType extends AstToken implements ISimpleType
    {
        public SimpleType(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 30:  NumericType ::= IntegralType
     *<li>Rule 31:  NumericType ::= FloatingPointType
     *</em>
     *<p>
     *<b>
     *<li>Rule 32:  NumericType ::= decimal
     *</b>
     */
    static public class NumericType extends AstToken implements INumericType
    {
        public NumericType(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 44:  NullableType ::= Type ?
     *</b>
     */
    static public class NullableType extends Ast implements INullableType
    {
        private IType _Type;

        public IType getType() { return _Type; }

        public NullableType(IToken leftIToken, IToken rightIToken,
                            IType _Type)
        {
            super(leftIToken, rightIToken);

            this._Type = _Type;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof NullableType)) return false;
            NullableType other = (NullableType    ) o;
            if (! _Type.equals(other.getType())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getType().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 51:  ArgumentList ::= Argument
     *</em>
     *<p>
     *<b>
     *<li>Rule 52:  ArgumentList ::= ArgumentList , Argument
     *</b>
     */
    static public class ArgumentList extends Ast implements IArgumentList
    {
        private IArgumentList _ArgumentList;
        private IArgument _Argument;

        public IArgumentList getArgumentList() { return _ArgumentList; }
        public IArgument getArgument() { return _Argument; }

        public ArgumentList(IToken leftIToken, IToken rightIToken,
                            IArgumentList _ArgumentList,
                            IArgument _Argument)
        {
            super(leftIToken, rightIToken);

            this._ArgumentList = _ArgumentList;
            this._Argument = _Argument;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ArgumentList)) return false;
            ArgumentList other = (ArgumentList    ) o;
            if (! _ArgumentList.equals(other.getArgumentList())) return false;
            if (! _Argument.equals(other.getArgument())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getArgumentList().hashCode());
            hash = hash * 31 + (getArgument().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 74:  ParenthesizedExpression ::= ( Expression )
     *</b>
     */
    static public class ParenthesizedExpression extends Ast implements IParenthesizedExpression
    {
        private IExpression _Expression;

        public IExpression getExpression() { return _Expression; }

        public ParenthesizedExpression(IToken leftIToken, IToken rightIToken,
                                       IExpression _Expression)
        {
            super(leftIToken, rightIToken);

            this._Expression = _Expression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ParenthesizedExpression)) return false;
            ParenthesizedExpression other = (ParenthesizedExpression    ) o;
            if (! _Expression.equals(other.getExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 93:  InvocationExpression ::= PrimaryExpression ( ArgumentListOpt )
     *</b>
     */
    static public class InvocationExpression extends Ast implements IInvocationExpression
    {
        private IPrimaryExpression _PrimaryExpression;
        private IArgumentListOpt _ArgumentListOpt;

        public IPrimaryExpression getPrimaryExpression() { return _PrimaryExpression; }
        /**
         * The value returned by <b>getArgumentListOpt</b> may be <b>null</b>
         */
        public IArgumentListOpt getArgumentListOpt() { return _ArgumentListOpt; }

        public InvocationExpression(IToken leftIToken, IToken rightIToken,
                                    IPrimaryExpression _PrimaryExpression,
                                    IArgumentListOpt _ArgumentListOpt)
        {
            super(leftIToken, rightIToken);

            this._PrimaryExpression = _PrimaryExpression;
            this._ArgumentListOpt = _ArgumentListOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof InvocationExpression)) return false;
            InvocationExpression other = (InvocationExpression    ) o;
            if (! _PrimaryExpression.equals(other.getPrimaryExpression())) return false;
            if (_ArgumentListOpt == null && other.getArgumentListOpt() != null) return false;
            else if (! _ArgumentListOpt.equals(other.getArgumentListOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getPrimaryExpression().hashCode());
            hash = hash * 31 + (getArgumentListOpt() == null ? 0 : getArgumentListOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 94:  ElementAccess ::= PrimaryNoArrayCreationExpression [ ExpressionList ]
     *</b>
     */
    static public class ElementAccess extends Ast implements IElementAccess
    {
        private IPrimaryNoArrayCreationExpression _PrimaryNoArrayCreationExpression;
        private IExpressionList _ExpressionList;

        public IPrimaryNoArrayCreationExpression getPrimaryNoArrayCreationExpression() { return _PrimaryNoArrayCreationExpression; }
        public IExpressionList getExpressionList() { return _ExpressionList; }

        public ElementAccess(IToken leftIToken, IToken rightIToken,
                             IPrimaryNoArrayCreationExpression _PrimaryNoArrayCreationExpression,
                             IExpressionList _ExpressionList)
        {
            super(leftIToken, rightIToken);

            this._PrimaryNoArrayCreationExpression = _PrimaryNoArrayCreationExpression;
            this._ExpressionList = _ExpressionList;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ElementAccess)) return false;
            ElementAccess other = (ElementAccess    ) o;
            if (! _PrimaryNoArrayCreationExpression.equals(other.getPrimaryNoArrayCreationExpression())) return false;
            if (! _ExpressionList.equals(other.getExpressionList())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getPrimaryNoArrayCreationExpression().hashCode());
            hash = hash * 31 + (getExpressionList().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 95:  ExpressionList ::= Expression
     *</em>
     *<p>
     *<b>
     *<li>Rule 96:  ExpressionList ::= ExpressionList , Expression
     *</b>
     */
    static public class ExpressionList extends Ast implements IExpressionList
    {
        private IExpressionList _ExpressionList;
        private IExpression _Expression;

        public IExpressionList getExpressionList() { return _ExpressionList; }
        public IExpression getExpression() { return _Expression; }

        public ExpressionList(IToken leftIToken, IToken rightIToken,
                              IExpressionList _ExpressionList,
                              IExpression _Expression)
        {
            super(leftIToken, rightIToken);

            this._ExpressionList = _ExpressionList;
            this._Expression = _Expression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ExpressionList)) return false;
            ExpressionList other = (ExpressionList    ) o;
            if (! _ExpressionList.equals(other.getExpressionList())) return false;
            if (! _Expression.equals(other.getExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getExpressionList().hashCode());
            hash = hash * 31 + (getExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 97:  ThisAccess ::= this
     *</b>
     */
    static public class ThisAccess extends AstToken implements IThisAccess
    {
        public ThisAccess(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 100:  PostIncrementExpression ::= PrimaryExpression ++
     *</b>
     */
    static public class PostIncrementExpression extends Ast implements IPostIncrementExpression
    {
        private IPrimaryExpression _PrimaryExpression;

        public IPrimaryExpression getPrimaryExpression() { return _PrimaryExpression; }

        public PostIncrementExpression(IToken leftIToken, IToken rightIToken,
                                       IPrimaryExpression _PrimaryExpression)
        {
            super(leftIToken, rightIToken);

            this._PrimaryExpression = _PrimaryExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof PostIncrementExpression)) return false;
            PostIncrementExpression other = (PostIncrementExpression    ) o;
            if (! _PrimaryExpression.equals(other.getPrimaryExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getPrimaryExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 101:  PostDecrementExpression ::= PrimaryExpression --
     *</b>
     */
    static public class PostDecrementExpression extends Ast implements IPostDecrementExpression
    {
        private IPrimaryExpression _PrimaryExpression;

        public IPrimaryExpression getPrimaryExpression() { return _PrimaryExpression; }

        public PostDecrementExpression(IToken leftIToken, IToken rightIToken,
                                       IPrimaryExpression _PrimaryExpression)
        {
            super(leftIToken, rightIToken);

            this._PrimaryExpression = _PrimaryExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof PostDecrementExpression)) return false;
            PostDecrementExpression other = (PostDecrementExpression    ) o;
            if (! _PrimaryExpression.equals(other.getPrimaryExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getPrimaryExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 102:  ObjectCreationExpression ::= new Type ( ArgumentListOpt )
     *</b>
     */
    static public class ObjectCreationExpression extends Ast implements IObjectCreationExpression
    {
        private IType _Type;
        private IArgumentListOpt _ArgumentListOpt;

        public IType getType() { return _Type; }
        /**
         * The value returned by <b>getArgumentListOpt</b> may be <b>null</b>
         */
        public IArgumentListOpt getArgumentListOpt() { return _ArgumentListOpt; }

        public ObjectCreationExpression(IToken leftIToken, IToken rightIToken,
                                        IType _Type,
                                        IArgumentListOpt _ArgumentListOpt)
        {
            super(leftIToken, rightIToken);

            this._Type = _Type;
            this._ArgumentListOpt = _ArgumentListOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ObjectCreationExpression)) return false;
            ObjectCreationExpression other = (ObjectCreationExpression    ) o;
            if (! _Type.equals(other.getType())) return false;
            if (_ArgumentListOpt == null && other.getArgumentListOpt() != null) return false;
            else if (! _ArgumentListOpt.equals(other.getArgumentListOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getArgumentListOpt() == null ? 0 : getArgumentListOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 112:  GenericDimensionSpecifier ::= < CommasOpt >
     *</b>
     */
    static public class GenericDimensionSpecifier extends Ast implements IGenericDimensionSpecifier
    {
        private ICommasOpt _CommasOpt;

        /**
         * The value returned by <b>getCommasOpt</b> may be <b>null</b>
         */
        public ICommasOpt getCommasOpt() { return _CommasOpt; }

        public GenericDimensionSpecifier(IToken leftIToken, IToken rightIToken,
                                         ICommasOpt _CommasOpt)
        {
            super(leftIToken, rightIToken);

            this._CommasOpt = _CommasOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof GenericDimensionSpecifier)) return false;
            GenericDimensionSpecifier other = (GenericDimensionSpecifier    ) o;
            if (_CommasOpt == null && other.getCommasOpt() != null) return false;
            else if (! _CommasOpt.equals(other.getCommasOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getCommasOpt() == null ? 0 : getCommasOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 117:  CheckedExpression ::= checked ( Expression )
     *</b>
     */
    static public class CheckedExpression extends Ast implements ICheckedExpression
    {
        private IExpression _Expression;

        public IExpression getExpression() { return _Expression; }

        public CheckedExpression(IToken leftIToken, IToken rightIToken,
                                 IExpression _Expression)
        {
            super(leftIToken, rightIToken);

            this._Expression = _Expression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof CheckedExpression)) return false;
            CheckedExpression other = (CheckedExpression    ) o;
            if (! _Expression.equals(other.getExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 118:  UncheckedExpression ::= unchecked ( Expression )
     *</b>
     */
    static public class UncheckedExpression extends Ast implements IUncheckedExpression
    {
        private IExpression _Expression;

        public IExpression getExpression() { return _Expression; }

        public UncheckedExpression(IToken leftIToken, IToken rightIToken,
                                   IExpression _Expression)
        {
            super(leftIToken, rightIToken);

            this._Expression = _Expression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof UncheckedExpression)) return false;
            UncheckedExpression other = (UncheckedExpression    ) o;
            if (! _Expression.equals(other.getExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 119:  DefaultValueExpression ::= default ( Type )
     *</b>
     */
    static public class DefaultValueExpression extends Ast implements IDefaultValueExpression
    {
        private IType _Type;

        public IType getType() { return _Type; }

        public DefaultValueExpression(IToken leftIToken, IToken rightIToken,
                                      IType _Type)
        {
            super(leftIToken, rightIToken);

            this._Type = _Type;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof DefaultValueExpression)) return false;
            DefaultValueExpression other = (DefaultValueExpression    ) o;
            if (! _Type.equals(other.getType())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getType().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 120:  AnonymousMethodExpression ::= delegate AnonymousMethodSignatureOpt Block
     *</b>
     */
    static public class AnonymousMethodExpression extends Ast implements IAnonymousMethodExpression
    {
        private AnonymousMethodSignature _AnonymousMethodSignatureOpt;
        private Block _Block;

        /**
         * The value returned by <b>getAnonymousMethodSignatureOpt</b> may be <b>null</b>
         */
        public AnonymousMethodSignature getAnonymousMethodSignatureOpt() { return _AnonymousMethodSignatureOpt; }
        public Block getBlock() { return _Block; }

        public AnonymousMethodExpression(IToken leftIToken, IToken rightIToken,
                                         AnonymousMethodSignature _AnonymousMethodSignatureOpt,
                                         Block _Block)
        {
            super(leftIToken, rightIToken);

            this._AnonymousMethodSignatureOpt = _AnonymousMethodSignatureOpt;
            this._Block = _Block;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AnonymousMethodExpression)) return false;
            AnonymousMethodExpression other = (AnonymousMethodExpression    ) o;
            if (_AnonymousMethodSignatureOpt == null && other.getAnonymousMethodSignatureOpt() != null) return false;
            else if (! _AnonymousMethodSignatureOpt.equals(other.getAnonymousMethodSignatureOpt())) return false;
            if (! _Block.equals(other.getBlock())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAnonymousMethodSignatureOpt() == null ? 0 : getAnonymousMethodSignatureOpt().hashCode());
            hash = hash * 31 + (getBlock().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 123:  AnonymousMethodSignature ::= ( AnonymousMethodParameterListOpt )
     *</b>
     */
    static public class AnonymousMethodSignature extends Ast implements IAnonymousMethodSignature
    {
        private IAnonymousMethodParameterListOpt _AnonymousMethodParameterListOpt;

        /**
         * The value returned by <b>getAnonymousMethodParameterListOpt</b> may be <b>null</b>
         */
        public IAnonymousMethodParameterListOpt getAnonymousMethodParameterListOpt() { return _AnonymousMethodParameterListOpt; }

        public AnonymousMethodSignature(IToken leftIToken, IToken rightIToken,
                                        IAnonymousMethodParameterListOpt _AnonymousMethodParameterListOpt)
        {
            super(leftIToken, rightIToken);

            this._AnonymousMethodParameterListOpt = _AnonymousMethodParameterListOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AnonymousMethodSignature)) return false;
            AnonymousMethodSignature other = (AnonymousMethodSignature    ) o;
            if (_AnonymousMethodParameterListOpt == null && other.getAnonymousMethodParameterListOpt() != null) return false;
            else if (! _AnonymousMethodParameterListOpt.equals(other.getAnonymousMethodParameterListOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAnonymousMethodParameterListOpt() == null ? 0 : getAnonymousMethodParameterListOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 126:  AnonymousMethodParameterList ::= AnonymousMethodParameter
     *</em>
     *<p>
     *<b>
     *<li>Rule 127:  AnonymousMethodParameterList ::= AnonymousMethodParameterList , AnonymousMethodParameter
     *</b>
     */
    static public class AnonymousMethodParameterList extends Ast implements IAnonymousMethodParameterList
    {
        private IAnonymousMethodParameterList _AnonymousMethodParameterList;
        private AnonymousMethodParameter _AnonymousMethodParameter;

        public IAnonymousMethodParameterList getAnonymousMethodParameterList() { return _AnonymousMethodParameterList; }
        public AnonymousMethodParameter getAnonymousMethodParameter() { return _AnonymousMethodParameter; }

        public AnonymousMethodParameterList(IToken leftIToken, IToken rightIToken,
                                            IAnonymousMethodParameterList _AnonymousMethodParameterList,
                                            AnonymousMethodParameter _AnonymousMethodParameter)
        {
            super(leftIToken, rightIToken);

            this._AnonymousMethodParameterList = _AnonymousMethodParameterList;
            this._AnonymousMethodParameter = _AnonymousMethodParameter;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AnonymousMethodParameterList)) return false;
            AnonymousMethodParameterList other = (AnonymousMethodParameterList    ) o;
            if (! _AnonymousMethodParameterList.equals(other.getAnonymousMethodParameterList())) return false;
            if (! _AnonymousMethodParameter.equals(other.getAnonymousMethodParameter())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAnonymousMethodParameterList().hashCode());
            hash = hash * 31 + (getAnonymousMethodParameter().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 128:  AnonymousMethodParameter ::= ParameterModifierOpt Type identifier
     *</b>
     */
    static public class AnonymousMethodParameter extends Ast implements IAnonymousMethodParameter
    {
        private IParameterModifierOpt _ParameterModifierOpt;
        private IType _Type;

        /**
         * The value returned by <b>getParameterModifierOpt</b> may be <b>null</b>
         */
        public IParameterModifierOpt getParameterModifierOpt() { return _ParameterModifierOpt; }
        public IType getType() { return _Type; }

        public AnonymousMethodParameter(IToken leftIToken, IToken rightIToken,
                                        IParameterModifierOpt _ParameterModifierOpt,
                                        IType _Type)
        {
            super(leftIToken, rightIToken);

            this._ParameterModifierOpt = _ParameterModifierOpt;
            this._Type = _Type;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AnonymousMethodParameter)) return false;
            AnonymousMethodParameter other = (AnonymousMethodParameter    ) o;
            if (_ParameterModifierOpt == null && other.getParameterModifierOpt() != null) return false;
            else if (! _ParameterModifierOpt.equals(other.getParameterModifierOpt())) return false;
            if (! _Type.equals(other.getType())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getParameterModifierOpt() == null ? 0 : getParameterModifierOpt().hashCode());
            hash = hash * 31 + (getType().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 137:  PreIncrementExpression ::= ++ UnaryExpression
     *</b>
     */
    static public class PreIncrementExpression extends Ast implements IPreIncrementExpression
    {
        private IUnaryExpression _UnaryExpression;

        public IUnaryExpression getUnaryExpression() { return _UnaryExpression; }

        public PreIncrementExpression(IToken leftIToken, IToken rightIToken,
                                      IUnaryExpression _UnaryExpression)
        {
            super(leftIToken, rightIToken);

            this._UnaryExpression = _UnaryExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof PreIncrementExpression)) return false;
            PreIncrementExpression other = (PreIncrementExpression    ) o;
            if (! _UnaryExpression.equals(other.getUnaryExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getUnaryExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 138:  PreDecrementExpression ::= -- UnaryExpression
     *</b>
     */
    static public class PreDecrementExpression extends Ast implements IPreDecrementExpression
    {
        private IUnaryExpression _UnaryExpression;

        public IUnaryExpression getUnaryExpression() { return _UnaryExpression; }

        public PreDecrementExpression(IToken leftIToken, IToken rightIToken,
                                      IUnaryExpression _UnaryExpression)
        {
            super(leftIToken, rightIToken);

            this._UnaryExpression = _UnaryExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof PreDecrementExpression)) return false;
            PreDecrementExpression other = (PreDecrementExpression    ) o;
            if (! _UnaryExpression.equals(other.getUnaryExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getUnaryExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 139:  CastExpression ::= ( NonNamedType ) UnaryExpression
     *</b>
     */
    static public class CastExpression extends Ast implements ICastExpression
    {
        private INonNamedType _NonNamedType;
        private IUnaryExpression _UnaryExpression;

        public INonNamedType getNonNamedType() { return _NonNamedType; }
        public IUnaryExpression getUnaryExpression() { return _UnaryExpression; }

        public CastExpression(IToken leftIToken, IToken rightIToken,
                              INonNamedType _NonNamedType,
                              IUnaryExpression _UnaryExpression)
        {
            super(leftIToken, rightIToken);

            this._NonNamedType = _NonNamedType;
            this._UnaryExpression = _UnaryExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof CastExpression)) return false;
            CastExpression other = (CastExpression    ) o;
            if (! _NonNamedType.equals(other.getNonNamedType())) return false;
            if (! _UnaryExpression.equals(other.getUnaryExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getNonNamedType().hashCode());
            hash = hash * 31 + (getUnaryExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 160:  AndExpression ::= EqualityExpression
     *</em>
     *<p>
     *<b>
     *<li>Rule 161:  AndExpression ::= AndExpression & EqualityExpression
     *</b>
     */
    static public class AndExpression extends Ast implements IAndExpression
    {
        private IAndExpression _AndExpression;
        private IEqualityExpression _EqualityExpression;

        public IAndExpression getAndExpression() { return _AndExpression; }
        public IEqualityExpression getEqualityExpression() { return _EqualityExpression; }

        public AndExpression(IToken leftIToken, IToken rightIToken,
                             IAndExpression _AndExpression,
                             IEqualityExpression _EqualityExpression)
        {
            super(leftIToken, rightIToken);

            this._AndExpression = _AndExpression;
            this._EqualityExpression = _EqualityExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AndExpression)) return false;
            AndExpression other = (AndExpression    ) o;
            if (! _AndExpression.equals(other.getAndExpression())) return false;
            if (! _EqualityExpression.equals(other.getEqualityExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAndExpression().hashCode());
            hash = hash * 31 + (getEqualityExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 162:  ExclusiveOrExpression ::= AndExpression
     *</em>
     *<p>
     *<b>
     *<li>Rule 163:  ExclusiveOrExpression ::= ExclusiveOrExpression ^ AndExpression
     *</b>
     */
    static public class ExclusiveOrExpression extends Ast implements IExclusiveOrExpression
    {
        private IExclusiveOrExpression _ExclusiveOrExpression;
        private IAndExpression _AndExpression;

        public IExclusiveOrExpression getExclusiveOrExpression() { return _ExclusiveOrExpression; }
        public IAndExpression getAndExpression() { return _AndExpression; }

        public ExclusiveOrExpression(IToken leftIToken, IToken rightIToken,
                                     IExclusiveOrExpression _ExclusiveOrExpression,
                                     IAndExpression _AndExpression)
        {
            super(leftIToken, rightIToken);

            this._ExclusiveOrExpression = _ExclusiveOrExpression;
            this._AndExpression = _AndExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ExclusiveOrExpression)) return false;
            ExclusiveOrExpression other = (ExclusiveOrExpression    ) o;
            if (! _ExclusiveOrExpression.equals(other.getExclusiveOrExpression())) return false;
            if (! _AndExpression.equals(other.getAndExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getExclusiveOrExpression().hashCode());
            hash = hash * 31 + (getAndExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 164:  InclusiveOrExpression ::= ExclusiveOrExpression
     *</em>
     *<p>
     *<b>
     *<li>Rule 165:  InclusiveOrExpression ::= InclusiveOrExpression | ExclusiveOrExpression
     *</b>
     */
    static public class InclusiveOrExpression extends Ast implements IInclusiveOrExpression
    {
        private IInclusiveOrExpression _InclusiveOrExpression;
        private IExclusiveOrExpression _ExclusiveOrExpression;

        public IInclusiveOrExpression getInclusiveOrExpression() { return _InclusiveOrExpression; }
        public IExclusiveOrExpression getExclusiveOrExpression() { return _ExclusiveOrExpression; }

        public InclusiveOrExpression(IToken leftIToken, IToken rightIToken,
                                     IInclusiveOrExpression _InclusiveOrExpression,
                                     IExclusiveOrExpression _ExclusiveOrExpression)
        {
            super(leftIToken, rightIToken);

            this._InclusiveOrExpression = _InclusiveOrExpression;
            this._ExclusiveOrExpression = _ExclusiveOrExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof InclusiveOrExpression)) return false;
            InclusiveOrExpression other = (InclusiveOrExpression    ) o;
            if (! _InclusiveOrExpression.equals(other.getInclusiveOrExpression())) return false;
            if (! _ExclusiveOrExpression.equals(other.getExclusiveOrExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getInclusiveOrExpression().hashCode());
            hash = hash * 31 + (getExclusiveOrExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 166:  ConditionalAndExpression ::= InclusiveOrExpression
     *</em>
     *<p>
     *<b>
     *<li>Rule 167:  ConditionalAndExpression ::= ConditionalAndExpression && InclusiveOrExpression
     *</b>
     */
    static public class ConditionalAndExpression extends Ast implements IConditionalAndExpression
    {
        private IConditionalAndExpression _ConditionalAndExpression;
        private IInclusiveOrExpression _InclusiveOrExpression;

        public IConditionalAndExpression getConditionalAndExpression() { return _ConditionalAndExpression; }
        public IInclusiveOrExpression getInclusiveOrExpression() { return _InclusiveOrExpression; }

        public ConditionalAndExpression(IToken leftIToken, IToken rightIToken,
                                        IConditionalAndExpression _ConditionalAndExpression,
                                        IInclusiveOrExpression _InclusiveOrExpression)
        {
            super(leftIToken, rightIToken);

            this._ConditionalAndExpression = _ConditionalAndExpression;
            this._InclusiveOrExpression = _InclusiveOrExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ConditionalAndExpression)) return false;
            ConditionalAndExpression other = (ConditionalAndExpression    ) o;
            if (! _ConditionalAndExpression.equals(other.getConditionalAndExpression())) return false;
            if (! _InclusiveOrExpression.equals(other.getInclusiveOrExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getConditionalAndExpression().hashCode());
            hash = hash * 31 + (getInclusiveOrExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 168:  ConditionalOrExpression ::= ConditionalAndExpression
     *</em>
     *<p>
     *<b>
     *<li>Rule 169:  ConditionalOrExpression ::= ConditionalOrExpression || ConditionalAndExpression
     *</b>
     */
    static public class ConditionalOrExpression extends Ast implements IConditionalOrExpression
    {
        private IConditionalOrExpression _ConditionalOrExpression;
        private IConditionalAndExpression _ConditionalAndExpression;

        public IConditionalOrExpression getConditionalOrExpression() { return _ConditionalOrExpression; }
        public IConditionalAndExpression getConditionalAndExpression() { return _ConditionalAndExpression; }

        public ConditionalOrExpression(IToken leftIToken, IToken rightIToken,
                                       IConditionalOrExpression _ConditionalOrExpression,
                                       IConditionalAndExpression _ConditionalAndExpression)
        {
            super(leftIToken, rightIToken);

            this._ConditionalOrExpression = _ConditionalOrExpression;
            this._ConditionalAndExpression = _ConditionalAndExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ConditionalOrExpression)) return false;
            ConditionalOrExpression other = (ConditionalOrExpression    ) o;
            if (! _ConditionalOrExpression.equals(other.getConditionalOrExpression())) return false;
            if (! _ConditionalAndExpression.equals(other.getConditionalAndExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getConditionalOrExpression().hashCode());
            hash = hash * 31 + (getConditionalAndExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 170:  NullCoalescingExpression ::= ConditionalOrExpression
     *</em>
     *<p>
     *<b>
     *<li>Rule 171:  NullCoalescingExpression ::= ConditionalOrExpression ?? NullCoalescingExpression
     *</b>
     */
    static public class NullCoalescingExpression extends Ast implements INullCoalescingExpression
    {
        private IConditionalOrExpression _ConditionalOrExpression;
        private INullCoalescingExpression _NullCoalescingExpression;

        public IConditionalOrExpression getConditionalOrExpression() { return _ConditionalOrExpression; }
        public INullCoalescingExpression getNullCoalescingExpression() { return _NullCoalescingExpression; }

        public NullCoalescingExpression(IToken leftIToken, IToken rightIToken,
                                        IConditionalOrExpression _ConditionalOrExpression,
                                        INullCoalescingExpression _NullCoalescingExpression)
        {
            super(leftIToken, rightIToken);

            this._ConditionalOrExpression = _ConditionalOrExpression;
            this._NullCoalescingExpression = _NullCoalescingExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof NullCoalescingExpression)) return false;
            NullCoalescingExpression other = (NullCoalescingExpression    ) o;
            if (! _ConditionalOrExpression.equals(other.getConditionalOrExpression())) return false;
            if (! _NullCoalescingExpression.equals(other.getNullCoalescingExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getConditionalOrExpression().hashCode());
            hash = hash * 31 + (getNullCoalescingExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 172:  ConditionalExpression ::= NullCoalescingExpression
     *</em>
     *<p>
     *<b>
     *<li>Rule 173:  ConditionalExpression ::= NullCoalescingExpression ? Expression : Expression
     *</b>
     */
    static public class ConditionalExpression extends Ast implements IConditionalExpression
    {
        private INullCoalescingExpression _NullCoalescingExpression;
        private IExpression _Expression;
        private IExpression _Expression5;

        public INullCoalescingExpression getNullCoalescingExpression() { return _NullCoalescingExpression; }
        public IExpression getExpression() { return _Expression; }
        public IExpression getExpression5() { return _Expression5; }

        public ConditionalExpression(IToken leftIToken, IToken rightIToken,
                                     INullCoalescingExpression _NullCoalescingExpression,
                                     IExpression _Expression,
                                     IExpression _Expression5)
        {
            super(leftIToken, rightIToken);

            this._NullCoalescingExpression = _NullCoalescingExpression;
            this._Expression = _Expression;
            this._Expression5 = _Expression5;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ConditionalExpression)) return false;
            ConditionalExpression other = (ConditionalExpression    ) o;
            if (! _NullCoalescingExpression.equals(other.getNullCoalescingExpression())) return false;
            if (! _Expression.equals(other.getExpression())) return false;
            if (! _Expression5.equals(other.getExpression5())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getNullCoalescingExpression().hashCode());
            hash = hash * 31 + (getExpression().hashCode());
            hash = hash * 31 + (getExpression5().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 174:  Assignment ::= UnaryExpression AssignmentOperator Expression
     *</b>
     */
    static public class Assignment extends Ast implements IAssignment
    {
        private IUnaryExpression _UnaryExpression;
        private IAssignmentOperator _AssignmentOperator;
        private IExpression _Expression;

        public IUnaryExpression getUnaryExpression() { return _UnaryExpression; }
        public IAssignmentOperator getAssignmentOperator() { return _AssignmentOperator; }
        public IExpression getExpression() { return _Expression; }

        public Assignment(IToken leftIToken, IToken rightIToken,
                          IUnaryExpression _UnaryExpression,
                          IAssignmentOperator _AssignmentOperator,
                          IExpression _Expression)
        {
            super(leftIToken, rightIToken);

            this._UnaryExpression = _UnaryExpression;
            this._AssignmentOperator = _AssignmentOperator;
            this._Expression = _Expression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof Assignment)) return false;
            Assignment other = (Assignment    ) o;
            if (! _UnaryExpression.equals(other.getUnaryExpression())) return false;
            if (! _AssignmentOperator.equals(other.getAssignmentOperator())) return false;
            if (! _Expression.equals(other.getExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getUnaryExpression().hashCode());
            hash = hash * 31 + (getAssignmentOperator().hashCode());
            hash = hash * 31 + (getExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 207:  Block ::= { StatementListOpt }
     *</b>
     */
    static public class Block extends Ast implements IBlock
    {
        private IStatementListOpt _StatementListOpt;

        /**
         * The value returned by <b>getStatementListOpt</b> may be <b>null</b>
         */
        public IStatementListOpt getStatementListOpt() { return _StatementListOpt; }

        public Block(IToken leftIToken, IToken rightIToken,
                     IStatementListOpt _StatementListOpt)
        {
            super(leftIToken, rightIToken);

            this._StatementListOpt = _StatementListOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof Block)) return false;
            Block other = (Block    ) o;
            if (_StatementListOpt == null && other.getStatementListOpt() != null) return false;
            else if (! _StatementListOpt.equals(other.getStatementListOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getStatementListOpt() == null ? 0 : getStatementListOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 210:  StatementList ::= Statement
     *</em>
     *<p>
     *<b>
     *<li>Rule 211:  StatementList ::= StatementList Statement
     *</b>
     */
    static public class StatementList extends Ast implements IStatementList
    {
        private IStatementList _StatementList;
        private IStatement _Statement;

        public IStatementList getStatementList() { return _StatementList; }
        public IStatement getStatement() { return _Statement; }

        public StatementList(IToken leftIToken, IToken rightIToken,
                             IStatementList _StatementList,
                             IStatement _Statement)
        {
            super(leftIToken, rightIToken);

            this._StatementList = _StatementList;
            this._Statement = _Statement;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof StatementList)) return false;
            StatementList other = (StatementList    ) o;
            if (! _StatementList.equals(other.getStatementList())) return false;
            if (! _Statement.equals(other.getStatement())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getStatementList().hashCode());
            hash = hash * 31 + (getStatement().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 212:  EmptyStatement ::= ;
     *</b>
     */
    static public class EmptyStatement extends AstToken implements IEmptyStatement
    {
        public EmptyStatement(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 213:  LabeledStatement ::= identifier : Statement
     *</b>
     */
    static public class LabeledStatement extends Ast implements ILabeledStatement
    {
        private IStatement _Statement;

        public IStatement getStatement() { return _Statement; }

        public LabeledStatement(IToken leftIToken, IToken rightIToken,
                                IStatement _Statement)
        {
            super(leftIToken, rightIToken);

            this._Statement = _Statement;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof LabeledStatement)) return false;
            LabeledStatement other = (LabeledStatement    ) o;
            if (! _Statement.equals(other.getStatement())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getStatement().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 216:  LocalVariableDeclaration ::= Type LocalVariableDeclarators
     *</b>
     */
    static public class LocalVariableDeclaration extends Ast implements ILocalVariableDeclaration
    {
        private IType _Type;
        private ILocalVariableDeclarators _LocalVariableDeclarators;

        public IType getType() { return _Type; }
        public ILocalVariableDeclarators getLocalVariableDeclarators() { return _LocalVariableDeclarators; }

        public LocalVariableDeclaration(IToken leftIToken, IToken rightIToken,
                                        IType _Type,
                                        ILocalVariableDeclarators _LocalVariableDeclarators)
        {
            super(leftIToken, rightIToken);

            this._Type = _Type;
            this._LocalVariableDeclarators = _LocalVariableDeclarators;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof LocalVariableDeclaration)) return false;
            LocalVariableDeclaration other = (LocalVariableDeclaration    ) o;
            if (! _Type.equals(other.getType())) return false;
            if (! _LocalVariableDeclarators.equals(other.getLocalVariableDeclarators())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getLocalVariableDeclarators().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 217:  LocalVariableDeclarators ::= LocalVariableDeclarator
     *</em>
     *<p>
     *<b>
     *<li>Rule 218:  LocalVariableDeclarators ::= LocalVariableDeclarators , LocalVariableDeclarator
     *</b>
     */
    static public class LocalVariableDeclarators extends Ast implements ILocalVariableDeclarators
    {
        private ILocalVariableDeclarators _LocalVariableDeclarators;
        private ILocalVariableDeclarator _LocalVariableDeclarator;

        public ILocalVariableDeclarators getLocalVariableDeclarators() { return _LocalVariableDeclarators; }
        public ILocalVariableDeclarator getLocalVariableDeclarator() { return _LocalVariableDeclarator; }

        public LocalVariableDeclarators(IToken leftIToken, IToken rightIToken,
                                        ILocalVariableDeclarators _LocalVariableDeclarators,
                                        ILocalVariableDeclarator _LocalVariableDeclarator)
        {
            super(leftIToken, rightIToken);

            this._LocalVariableDeclarators = _LocalVariableDeclarators;
            this._LocalVariableDeclarator = _LocalVariableDeclarator;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof LocalVariableDeclarators)) return false;
            LocalVariableDeclarators other = (LocalVariableDeclarators    ) o;
            if (! _LocalVariableDeclarators.equals(other.getLocalVariableDeclarators())) return false;
            if (! _LocalVariableDeclarator.equals(other.getLocalVariableDeclarator())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getLocalVariableDeclarators().hashCode());
            hash = hash * 31 + (getLocalVariableDeclarator().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 223:  LocalConstantDeclaration ::= const Type ConstantDeclarators
     *</b>
     */
    static public class LocalConstantDeclaration extends Ast implements ILocalConstantDeclaration
    {
        private IType _Type;
        private IConstantDeclarators _ConstantDeclarators;

        public IType getType() { return _Type; }
        public IConstantDeclarators getConstantDeclarators() { return _ConstantDeclarators; }

        public LocalConstantDeclaration(IToken leftIToken, IToken rightIToken,
                                        IType _Type,
                                        IConstantDeclarators _ConstantDeclarators)
        {
            super(leftIToken, rightIToken);

            this._Type = _Type;
            this._ConstantDeclarators = _ConstantDeclarators;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof LocalConstantDeclaration)) return false;
            LocalConstantDeclaration other = (LocalConstantDeclaration    ) o;
            if (! _Type.equals(other.getType())) return false;
            if (! _ConstantDeclarators.equals(other.getConstantDeclarators())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getConstantDeclarators().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 224:  ExpressionStatement ::= StatementExpression ;
     *</b>
     */
    static public class ExpressionStatement extends Ast implements IExpressionStatement
    {
        private IStatementExpression _StatementExpression;

        public IStatementExpression getStatementExpression() { return _StatementExpression; }

        public ExpressionStatement(IToken leftIToken, IToken rightIToken,
                                   IStatementExpression _StatementExpression)
        {
            super(leftIToken, rightIToken);

            this._StatementExpression = _StatementExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ExpressionStatement)) return false;
            ExpressionStatement other = (ExpressionStatement    ) o;
            if (! _StatementExpression.equals(other.getStatementExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getStatementExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 235:  IfStatement ::= if ( BooleanExpression ) EmbeddedStatement
     *</b>
     */
    static public class IfStatement extends Ast implements IIfStatement
    {
        private IBooleanExpression _BooleanExpression;
        private IEmbeddedStatement _EmbeddedStatement;

        public IBooleanExpression getBooleanExpression() { return _BooleanExpression; }
        public IEmbeddedStatement getEmbeddedStatement() { return _EmbeddedStatement; }

        public IfStatement(IToken leftIToken, IToken rightIToken,
                           IBooleanExpression _BooleanExpression,
                           IEmbeddedStatement _EmbeddedStatement)
        {
            super(leftIToken, rightIToken);

            this._BooleanExpression = _BooleanExpression;
            this._EmbeddedStatement = _EmbeddedStatement;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof IfStatement)) return false;
            IfStatement other = (IfStatement    ) o;
            if (! _BooleanExpression.equals(other.getBooleanExpression())) return false;
            if (! _EmbeddedStatement.equals(other.getEmbeddedStatement())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getBooleanExpression().hashCode());
            hash = hash * 31 + (getEmbeddedStatement().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 236:  ElseStatement ::= else EmbeddedStatement
     *</b>
     */
    static public class ElseStatement extends Ast implements IElseStatement
    {
        private IEmbeddedStatement _EmbeddedStatement;

        public IEmbeddedStatement getEmbeddedStatement() { return _EmbeddedStatement; }

        public ElseStatement(IToken leftIToken, IToken rightIToken,
                             IEmbeddedStatement _EmbeddedStatement)
        {
            super(leftIToken, rightIToken);

            this._EmbeddedStatement = _EmbeddedStatement;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ElseStatement)) return false;
            ElseStatement other = (ElseStatement    ) o;
            if (! _EmbeddedStatement.equals(other.getEmbeddedStatement())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getEmbeddedStatement().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 237:  SwitchStatement ::= switch ( Expression ) SwitchBlock
     *</b>
     */
    static public class SwitchStatement extends Ast implements ISwitchStatement
    {
        private IExpression _Expression;
        private SwitchBlock _SwitchBlock;

        public IExpression getExpression() { return _Expression; }
        public SwitchBlock getSwitchBlock() { return _SwitchBlock; }

        public SwitchStatement(IToken leftIToken, IToken rightIToken,
                               IExpression _Expression,
                               SwitchBlock _SwitchBlock)
        {
            super(leftIToken, rightIToken);

            this._Expression = _Expression;
            this._SwitchBlock = _SwitchBlock;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof SwitchStatement)) return false;
            SwitchStatement other = (SwitchStatement    ) o;
            if (! _Expression.equals(other.getExpression())) return false;
            if (! _SwitchBlock.equals(other.getSwitchBlock())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getExpression().hashCode());
            hash = hash * 31 + (getSwitchBlock().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 238:  SwitchBlock ::= { SwitchSectionsOpt }
     *</b>
     */
    static public class SwitchBlock extends Ast implements ISwitchBlock
    {
        private ISwitchSectionsOpt _SwitchSectionsOpt;

        /**
         * The value returned by <b>getSwitchSectionsOpt</b> may be <b>null</b>
         */
        public ISwitchSectionsOpt getSwitchSectionsOpt() { return _SwitchSectionsOpt; }

        public SwitchBlock(IToken leftIToken, IToken rightIToken,
                           ISwitchSectionsOpt _SwitchSectionsOpt)
        {
            super(leftIToken, rightIToken);

            this._SwitchSectionsOpt = _SwitchSectionsOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof SwitchBlock)) return false;
            SwitchBlock other = (SwitchBlock    ) o;
            if (_SwitchSectionsOpt == null && other.getSwitchSectionsOpt() != null) return false;
            else if (! _SwitchSectionsOpt.equals(other.getSwitchSectionsOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getSwitchSectionsOpt() == null ? 0 : getSwitchSectionsOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 241:  SwitchSections ::= SwitchSection
     *</em>
     *<p>
     *<b>
     *<li>Rule 242:  SwitchSections ::= SwitchSections SwitchSection
     *</b>
     */
    static public class SwitchSections extends Ast implements ISwitchSections
    {
        private ISwitchSections _SwitchSections;
        private SwitchSection _SwitchSection;

        public ISwitchSections getSwitchSections() { return _SwitchSections; }
        public SwitchSection getSwitchSection() { return _SwitchSection; }

        public SwitchSections(IToken leftIToken, IToken rightIToken,
                              ISwitchSections _SwitchSections,
                              SwitchSection _SwitchSection)
        {
            super(leftIToken, rightIToken);

            this._SwitchSections = _SwitchSections;
            this._SwitchSection = _SwitchSection;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof SwitchSections)) return false;
            SwitchSections other = (SwitchSections    ) o;
            if (! _SwitchSections.equals(other.getSwitchSections())) return false;
            if (! _SwitchSection.equals(other.getSwitchSection())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getSwitchSections().hashCode());
            hash = hash * 31 + (getSwitchSection().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 243:  SwitchSection ::= SwitchLabels StatementList
     *</b>
     */
    static public class SwitchSection extends Ast implements ISwitchSection
    {
        private ISwitchLabels _SwitchLabels;
        private IStatementList _StatementList;

        public ISwitchLabels getSwitchLabels() { return _SwitchLabels; }
        public IStatementList getStatementList() { return _StatementList; }

        public SwitchSection(IToken leftIToken, IToken rightIToken,
                             ISwitchLabels _SwitchLabels,
                             IStatementList _StatementList)
        {
            super(leftIToken, rightIToken);

            this._SwitchLabels = _SwitchLabels;
            this._StatementList = _StatementList;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof SwitchSection)) return false;
            SwitchSection other = (SwitchSection    ) o;
            if (! _SwitchLabels.equals(other.getSwitchLabels())) return false;
            if (! _StatementList.equals(other.getStatementList())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getSwitchLabels().hashCode());
            hash = hash * 31 + (getStatementList().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 244:  SwitchLabels ::= SwitchLabel
     *</em>
     *<p>
     *<b>
     *<li>Rule 245:  SwitchLabels ::= SwitchLabels SwitchLabel
     *</b>
     */
    static public class SwitchLabels extends Ast implements ISwitchLabels
    {
        private ISwitchLabels _SwitchLabels;
        private ISwitchLabel _SwitchLabel;

        public ISwitchLabels getSwitchLabels() { return _SwitchLabels; }
        public ISwitchLabel getSwitchLabel() { return _SwitchLabel; }

        public SwitchLabels(IToken leftIToken, IToken rightIToken,
                            ISwitchLabels _SwitchLabels,
                            ISwitchLabel _SwitchLabel)
        {
            super(leftIToken, rightIToken);

            this._SwitchLabels = _SwitchLabels;
            this._SwitchLabel = _SwitchLabel;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof SwitchLabels)) return false;
            SwitchLabels other = (SwitchLabels    ) o;
            if (! _SwitchLabels.equals(other.getSwitchLabels())) return false;
            if (! _SwitchLabel.equals(other.getSwitchLabel())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getSwitchLabels().hashCode());
            hash = hash * 31 + (getSwitchLabel().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 252:  WhileStatement ::= while ( BooleanExpression ) EmbeddedStatement
     *</b>
     */
    static public class WhileStatement extends Ast implements IWhileStatement
    {
        private IBooleanExpression _BooleanExpression;
        private IEmbeddedStatement _EmbeddedStatement;

        public IBooleanExpression getBooleanExpression() { return _BooleanExpression; }
        public IEmbeddedStatement getEmbeddedStatement() { return _EmbeddedStatement; }

        public WhileStatement(IToken leftIToken, IToken rightIToken,
                              IBooleanExpression _BooleanExpression,
                              IEmbeddedStatement _EmbeddedStatement)
        {
            super(leftIToken, rightIToken);

            this._BooleanExpression = _BooleanExpression;
            this._EmbeddedStatement = _EmbeddedStatement;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof WhileStatement)) return false;
            WhileStatement other = (WhileStatement    ) o;
            if (! _BooleanExpression.equals(other.getBooleanExpression())) return false;
            if (! _EmbeddedStatement.equals(other.getEmbeddedStatement())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getBooleanExpression().hashCode());
            hash = hash * 31 + (getEmbeddedStatement().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 253:  DoStatement ::= do EmbeddedStatement while ( BooleanExpression ) ;
     *</b>
     */
    static public class DoStatement extends Ast implements IDoStatement
    {
        private IEmbeddedStatement _EmbeddedStatement;
        private IBooleanExpression _BooleanExpression;

        public IEmbeddedStatement getEmbeddedStatement() { return _EmbeddedStatement; }
        public IBooleanExpression getBooleanExpression() { return _BooleanExpression; }

        public DoStatement(IToken leftIToken, IToken rightIToken,
                           IEmbeddedStatement _EmbeddedStatement,
                           IBooleanExpression _BooleanExpression)
        {
            super(leftIToken, rightIToken);

            this._EmbeddedStatement = _EmbeddedStatement;
            this._BooleanExpression = _BooleanExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof DoStatement)) return false;
            DoStatement other = (DoStatement    ) o;
            if (! _EmbeddedStatement.equals(other.getEmbeddedStatement())) return false;
            if (! _BooleanExpression.equals(other.getBooleanExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getEmbeddedStatement().hashCode());
            hash = hash * 31 + (getBooleanExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 254:  ForStatement ::= for ( ForInitializerOpt ; ForConditionOpt ; ForIteratorOpt ) EmbeddedStatement
     *</b>
     */
    static public class ForStatement extends Ast implements IForStatement
    {
        private IForInitializerOpt _ForInitializerOpt;
        private IForConditionOpt _ForConditionOpt;
        private IForIteratorOpt _ForIteratorOpt;
        private IEmbeddedStatement _EmbeddedStatement;

        /**
         * The value returned by <b>getForInitializerOpt</b> may be <b>null</b>
         */
        public IForInitializerOpt getForInitializerOpt() { return _ForInitializerOpt; }
        /**
         * The value returned by <b>getForConditionOpt</b> may be <b>null</b>
         */
        public IForConditionOpt getForConditionOpt() { return _ForConditionOpt; }
        /**
         * The value returned by <b>getForIteratorOpt</b> may be <b>null</b>
         */
        public IForIteratorOpt getForIteratorOpt() { return _ForIteratorOpt; }
        public IEmbeddedStatement getEmbeddedStatement() { return _EmbeddedStatement; }

        public ForStatement(IToken leftIToken, IToken rightIToken,
                            IForInitializerOpt _ForInitializerOpt,
                            IForConditionOpt _ForConditionOpt,
                            IForIteratorOpt _ForIteratorOpt,
                            IEmbeddedStatement _EmbeddedStatement)
        {
            super(leftIToken, rightIToken);

            this._ForInitializerOpt = _ForInitializerOpt;
            this._ForConditionOpt = _ForConditionOpt;
            this._ForIteratorOpt = _ForIteratorOpt;
            this._EmbeddedStatement = _EmbeddedStatement;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ForStatement)) return false;
            ForStatement other = (ForStatement    ) o;
            if (_ForInitializerOpt == null && other.getForInitializerOpt() != null) return false;
            else if (! _ForInitializerOpt.equals(other.getForInitializerOpt())) return false;
            if (_ForConditionOpt == null && other.getForConditionOpt() != null) return false;
            else if (! _ForConditionOpt.equals(other.getForConditionOpt())) return false;
            if (_ForIteratorOpt == null && other.getForIteratorOpt() != null) return false;
            else if (! _ForIteratorOpt.equals(other.getForIteratorOpt())) return false;
            if (! _EmbeddedStatement.equals(other.getEmbeddedStatement())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getForInitializerOpt() == null ? 0 : getForInitializerOpt().hashCode());
            hash = hash * 31 + (getForConditionOpt() == null ? 0 : getForConditionOpt().hashCode());
            hash = hash * 31 + (getForIteratorOpt() == null ? 0 : getForIteratorOpt().hashCode());
            hash = hash * 31 + (getEmbeddedStatement().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 265:  StatementExpressionList ::= StatementExpression
     *</em>
     *<p>
     *<b>
     *<li>Rule 266:  StatementExpressionList ::= StatementExpressionList , StatementExpression
     *</b>
     */
    static public class StatementExpressionList extends Ast implements IStatementExpressionList
    {
        private IStatementExpressionList _StatementExpressionList;
        private IStatementExpression _StatementExpression;

        public IStatementExpressionList getStatementExpressionList() { return _StatementExpressionList; }
        public IStatementExpression getStatementExpression() { return _StatementExpression; }

        public StatementExpressionList(IToken leftIToken, IToken rightIToken,
                                       IStatementExpressionList _StatementExpressionList,
                                       IStatementExpression _StatementExpression)
        {
            super(leftIToken, rightIToken);

            this._StatementExpressionList = _StatementExpressionList;
            this._StatementExpression = _StatementExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof StatementExpressionList)) return false;
            StatementExpressionList other = (StatementExpressionList    ) o;
            if (! _StatementExpressionList.equals(other.getStatementExpressionList())) return false;
            if (! _StatementExpression.equals(other.getStatementExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getStatementExpressionList().hashCode());
            hash = hash * 31 + (getStatementExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 267:  ForeachStatement ::= foreach ( Type identifier in Expression ) EmbeddedStatement
     *</b>
     */
    static public class ForeachStatement extends Ast implements IForeachStatement
    {
        private IType _Type;
        private IExpression _Expression;
        private IEmbeddedStatement _EmbeddedStatement;

        public IType getType() { return _Type; }
        public IExpression getExpression() { return _Expression; }
        public IEmbeddedStatement getEmbeddedStatement() { return _EmbeddedStatement; }

        public ForeachStatement(IToken leftIToken, IToken rightIToken,
                                IType _Type,
                                IExpression _Expression,
                                IEmbeddedStatement _EmbeddedStatement)
        {
            super(leftIToken, rightIToken);

            this._Type = _Type;
            this._Expression = _Expression;
            this._EmbeddedStatement = _EmbeddedStatement;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ForeachStatement)) return false;
            ForeachStatement other = (ForeachStatement    ) o;
            if (! _Type.equals(other.getType())) return false;
            if (! _Expression.equals(other.getExpression())) return false;
            if (! _EmbeddedStatement.equals(other.getEmbeddedStatement())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getExpression().hashCode());
            hash = hash * 31 + (getEmbeddedStatement().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 273:  BreakStatement ::= break ;
     *</b>
     */
    static public class BreakStatement extends Ast implements IBreakStatement
    {
        public BreakStatement(IToken leftIToken, IToken rightIToken)
        {
            super(leftIToken, rightIToken);

            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof BreakStatement)) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 274:  ContinueStatement ::= continue ;
     *</b>
     */
    static public class ContinueStatement extends Ast implements IContinueStatement
    {
        public ContinueStatement(IToken leftIToken, IToken rightIToken)
        {
            super(leftIToken, rightIToken);

            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ContinueStatement)) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 278:  ReturnStatement ::= return ExpressionOpt ;
     *</b>
     */
    static public class ReturnStatement extends Ast implements IReturnStatement
    {
        private IExpressionOpt _ExpressionOpt;

        /**
         * The value returned by <b>getExpressionOpt</b> may be <b>null</b>
         */
        public IExpressionOpt getExpressionOpt() { return _ExpressionOpt; }

        public ReturnStatement(IToken leftIToken, IToken rightIToken,
                               IExpressionOpt _ExpressionOpt)
        {
            super(leftIToken, rightIToken);

            this._ExpressionOpt = _ExpressionOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ReturnStatement)) return false;
            ReturnStatement other = (ReturnStatement    ) o;
            if (_ExpressionOpt == null && other.getExpressionOpt() != null) return false;
            else if (! _ExpressionOpt.equals(other.getExpressionOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getExpressionOpt() == null ? 0 : getExpressionOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 279:  ThrowStatement ::= throw ExpressionOpt ;
     *</b>
     */
    static public class ThrowStatement extends Ast implements IThrowStatement
    {
        private IExpressionOpt _ExpressionOpt;

        /**
         * The value returned by <b>getExpressionOpt</b> may be <b>null</b>
         */
        public IExpressionOpt getExpressionOpt() { return _ExpressionOpt; }

        public ThrowStatement(IToken leftIToken, IToken rightIToken,
                              IExpressionOpt _ExpressionOpt)
        {
            super(leftIToken, rightIToken);

            this._ExpressionOpt = _ExpressionOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ThrowStatement)) return false;
            ThrowStatement other = (ThrowStatement    ) o;
            if (_ExpressionOpt == null && other.getExpressionOpt() != null) return false;
            else if (! _ExpressionOpt.equals(other.getExpressionOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getExpressionOpt() == null ? 0 : getExpressionOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 284:  CatchClauses ::= SpecificCatchClauses
     *</em>
     *<p>
     *<b>
     *<li>Rule 285:  CatchClauses ::= SpecificCatchClausesOpt GeneralCatchClause
     *</b>
     */
    static public class CatchClauses extends Ast implements ICatchClauses
    {
        private ISpecificCatchClausesOpt _SpecificCatchClausesOpt;
        private GeneralCatchClause _GeneralCatchClause;

        /**
         * The value returned by <b>getSpecificCatchClausesOpt</b> may be <b>null</b>
         */
        public ISpecificCatchClausesOpt getSpecificCatchClausesOpt() { return _SpecificCatchClausesOpt; }
        public GeneralCatchClause getGeneralCatchClause() { return _GeneralCatchClause; }

        public CatchClauses(IToken leftIToken, IToken rightIToken,
                            ISpecificCatchClausesOpt _SpecificCatchClausesOpt,
                            GeneralCatchClause _GeneralCatchClause)
        {
            super(leftIToken, rightIToken);

            this._SpecificCatchClausesOpt = _SpecificCatchClausesOpt;
            this._GeneralCatchClause = _GeneralCatchClause;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof CatchClauses)) return false;
            CatchClauses other = (CatchClauses    ) o;
            if (_SpecificCatchClausesOpt == null && other.getSpecificCatchClausesOpt() != null) return false;
            else if (! _SpecificCatchClausesOpt.equals(other.getSpecificCatchClausesOpt())) return false;
            if (! _GeneralCatchClause.equals(other.getGeneralCatchClause())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getSpecificCatchClausesOpt() == null ? 0 : getSpecificCatchClausesOpt().hashCode());
            hash = hash * 31 + (getGeneralCatchClause().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 288:  SpecificCatchClauses ::= SpecificCatchClause
     *</em>
     *<p>
     *<b>
     *<li>Rule 289:  SpecificCatchClauses ::= SpecificCatchClauses SpecificCatchClause
     *</b>
     */
    static public class SpecificCatchClauses extends Ast implements ISpecificCatchClauses
    {
        private ISpecificCatchClauses _SpecificCatchClauses;
        private SpecificCatchClause _SpecificCatchClause;

        public ISpecificCatchClauses getSpecificCatchClauses() { return _SpecificCatchClauses; }
        public SpecificCatchClause getSpecificCatchClause() { return _SpecificCatchClause; }

        public SpecificCatchClauses(IToken leftIToken, IToken rightIToken,
                                    ISpecificCatchClauses _SpecificCatchClauses,
                                    SpecificCatchClause _SpecificCatchClause)
        {
            super(leftIToken, rightIToken);

            this._SpecificCatchClauses = _SpecificCatchClauses;
            this._SpecificCatchClause = _SpecificCatchClause;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof SpecificCatchClauses)) return false;
            SpecificCatchClauses other = (SpecificCatchClauses    ) o;
            if (! _SpecificCatchClauses.equals(other.getSpecificCatchClauses())) return false;
            if (! _SpecificCatchClause.equals(other.getSpecificCatchClause())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getSpecificCatchClauses().hashCode());
            hash = hash * 31 + (getSpecificCatchClause().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 290:  SpecificCatchClause ::= catch ( ClassType IdentifierOpt ) Block
     *</b>
     */
    static public class SpecificCatchClause extends Ast implements ISpecificCatchClause
    {
        private IClassType _ClassType;
        private IdentifierOpt _IdentifierOpt;
        private Block _Block;

        public IClassType getClassType() { return _ClassType; }
        /**
         * The value returned by <b>getIdentifierOpt</b> may be <b>null</b>
         */
        public IdentifierOpt getIdentifierOpt() { return _IdentifierOpt; }
        public Block getBlock() { return _Block; }

        public SpecificCatchClause(IToken leftIToken, IToken rightIToken,
                                   IClassType _ClassType,
                                   IdentifierOpt _IdentifierOpt,
                                   Block _Block)
        {
            super(leftIToken, rightIToken);

            this._ClassType = _ClassType;
            this._IdentifierOpt = _IdentifierOpt;
            this._Block = _Block;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof SpecificCatchClause)) return false;
            SpecificCatchClause other = (SpecificCatchClause    ) o;
            if (! _ClassType.equals(other.getClassType())) return false;
            if (_IdentifierOpt == null && other.getIdentifierOpt() != null) return false;
            else if (! _IdentifierOpt.equals(other.getIdentifierOpt())) return false;
            if (! _Block.equals(other.getBlock())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getClassType().hashCode());
            hash = hash * 31 + (getIdentifierOpt() == null ? 0 : getIdentifierOpt().hashCode());
            hash = hash * 31 + (getBlock().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 291:  GeneralCatchClause ::= catch Block
     *</b>
     */
    static public class GeneralCatchClause extends Ast implements IGeneralCatchClause
    {
        private Block _Block;

        public Block getBlock() { return _Block; }

        public GeneralCatchClause(IToken leftIToken, IToken rightIToken,
                                  Block _Block)
        {
            super(leftIToken, rightIToken);

            this._Block = _Block;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof GeneralCatchClause)) return false;
            GeneralCatchClause other = (GeneralCatchClause    ) o;
            if (! _Block.equals(other.getBlock())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getBlock().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 292:  FinallyClause ::= finally Block
     *</b>
     */
    static public class FinallyClause extends Ast implements IFinallyClause
    {
        private Block _Block;

        public Block getBlock() { return _Block; }

        public FinallyClause(IToken leftIToken, IToken rightIToken,
                             Block _Block)
        {
            super(leftIToken, rightIToken);

            this._Block = _Block;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof FinallyClause)) return false;
            FinallyClause other = (FinallyClause    ) o;
            if (! _Block.equals(other.getBlock())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getBlock().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 293:  CheckedStatement ::= checked Block
     *</b>
     */
    static public class CheckedStatement extends Ast implements ICheckedStatement
    {
        private Block _Block;

        public Block getBlock() { return _Block; }

        public CheckedStatement(IToken leftIToken, IToken rightIToken,
                                Block _Block)
        {
            super(leftIToken, rightIToken);

            this._Block = _Block;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof CheckedStatement)) return false;
            CheckedStatement other = (CheckedStatement    ) o;
            if (! _Block.equals(other.getBlock())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getBlock().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 294:  UncheckedStatement ::= unchecked Block
     *</b>
     */
    static public class UncheckedStatement extends Ast implements IUncheckedStatement
    {
        private Block _Block;

        public Block getBlock() { return _Block; }

        public UncheckedStatement(IToken leftIToken, IToken rightIToken,
                                  Block _Block)
        {
            super(leftIToken, rightIToken);

            this._Block = _Block;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof UncheckedStatement)) return false;
            UncheckedStatement other = (UncheckedStatement    ) o;
            if (! _Block.equals(other.getBlock())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getBlock().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 295:  LockStatement ::= lock ( Expression ) EmbeddedStatement
     *</b>
     */
    static public class LockStatement extends Ast implements ILockStatement
    {
        private IExpression _Expression;
        private IEmbeddedStatement _EmbeddedStatement;

        public IExpression getExpression() { return _Expression; }
        public IEmbeddedStatement getEmbeddedStatement() { return _EmbeddedStatement; }

        public LockStatement(IToken leftIToken, IToken rightIToken,
                             IExpression _Expression,
                             IEmbeddedStatement _EmbeddedStatement)
        {
            super(leftIToken, rightIToken);

            this._Expression = _Expression;
            this._EmbeddedStatement = _EmbeddedStatement;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof LockStatement)) return false;
            LockStatement other = (LockStatement    ) o;
            if (! _Expression.equals(other.getExpression())) return false;
            if (! _EmbeddedStatement.equals(other.getEmbeddedStatement())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getExpression().hashCode());
            hash = hash * 31 + (getEmbeddedStatement().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 296:  UsingStatement ::= using ( ResourceAcquisition ) EmbeddedStatement
     *</b>
     */
    static public class UsingStatement extends Ast implements IUsingStatement
    {
        private IResourceAcquisition _ResourceAcquisition;
        private IEmbeddedStatement _EmbeddedStatement;

        public IResourceAcquisition getResourceAcquisition() { return _ResourceAcquisition; }
        public IEmbeddedStatement getEmbeddedStatement() { return _EmbeddedStatement; }

        public UsingStatement(IToken leftIToken, IToken rightIToken,
                              IResourceAcquisition _ResourceAcquisition,
                              IEmbeddedStatement _EmbeddedStatement)
        {
            super(leftIToken, rightIToken);

            this._ResourceAcquisition = _ResourceAcquisition;
            this._EmbeddedStatement = _EmbeddedStatement;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof UsingStatement)) return false;
            UsingStatement other = (UsingStatement    ) o;
            if (! _ResourceAcquisition.equals(other.getResourceAcquisition())) return false;
            if (! _EmbeddedStatement.equals(other.getEmbeddedStatement())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getResourceAcquisition().hashCode());
            hash = hash * 31 + (getEmbeddedStatement().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 301:  NamespaceDeclaration ::= namespace Name NamespaceBody SemiOpt
     *</b>
     */
    static public class NamespaceDeclaration extends Ast implements INamespaceDeclaration
    {
        private IName _Name;
        private NamespaceBody _NamespaceBody;
        private SemiOpt _SemiOpt;

        public IName getName() { return _Name; }
        public NamespaceBody getNamespaceBody() { return _NamespaceBody; }
        /**
         * The value returned by <b>getSemiOpt</b> may be <b>null</b>
         */
        public SemiOpt getSemiOpt() { return _SemiOpt; }

        public NamespaceDeclaration(IToken leftIToken, IToken rightIToken,
                                    IName _Name,
                                    NamespaceBody _NamespaceBody,
                                    SemiOpt _SemiOpt)
        {
            super(leftIToken, rightIToken);

            this._Name = _Name;
            this._NamespaceBody = _NamespaceBody;
            this._SemiOpt = _SemiOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof NamespaceDeclaration)) return false;
            NamespaceDeclaration other = (NamespaceDeclaration    ) o;
            if (! _Name.equals(other.getName())) return false;
            if (! _NamespaceBody.equals(other.getNamespaceBody())) return false;
            if (_SemiOpt == null && other.getSemiOpt() != null) return false;
            else if (! _SemiOpt.equals(other.getSemiOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getName().hashCode());
            hash = hash * 31 + (getNamespaceBody().hashCode());
            hash = hash * 31 + (getSemiOpt() == null ? 0 : getSemiOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 302:  NamespaceBody ::= { ExternAliasDirectivesOpt UsingDirectivesOpt NamespaceMemberDeclarationsOpt }
     *</b>
     */
    static public class NamespaceBody extends Ast implements INamespaceBody
    {
        private IExternAliasDirectivesOpt _ExternAliasDirectivesOpt;
        private IUsingDirectivesOpt _UsingDirectivesOpt;
        private INamespaceMemberDeclarationsOpt _NamespaceMemberDeclarationsOpt;

        /**
         * The value returned by <b>getExternAliasDirectivesOpt</b> may be <b>null</b>
         */
        public IExternAliasDirectivesOpt getExternAliasDirectivesOpt() { return _ExternAliasDirectivesOpt; }
        /**
         * The value returned by <b>getUsingDirectivesOpt</b> may be <b>null</b>
         */
        public IUsingDirectivesOpt getUsingDirectivesOpt() { return _UsingDirectivesOpt; }
        /**
         * The value returned by <b>getNamespaceMemberDeclarationsOpt</b> may be <b>null</b>
         */
        public INamespaceMemberDeclarationsOpt getNamespaceMemberDeclarationsOpt() { return _NamespaceMemberDeclarationsOpt; }

        public NamespaceBody(IToken leftIToken, IToken rightIToken,
                             IExternAliasDirectivesOpt _ExternAliasDirectivesOpt,
                             IUsingDirectivesOpt _UsingDirectivesOpt,
                             INamespaceMemberDeclarationsOpt _NamespaceMemberDeclarationsOpt)
        {
            super(leftIToken, rightIToken);

            this._ExternAliasDirectivesOpt = _ExternAliasDirectivesOpt;
            this._UsingDirectivesOpt = _UsingDirectivesOpt;
            this._NamespaceMemberDeclarationsOpt = _NamespaceMemberDeclarationsOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof NamespaceBody)) return false;
            NamespaceBody other = (NamespaceBody    ) o;
            if (_ExternAliasDirectivesOpt == null && other.getExternAliasDirectivesOpt() != null) return false;
            else if (! _ExternAliasDirectivesOpt.equals(other.getExternAliasDirectivesOpt())) return false;
            if (_UsingDirectivesOpt == null && other.getUsingDirectivesOpt() != null) return false;
            else if (! _UsingDirectivesOpt.equals(other.getUsingDirectivesOpt())) return false;
            if (_NamespaceMemberDeclarationsOpt == null && other.getNamespaceMemberDeclarationsOpt() != null) return false;
            else if (! _NamespaceMemberDeclarationsOpt.equals(other.getNamespaceMemberDeclarationsOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getExternAliasDirectivesOpt() == null ? 0 : getExternAliasDirectivesOpt().hashCode());
            hash = hash * 31 + (getUsingDirectivesOpt() == null ? 0 : getUsingDirectivesOpt().hashCode());
            hash = hash * 31 + (getNamespaceMemberDeclarationsOpt() == null ? 0 : getNamespaceMemberDeclarationsOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 305:  ExternAliasDirectives ::= ExternAliasDirective
     *</em>
     *<p>
     *<b>
     *<li>Rule 306:  ExternAliasDirectives ::= ExternAliasDirectives ExternAliasDirective
     *</b>
     */
    static public class ExternAliasDirectives extends Ast implements IExternAliasDirectives
    {
        private IExternAliasDirectives _ExternAliasDirectives;
        private ExternAliasDirective _ExternAliasDirective;

        public IExternAliasDirectives getExternAliasDirectives() { return _ExternAliasDirectives; }
        public ExternAliasDirective getExternAliasDirective() { return _ExternAliasDirective; }

        public ExternAliasDirectives(IToken leftIToken, IToken rightIToken,
                                     IExternAliasDirectives _ExternAliasDirectives,
                                     ExternAliasDirective _ExternAliasDirective)
        {
            super(leftIToken, rightIToken);

            this._ExternAliasDirectives = _ExternAliasDirectives;
            this._ExternAliasDirective = _ExternAliasDirective;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ExternAliasDirectives)) return false;
            ExternAliasDirectives other = (ExternAliasDirectives    ) o;
            if (! _ExternAliasDirectives.equals(other.getExternAliasDirectives())) return false;
            if (! _ExternAliasDirective.equals(other.getExternAliasDirective())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getExternAliasDirectives().hashCode());
            hash = hash * 31 + (getExternAliasDirective().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 307:  ExternAliasDirective ::= extern alias identifier ;
     *</b>
     */
    static public class ExternAliasDirective extends Ast implements IExternAliasDirective
    {
        public ExternAliasDirective(IToken leftIToken, IToken rightIToken)
        {
            super(leftIToken, rightIToken);

            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ExternAliasDirective)) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 310:  UsingDirectives ::= UsingDirective
     *</em>
     *<p>
     *<b>
     *<li>Rule 311:  UsingDirectives ::= UsingDirectives UsingDirective
     *</b>
     */
    static public class UsingDirectives extends Ast implements IUsingDirectives
    {
        private IUsingDirectives _UsingDirectives;
        private IUsingDirective _UsingDirective;

        public IUsingDirectives getUsingDirectives() { return _UsingDirectives; }
        public IUsingDirective getUsingDirective() { return _UsingDirective; }

        public UsingDirectives(IToken leftIToken, IToken rightIToken,
                               IUsingDirectives _UsingDirectives,
                               IUsingDirective _UsingDirective)
        {
            super(leftIToken, rightIToken);

            this._UsingDirectives = _UsingDirectives;
            this._UsingDirective = _UsingDirective;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof UsingDirectives)) return false;
            UsingDirectives other = (UsingDirectives    ) o;
            if (! _UsingDirectives.equals(other.getUsingDirectives())) return false;
            if (! _UsingDirective.equals(other.getUsingDirective())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getUsingDirectives().hashCode());
            hash = hash * 31 + (getUsingDirective().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 314:  UsingAliasDirective ::= using identifier = Name ;
     *</b>
     */
    static public class UsingAliasDirective extends Ast implements IUsingAliasDirective
    {
        private IName _Name;

        public IName getName() { return _Name; }

        public UsingAliasDirective(IToken leftIToken, IToken rightIToken,
                                   IName _Name)
        {
            super(leftIToken, rightIToken);

            this._Name = _Name;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof UsingAliasDirective)) return false;
            UsingAliasDirective other = (UsingAliasDirective    ) o;
            if (! _Name.equals(other.getName())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getName().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 315:  UsingNamespaceDirective ::= using Name ;
     *</b>
     */
    static public class UsingNamespaceDirective extends Ast implements IUsingNamespaceDirective
    {
        private IName _Name;

        public IName getName() { return _Name; }

        public UsingNamespaceDirective(IToken leftIToken, IToken rightIToken,
                                       IName _Name)
        {
            super(leftIToken, rightIToken);

            this._Name = _Name;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof UsingNamespaceDirective)) return false;
            UsingNamespaceDirective other = (UsingNamespaceDirective    ) o;
            if (! _Name.equals(other.getName())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getName().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 318:  NamespaceMemberDeclarations ::= NamespaceMemberDeclaration
     *</em>
     *<p>
     *<b>
     *<li>Rule 319:  NamespaceMemberDeclarations ::= NamespaceMemberDeclarations NamespaceMemberDeclaration
     *</b>
     */
    static public class NamespaceMemberDeclarations extends Ast implements INamespaceMemberDeclarations
    {
        private INamespaceMemberDeclarations _NamespaceMemberDeclarations;
        private INamespaceMemberDeclaration _NamespaceMemberDeclaration;

        public INamespaceMemberDeclarations getNamespaceMemberDeclarations() { return _NamespaceMemberDeclarations; }
        public INamespaceMemberDeclaration getNamespaceMemberDeclaration() { return _NamespaceMemberDeclaration; }

        public NamespaceMemberDeclarations(IToken leftIToken, IToken rightIToken,
                                           INamespaceMemberDeclarations _NamespaceMemberDeclarations,
                                           INamespaceMemberDeclaration _NamespaceMemberDeclaration)
        {
            super(leftIToken, rightIToken);

            this._NamespaceMemberDeclarations = _NamespaceMemberDeclarations;
            this._NamespaceMemberDeclaration = _NamespaceMemberDeclaration;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof NamespaceMemberDeclarations)) return false;
            NamespaceMemberDeclarations other = (NamespaceMemberDeclarations    ) o;
            if (! _NamespaceMemberDeclarations.equals(other.getNamespaceMemberDeclarations())) return false;
            if (! _NamespaceMemberDeclaration.equals(other.getNamespaceMemberDeclaration())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getNamespaceMemberDeclarations().hashCode());
            hash = hash * 31 + (getNamespaceMemberDeclaration().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 329:  Modifiers ::= Modifier
     *</em>
     *<p>
     *<b>
     *<li>Rule 330:  Modifiers ::= Modifiers Modifier
     *</b>
     */
    static public class Modifiers extends Ast implements IModifiers
    {
        private IModifiers _Modifiers;
        private IModifier _Modifier;

        public IModifiers getModifiers() { return _Modifiers; }
        public IModifier getModifier() { return _Modifier; }

        public Modifiers(IToken leftIToken, IToken rightIToken,
                         IModifiers _Modifiers,
                         IModifier _Modifier)
        {
            super(leftIToken, rightIToken);

            this._Modifiers = _Modifiers;
            this._Modifier = _Modifier;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof Modifiers)) return false;
            Modifiers other = (Modifiers    ) o;
            if (! _Modifiers.equals(other.getModifiers())) return false;
            if (! _Modifier.equals(other.getModifier())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getModifiers().hashCode());
            hash = hash * 31 + (getModifier().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 344:  ClassDeclaration ::= AttributesOpt ModifiersOpt PartialOpt class identifier TypeParameterListOpt ClassBaseOpt TypeParameterConstraintsClausesOpt ClassBody SemiOpt
     *</b>
     */
    static public class ClassDeclaration extends Ast implements IClassDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private IModifiersOpt _ModifiersOpt;
        private PartialOpt _PartialOpt;
        private TypeParameterList _TypeParameterListOpt;
        private ClassBaseOpt _ClassBaseOpt;
        private ITypeParameterConstraintsClausesOpt _TypeParameterConstraintsClausesOpt;
        private ClassBody _ClassBody;
        private SemiOpt _SemiOpt;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getModifiersOpt</b> may be <b>null</b>
         */
        public IModifiersOpt getModifiersOpt() { return _ModifiersOpt; }
        /**
         * The value returned by <b>getPartialOpt</b> may be <b>null</b>
         */
        public PartialOpt getPartialOpt() { return _PartialOpt; }
        /**
         * The value returned by <b>getTypeParameterListOpt</b> may be <b>null</b>
         */
        public TypeParameterList getTypeParameterListOpt() { return _TypeParameterListOpt; }
        /**
         * The value returned by <b>getClassBaseOpt</b> may be <b>null</b>
         */
        public ClassBaseOpt getClassBaseOpt() { return _ClassBaseOpt; }
        /**
         * The value returned by <b>getTypeParameterConstraintsClausesOpt</b> may be <b>null</b>
         */
        public ITypeParameterConstraintsClausesOpt getTypeParameterConstraintsClausesOpt() { return _TypeParameterConstraintsClausesOpt; }
        public ClassBody getClassBody() { return _ClassBody; }
        /**
         * The value returned by <b>getSemiOpt</b> may be <b>null</b>
         */
        public SemiOpt getSemiOpt() { return _SemiOpt; }

        public ClassDeclaration(IToken leftIToken, IToken rightIToken,
                                IAttributesOpt _AttributesOpt,
                                IModifiersOpt _ModifiersOpt,
                                PartialOpt _PartialOpt,
                                TypeParameterList _TypeParameterListOpt,
                                ClassBaseOpt _ClassBaseOpt,
                                ITypeParameterConstraintsClausesOpt _TypeParameterConstraintsClausesOpt,
                                ClassBody _ClassBody,
                                SemiOpt _SemiOpt)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ModifiersOpt = _ModifiersOpt;
            this._PartialOpt = _PartialOpt;
            this._TypeParameterListOpt = _TypeParameterListOpt;
            this._ClassBaseOpt = _ClassBaseOpt;
            this._TypeParameterConstraintsClausesOpt = _TypeParameterConstraintsClausesOpt;
            this._ClassBody = _ClassBody;
            this._SemiOpt = _SemiOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ClassDeclaration)) return false;
            ClassDeclaration other = (ClassDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_ModifiersOpt == null && other.getModifiersOpt() != null) return false;
            else if (! _ModifiersOpt.equals(other.getModifiersOpt())) return false;
            if (_PartialOpt == null && other.getPartialOpt() != null) return false;
            else if (! _PartialOpt.equals(other.getPartialOpt())) return false;
            if (_TypeParameterListOpt == null && other.getTypeParameterListOpt() != null) return false;
            else if (! _TypeParameterListOpt.equals(other.getTypeParameterListOpt())) return false;
            if (_ClassBaseOpt == null && other.getClassBaseOpt() != null) return false;
            else if (! _ClassBaseOpt.equals(other.getClassBaseOpt())) return false;
            if (_TypeParameterConstraintsClausesOpt == null && other.getTypeParameterConstraintsClausesOpt() != null) return false;
            else if (! _TypeParameterConstraintsClausesOpt.equals(other.getTypeParameterConstraintsClausesOpt())) return false;
            if (! _ClassBody.equals(other.getClassBody())) return false;
            if (_SemiOpt == null && other.getSemiOpt() != null) return false;
            else if (! _SemiOpt.equals(other.getSemiOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getModifiersOpt() == null ? 0 : getModifiersOpt().hashCode());
            hash = hash * 31 + (getPartialOpt() == null ? 0 : getPartialOpt().hashCode());
            hash = hash * 31 + (getTypeParameterListOpt() == null ? 0 : getTypeParameterListOpt().hashCode());
            hash = hash * 31 + (getClassBaseOpt() == null ? 0 : getClassBaseOpt().hashCode());
            hash = hash * 31 + (getTypeParameterConstraintsClausesOpt() == null ? 0 : getTypeParameterConstraintsClausesOpt().hashCode());
            hash = hash * 31 + (getClassBody().hashCode());
            hash = hash * 31 + (getSemiOpt() == null ? 0 : getSemiOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 345:  ClassBaseOpt ::= $Empty
     *</em>
     *<p>
     *<b>
     *<li>Rule 346:  ClassBaseOpt ::= : ClassBase
     *</b>
     */
    static public class ClassBaseOpt extends Ast implements IClassBaseOpt
    {
        private IClassBase _ClassBase;

        public IClassBase getClassBase() { return _ClassBase; }

        public ClassBaseOpt(IToken leftIToken, IToken rightIToken,
                            IClassBase _ClassBase)
        {
            super(leftIToken, rightIToken);

            this._ClassBase = _ClassBase;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ClassBaseOpt)) return false;
            ClassBaseOpt other = (ClassBaseOpt    ) o;
            if (! _ClassBase.equals(other.getClassBase())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getClassBase().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 347:  ClassBase ::= ClassType
     *</em>
     *<p>
     *<b>
     *<li>Rule 348:  ClassBase ::= ClassBase , ClassType
     *</b>
     */
    static public class ClassBase extends Ast implements IClassBase
    {
        private IClassBase _ClassBase;
        private IClassType _ClassType;

        public IClassBase getClassBase() { return _ClassBase; }
        public IClassType getClassType() { return _ClassType; }

        public ClassBase(IToken leftIToken, IToken rightIToken,
                         IClassBase _ClassBase,
                         IClassType _ClassType)
        {
            super(leftIToken, rightIToken);

            this._ClassBase = _ClassBase;
            this._ClassType = _ClassType;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ClassBase)) return false;
            ClassBase other = (ClassBase    ) o;
            if (! _ClassBase.equals(other.getClassBase())) return false;
            if (! _ClassType.equals(other.getClassType())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getClassBase().hashCode());
            hash = hash * 31 + (getClassType().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 349:  ClassBody ::= { ClassMemberDeclarationsOpt }
     *</b>
     */
    static public class ClassBody extends Ast implements IClassBody
    {
        private IClassMemberDeclarationsOpt _ClassMemberDeclarationsOpt;

        /**
         * The value returned by <b>getClassMemberDeclarationsOpt</b> may be <b>null</b>
         */
        public IClassMemberDeclarationsOpt getClassMemberDeclarationsOpt() { return _ClassMemberDeclarationsOpt; }

        public ClassBody(IToken leftIToken, IToken rightIToken,
                         IClassMemberDeclarationsOpt _ClassMemberDeclarationsOpt)
        {
            super(leftIToken, rightIToken);

            this._ClassMemberDeclarationsOpt = _ClassMemberDeclarationsOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ClassBody)) return false;
            ClassBody other = (ClassBody    ) o;
            if (_ClassMemberDeclarationsOpt == null && other.getClassMemberDeclarationsOpt() != null) return false;
            else if (! _ClassMemberDeclarationsOpt.equals(other.getClassMemberDeclarationsOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getClassMemberDeclarationsOpt() == null ? 0 : getClassMemberDeclarationsOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 352:  ClassMemberDeclarations ::= ClassMemberDeclaration
     *</em>
     *<p>
     *<b>
     *<li>Rule 353:  ClassMemberDeclarations ::= ClassMemberDeclarations ClassMemberDeclaration
     *</b>
     */
    static public class ClassMemberDeclarations extends Ast implements IClassMemberDeclarations
    {
        private IClassMemberDeclarations _ClassMemberDeclarations;
        private IClassMemberDeclaration _ClassMemberDeclaration;

        public IClassMemberDeclarations getClassMemberDeclarations() { return _ClassMemberDeclarations; }
        public IClassMemberDeclaration getClassMemberDeclaration() { return _ClassMemberDeclaration; }

        public ClassMemberDeclarations(IToken leftIToken, IToken rightIToken,
                                       IClassMemberDeclarations _ClassMemberDeclarations,
                                       IClassMemberDeclaration _ClassMemberDeclaration)
        {
            super(leftIToken, rightIToken);

            this._ClassMemberDeclarations = _ClassMemberDeclarations;
            this._ClassMemberDeclaration = _ClassMemberDeclaration;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ClassMemberDeclarations)) return false;
            ClassMemberDeclarations other = (ClassMemberDeclarations    ) o;
            if (! _ClassMemberDeclarations.equals(other.getClassMemberDeclarations())) return false;
            if (! _ClassMemberDeclaration.equals(other.getClassMemberDeclaration())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getClassMemberDeclarations().hashCode());
            hash = hash * 31 + (getClassMemberDeclaration().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 364:  ConstantDeclaration ::= AttributesOpt ModifiersOpt const Type ConstantDeclarators ;
     *</b>
     */
    static public class ConstantDeclaration extends Ast implements IConstantDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private IModifiersOpt _ModifiersOpt;
        private IType _Type;
        private IConstantDeclarators _ConstantDeclarators;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getModifiersOpt</b> may be <b>null</b>
         */
        public IModifiersOpt getModifiersOpt() { return _ModifiersOpt; }
        public IType getType() { return _Type; }
        public IConstantDeclarators getConstantDeclarators() { return _ConstantDeclarators; }

        public ConstantDeclaration(IToken leftIToken, IToken rightIToken,
                                   IAttributesOpt _AttributesOpt,
                                   IModifiersOpt _ModifiersOpt,
                                   IType _Type,
                                   IConstantDeclarators _ConstantDeclarators)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ModifiersOpt = _ModifiersOpt;
            this._Type = _Type;
            this._ConstantDeclarators = _ConstantDeclarators;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ConstantDeclaration)) return false;
            ConstantDeclaration other = (ConstantDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_ModifiersOpt == null && other.getModifiersOpt() != null) return false;
            else if (! _ModifiersOpt.equals(other.getModifiersOpt())) return false;
            if (! _Type.equals(other.getType())) return false;
            if (! _ConstantDeclarators.equals(other.getConstantDeclarators())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getModifiersOpt() == null ? 0 : getModifiersOpt().hashCode());
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getConstantDeclarators().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 365:  ConstantDeclarators ::= ConstantDeclarator
     *</em>
     *<p>
     *<b>
     *<li>Rule 366:  ConstantDeclarators ::= ConstantDeclarators , ConstantDeclarator
     *</b>
     */
    static public class ConstantDeclarators extends Ast implements IConstantDeclarators
    {
        private IConstantDeclarators _ConstantDeclarators;
        private ConstantDeclarator _ConstantDeclarator;

        public IConstantDeclarators getConstantDeclarators() { return _ConstantDeclarators; }
        public ConstantDeclarator getConstantDeclarator() { return _ConstantDeclarator; }

        public ConstantDeclarators(IToken leftIToken, IToken rightIToken,
                                   IConstantDeclarators _ConstantDeclarators,
                                   ConstantDeclarator _ConstantDeclarator)
        {
            super(leftIToken, rightIToken);

            this._ConstantDeclarators = _ConstantDeclarators;
            this._ConstantDeclarator = _ConstantDeclarator;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ConstantDeclarators)) return false;
            ConstantDeclarators other = (ConstantDeclarators    ) o;
            if (! _ConstantDeclarators.equals(other.getConstantDeclarators())) return false;
            if (! _ConstantDeclarator.equals(other.getConstantDeclarator())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getConstantDeclarators().hashCode());
            hash = hash * 31 + (getConstantDeclarator().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 367:  ConstantDeclarator ::= identifier = ConstantExpression
     *</b>
     */
    static public class ConstantDeclarator extends Ast implements IConstantDeclarator
    {
        private IConstantExpression _ConstantExpression;

        public IConstantExpression getConstantExpression() { return _ConstantExpression; }

        public ConstantDeclarator(IToken leftIToken, IToken rightIToken,
                                  IConstantExpression _ConstantExpression)
        {
            super(leftIToken, rightIToken);

            this._ConstantExpression = _ConstantExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ConstantDeclarator)) return false;
            ConstantDeclarator other = (ConstantDeclarator    ) o;
            if (! _ConstantExpression.equals(other.getConstantExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getConstantExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 368:  FieldDeclaration ::= AttributesOpt ModifiersOpt Type VariableDeclarators ;
     *</b>
     */
    static public class FieldDeclaration extends Ast implements IFieldDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private IModifiersOpt _ModifiersOpt;
        private IType _Type;
        private IVariableDeclarators _VariableDeclarators;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getModifiersOpt</b> may be <b>null</b>
         */
        public IModifiersOpt getModifiersOpt() { return _ModifiersOpt; }
        public IType getType() { return _Type; }
        public IVariableDeclarators getVariableDeclarators() { return _VariableDeclarators; }

        public FieldDeclaration(IToken leftIToken, IToken rightIToken,
                                IAttributesOpt _AttributesOpt,
                                IModifiersOpt _ModifiersOpt,
                                IType _Type,
                                IVariableDeclarators _VariableDeclarators)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ModifiersOpt = _ModifiersOpt;
            this._Type = _Type;
            this._VariableDeclarators = _VariableDeclarators;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof FieldDeclaration)) return false;
            FieldDeclaration other = (FieldDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_ModifiersOpt == null && other.getModifiersOpt() != null) return false;
            else if (! _ModifiersOpt.equals(other.getModifiersOpt())) return false;
            if (! _Type.equals(other.getType())) return false;
            if (! _VariableDeclarators.equals(other.getVariableDeclarators())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getModifiersOpt() == null ? 0 : getModifiersOpt().hashCode());
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getVariableDeclarators().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 369:  VariableDeclarators ::= VariableDeclarator
     *</em>
     *<p>
     *<b>
     *<li>Rule 370:  VariableDeclarators ::= VariableDeclarators , VariableDeclarator
     *</b>
     */
    static public class VariableDeclarators extends Ast implements IVariableDeclarators
    {
        private IVariableDeclarators _VariableDeclarators;
        private IVariableDeclarator _VariableDeclarator;

        public IVariableDeclarators getVariableDeclarators() { return _VariableDeclarators; }
        public IVariableDeclarator getVariableDeclarator() { return _VariableDeclarator; }

        public VariableDeclarators(IToken leftIToken, IToken rightIToken,
                                   IVariableDeclarators _VariableDeclarators,
                                   IVariableDeclarator _VariableDeclarator)
        {
            super(leftIToken, rightIToken);

            this._VariableDeclarators = _VariableDeclarators;
            this._VariableDeclarator = _VariableDeclarator;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof VariableDeclarators)) return false;
            VariableDeclarators other = (VariableDeclarators    ) o;
            if (! _VariableDeclarators.equals(other.getVariableDeclarators())) return false;
            if (! _VariableDeclarator.equals(other.getVariableDeclarator())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getVariableDeclarators().hashCode());
            hash = hash * 31 + (getVariableDeclarator().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 375:  MethodDeclaration ::= MethodHeader MethodBody
     *</b>
     */
    static public class MethodDeclaration extends Ast implements IMethodDeclaration
    {
        private MethodHeader _MethodHeader;
        private IMethodBody _MethodBody;

        public MethodHeader getMethodHeader() { return _MethodHeader; }
        public IMethodBody getMethodBody() { return _MethodBody; }

        public MethodDeclaration(IToken leftIToken, IToken rightIToken,
                                 MethodHeader _MethodHeader,
                                 IMethodBody _MethodBody)
        {
            super(leftIToken, rightIToken);

            this._MethodHeader = _MethodHeader;
            this._MethodBody = _MethodBody;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof MethodDeclaration)) return false;
            MethodDeclaration other = (MethodDeclaration    ) o;
            if (! _MethodHeader.equals(other.getMethodHeader())) return false;
            if (! _MethodBody.equals(other.getMethodBody())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getMethodHeader().hashCode());
            hash = hash * 31 + (getMethodBody().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 376:  MethodHeader ::= AttributesOpt ModifiersOpt Type Name TypeParameterListOpt ( FormalParameterListOpt ) TypeParameterConstraintsClausesOpt
     *</b>
     */
    static public class MethodHeader extends Ast implements IMethodHeader
    {
        private IAttributesOpt _AttributesOpt;
        private IModifiersOpt _ModifiersOpt;
        private IType _Type;
        private IName _Name;
        private TypeParameterList _TypeParameterListOpt;
        private IFormalParameterListOpt _FormalParameterListOpt;
        private ITypeParameterConstraintsClausesOpt _TypeParameterConstraintsClausesOpt;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getModifiersOpt</b> may be <b>null</b>
         */
        public IModifiersOpt getModifiersOpt() { return _ModifiersOpt; }
        public IType getType() { return _Type; }
        public IName getName() { return _Name; }
        /**
         * The value returned by <b>getTypeParameterListOpt</b> may be <b>null</b>
         */
        public TypeParameterList getTypeParameterListOpt() { return _TypeParameterListOpt; }
        /**
         * The value returned by <b>getFormalParameterListOpt</b> may be <b>null</b>
         */
        public IFormalParameterListOpt getFormalParameterListOpt() { return _FormalParameterListOpt; }
        /**
         * The value returned by <b>getTypeParameterConstraintsClausesOpt</b> may be <b>null</b>
         */
        public ITypeParameterConstraintsClausesOpt getTypeParameterConstraintsClausesOpt() { return _TypeParameterConstraintsClausesOpt; }

        public MethodHeader(IToken leftIToken, IToken rightIToken,
                            IAttributesOpt _AttributesOpt,
                            IModifiersOpt _ModifiersOpt,
                            IType _Type,
                            IName _Name,
                            TypeParameterList _TypeParameterListOpt,
                            IFormalParameterListOpt _FormalParameterListOpt,
                            ITypeParameterConstraintsClausesOpt _TypeParameterConstraintsClausesOpt)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ModifiersOpt = _ModifiersOpt;
            this._Type = _Type;
            this._Name = _Name;
            this._TypeParameterListOpt = _TypeParameterListOpt;
            this._FormalParameterListOpt = _FormalParameterListOpt;
            this._TypeParameterConstraintsClausesOpt = _TypeParameterConstraintsClausesOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof MethodHeader)) return false;
            MethodHeader other = (MethodHeader    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_ModifiersOpt == null && other.getModifiersOpt() != null) return false;
            else if (! _ModifiersOpt.equals(other.getModifiersOpt())) return false;
            if (! _Type.equals(other.getType())) return false;
            if (! _Name.equals(other.getName())) return false;
            if (_TypeParameterListOpt == null && other.getTypeParameterListOpt() != null) return false;
            else if (! _TypeParameterListOpt.equals(other.getTypeParameterListOpt())) return false;
            if (_FormalParameterListOpt == null && other.getFormalParameterListOpt() != null) return false;
            else if (! _FormalParameterListOpt.equals(other.getFormalParameterListOpt())) return false;
            if (_TypeParameterConstraintsClausesOpt == null && other.getTypeParameterConstraintsClausesOpt() != null) return false;
            else if (! _TypeParameterConstraintsClausesOpt.equals(other.getTypeParameterConstraintsClausesOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getModifiersOpt() == null ? 0 : getModifiersOpt().hashCode());
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getName().hashCode());
            hash = hash * 31 + (getTypeParameterListOpt() == null ? 0 : getTypeParameterListOpt().hashCode());
            hash = hash * 31 + (getFormalParameterListOpt() == null ? 0 : getFormalParameterListOpt().hashCode());
            hash = hash * 31 + (getTypeParameterConstraintsClausesOpt() == null ? 0 : getTypeParameterConstraintsClausesOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 377:  MethodBody ::= Block
     *</em>
     *<p>
     *<b>
     *<li>Rule 378:  MethodBody ::= ;
     *</b>
     */
    static public class MethodBody extends AstToken implements IMethodBody
    {
        public MethodBody(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 381:  FormalParameterList ::= FixedParameters
     *<li>Rule 383:  FormalParameterList ::= ParameterArray
     *</em>
     *<p>
     *<b>
     *<li>Rule 382:  FormalParameterList ::= FixedParameters , ParameterArray
     *</b>
     */
    static public class FormalParameterList extends Ast implements IFormalParameterList
    {
        private IFixedParameters _FixedParameters;
        private ParameterArray _ParameterArray;

        public IFixedParameters getFixedParameters() { return _FixedParameters; }
        public ParameterArray getParameterArray() { return _ParameterArray; }

        public FormalParameterList(IToken leftIToken, IToken rightIToken,
                                   IFixedParameters _FixedParameters,
                                   ParameterArray _ParameterArray)
        {
            super(leftIToken, rightIToken);

            this._FixedParameters = _FixedParameters;
            this._ParameterArray = _ParameterArray;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof FormalParameterList)) return false;
            FormalParameterList other = (FormalParameterList    ) o;
            if (! _FixedParameters.equals(other.getFixedParameters())) return false;
            if (! _ParameterArray.equals(other.getParameterArray())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getFixedParameters().hashCode());
            hash = hash * 31 + (getParameterArray().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 384:  FixedParameters ::= FixedParameter
     *</em>
     *<p>
     *<b>
     *<li>Rule 385:  FixedParameters ::= FixedParameters FixedParameter
     *</b>
     */
    static public class FixedParameters extends Ast implements IFixedParameters
    {
        private IFixedParameters _FixedParameters;
        private FixedParameter _FixedParameter;

        public IFixedParameters getFixedParameters() { return _FixedParameters; }
        public FixedParameter getFixedParameter() { return _FixedParameter; }

        public FixedParameters(IToken leftIToken, IToken rightIToken,
                               IFixedParameters _FixedParameters,
                               FixedParameter _FixedParameter)
        {
            super(leftIToken, rightIToken);

            this._FixedParameters = _FixedParameters;
            this._FixedParameter = _FixedParameter;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof FixedParameters)) return false;
            FixedParameters other = (FixedParameters    ) o;
            if (! _FixedParameters.equals(other.getFixedParameters())) return false;
            if (! _FixedParameter.equals(other.getFixedParameter())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getFixedParameters().hashCode());
            hash = hash * 31 + (getFixedParameter().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 386:  FixedParameter ::= AttributesOpt ParameterModifierOpt Type identifier
     *</b>
     */
    static public class FixedParameter extends Ast implements IFixedParameter
    {
        private IAttributesOpt _AttributesOpt;
        private IParameterModifierOpt _ParameterModifierOpt;
        private IType _Type;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getParameterModifierOpt</b> may be <b>null</b>
         */
        public IParameterModifierOpt getParameterModifierOpt() { return _ParameterModifierOpt; }
        public IType getType() { return _Type; }

        public FixedParameter(IToken leftIToken, IToken rightIToken,
                              IAttributesOpt _AttributesOpt,
                              IParameterModifierOpt _ParameterModifierOpt,
                              IType _Type)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ParameterModifierOpt = _ParameterModifierOpt;
            this._Type = _Type;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof FixedParameter)) return false;
            FixedParameter other = (FixedParameter    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_ParameterModifierOpt == null && other.getParameterModifierOpt() != null) return false;
            else if (! _ParameterModifierOpt.equals(other.getParameterModifierOpt())) return false;
            if (! _Type.equals(other.getType())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getParameterModifierOpt() == null ? 0 : getParameterModifierOpt().hashCode());
            hash = hash * 31 + (getType().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 391:  ParameterArray ::= AttributesOpt params ArrayType identifier
     *</b>
     */
    static public class ParameterArray extends Ast implements IParameterArray
    {
        private IAttributesOpt _AttributesOpt;
        private ArrayType _ArrayType;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        public ArrayType getArrayType() { return _ArrayType; }

        public ParameterArray(IToken leftIToken, IToken rightIToken,
                              IAttributesOpt _AttributesOpt,
                              ArrayType _ArrayType)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ArrayType = _ArrayType;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ParameterArray)) return false;
            ParameterArray other = (ParameterArray    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (! _ArrayType.equals(other.getArrayType())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getArrayType().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 392:  PropertyDeclaration ::= AttributesOpt ModifiersOpt Type Name { AccessorDeclarations }
     *</b>
     */
    static public class PropertyDeclaration extends Ast implements IPropertyDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private IModifiersOpt _ModifiersOpt;
        private IType _Type;
        private IName _Name;
        private IAccessorDeclarations _AccessorDeclarations;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getModifiersOpt</b> may be <b>null</b>
         */
        public IModifiersOpt getModifiersOpt() { return _ModifiersOpt; }
        public IType getType() { return _Type; }
        public IName getName() { return _Name; }
        public IAccessorDeclarations getAccessorDeclarations() { return _AccessorDeclarations; }

        public PropertyDeclaration(IToken leftIToken, IToken rightIToken,
                                   IAttributesOpt _AttributesOpt,
                                   IModifiersOpt _ModifiersOpt,
                                   IType _Type,
                                   IName _Name,
                                   IAccessorDeclarations _AccessorDeclarations)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ModifiersOpt = _ModifiersOpt;
            this._Type = _Type;
            this._Name = _Name;
            this._AccessorDeclarations = _AccessorDeclarations;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof PropertyDeclaration)) return false;
            PropertyDeclaration other = (PropertyDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_ModifiersOpt == null && other.getModifiersOpt() != null) return false;
            else if (! _ModifiersOpt.equals(other.getModifiersOpt())) return false;
            if (! _Type.equals(other.getType())) return false;
            if (! _Name.equals(other.getName())) return false;
            if (! _AccessorDeclarations.equals(other.getAccessorDeclarations())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getModifiersOpt() == null ? 0 : getModifiersOpt().hashCode());
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getName().hashCode());
            hash = hash * 31 + (getAccessorDeclarations().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 397:  GetAccessorDeclaration ::= AttributesOpt AccessorModifierOpt get AccessorBody
     *</b>
     */
    static public class GetAccessorDeclaration extends Ast implements IGetAccessorDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private IAccessorModifierOpt _AccessorModifierOpt;
        private IAccessorBody _AccessorBody;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getAccessorModifierOpt</b> may be <b>null</b>
         */
        public IAccessorModifierOpt getAccessorModifierOpt() { return _AccessorModifierOpt; }
        public IAccessorBody getAccessorBody() { return _AccessorBody; }

        public GetAccessorDeclaration(IToken leftIToken, IToken rightIToken,
                                      IAttributesOpt _AttributesOpt,
                                      IAccessorModifierOpt _AccessorModifierOpt,
                                      IAccessorBody _AccessorBody)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._AccessorModifierOpt = _AccessorModifierOpt;
            this._AccessorBody = _AccessorBody;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof GetAccessorDeclaration)) return false;
            GetAccessorDeclaration other = (GetAccessorDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_AccessorModifierOpt == null && other.getAccessorModifierOpt() != null) return false;
            else if (! _AccessorModifierOpt.equals(other.getAccessorModifierOpt())) return false;
            if (! _AccessorBody.equals(other.getAccessorBody())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getAccessorModifierOpt() == null ? 0 : getAccessorModifierOpt().hashCode());
            hash = hash * 31 + (getAccessorBody().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 400:  SetAccessorDeclaration ::= AttributesOpt AccessorModifierOpt set AccessorBody
     *</b>
     */
    static public class SetAccessorDeclaration extends Ast implements ISetAccessorDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private IAccessorModifierOpt _AccessorModifierOpt;
        private IAccessorBody _AccessorBody;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getAccessorModifierOpt</b> may be <b>null</b>
         */
        public IAccessorModifierOpt getAccessorModifierOpt() { return _AccessorModifierOpt; }
        public IAccessorBody getAccessorBody() { return _AccessorBody; }

        public SetAccessorDeclaration(IToken leftIToken, IToken rightIToken,
                                      IAttributesOpt _AttributesOpt,
                                      IAccessorModifierOpt _AccessorModifierOpt,
                                      IAccessorBody _AccessorBody)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._AccessorModifierOpt = _AccessorModifierOpt;
            this._AccessorBody = _AccessorBody;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof SetAccessorDeclaration)) return false;
            SetAccessorDeclaration other = (SetAccessorDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_AccessorModifierOpt == null && other.getAccessorModifierOpt() != null) return false;
            else if (! _AccessorModifierOpt.equals(other.getAccessorModifierOpt())) return false;
            if (! _AccessorBody.equals(other.getAccessorBody())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getAccessorModifierOpt() == null ? 0 : getAccessorModifierOpt().hashCode());
            hash = hash * 31 + (getAccessorBody().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 408:  AccessorBody ::= Block
     *</em>
     *<p>
     *<b>
     *<li>Rule 409:  AccessorBody ::= ;
     *</b>
     */
    static public class AccessorBody extends AstToken implements IAccessorBody
    {
        public AccessorBody(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 414:  AddAccessorDeclaration ::= AttributesOpt add Block
     *</b>
     */
    static public class AddAccessorDeclaration extends Ast implements IAddAccessorDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private Block _Block;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        public Block getBlock() { return _Block; }

        public AddAccessorDeclaration(IToken leftIToken, IToken rightIToken,
                                      IAttributesOpt _AttributesOpt,
                                      Block _Block)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._Block = _Block;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AddAccessorDeclaration)) return false;
            AddAccessorDeclaration other = (AddAccessorDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (! _Block.equals(other.getBlock())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getBlock().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 415:  RemoveAccessorDeclaration ::= AttributesOpt remove Block
     *</b>
     */
    static public class RemoveAccessorDeclaration extends Ast implements IRemoveAccessorDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private Block _Block;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        public Block getBlock() { return _Block; }

        public RemoveAccessorDeclaration(IToken leftIToken, IToken rightIToken,
                                         IAttributesOpt _AttributesOpt,
                                         Block _Block)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._Block = _Block;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof RemoveAccessorDeclaration)) return false;
            RemoveAccessorDeclaration other = (RemoveAccessorDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (! _Block.equals(other.getBlock())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getBlock().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 416:  IndexerDeclaration ::= AttributesOpt ModifiersOpt IndexerDeclarator { AccessorDeclarations }
     *</b>
     */
    static public class IndexerDeclaration extends Ast implements IIndexerDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private IModifiersOpt _ModifiersOpt;
        private IIndexerDeclarator _IndexerDeclarator;
        private IAccessorDeclarations _AccessorDeclarations;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getModifiersOpt</b> may be <b>null</b>
         */
        public IModifiersOpt getModifiersOpt() { return _ModifiersOpt; }
        public IIndexerDeclarator getIndexerDeclarator() { return _IndexerDeclarator; }
        public IAccessorDeclarations getAccessorDeclarations() { return _AccessorDeclarations; }

        public IndexerDeclaration(IToken leftIToken, IToken rightIToken,
                                  IAttributesOpt _AttributesOpt,
                                  IModifiersOpt _ModifiersOpt,
                                  IIndexerDeclarator _IndexerDeclarator,
                                  IAccessorDeclarations _AccessorDeclarations)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ModifiersOpt = _ModifiersOpt;
            this._IndexerDeclarator = _IndexerDeclarator;
            this._AccessorDeclarations = _AccessorDeclarations;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof IndexerDeclaration)) return false;
            IndexerDeclaration other = (IndexerDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_ModifiersOpt == null && other.getModifiersOpt() != null) return false;
            else if (! _ModifiersOpt.equals(other.getModifiersOpt())) return false;
            if (! _IndexerDeclarator.equals(other.getIndexerDeclarator())) return false;
            if (! _AccessorDeclarations.equals(other.getAccessorDeclarations())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getModifiersOpt() == null ? 0 : getModifiersOpt().hashCode());
            hash = hash * 31 + (getIndexerDeclarator().hashCode());
            hash = hash * 31 + (getAccessorDeclarations().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 419:  OperatorDeclaration ::= AttributesOpt ModifiersOpt OperatorDeclarator OperatorBody
     *</b>
     */
    static public class OperatorDeclaration extends Ast implements IOperatorDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private IModifiersOpt _ModifiersOpt;
        private IOperatorDeclarator _OperatorDeclarator;
        private IOperatorBody _OperatorBody;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getModifiersOpt</b> may be <b>null</b>
         */
        public IModifiersOpt getModifiersOpt() { return _ModifiersOpt; }
        public IOperatorDeclarator getOperatorDeclarator() { return _OperatorDeclarator; }
        public IOperatorBody getOperatorBody() { return _OperatorBody; }

        public OperatorDeclaration(IToken leftIToken, IToken rightIToken,
                                   IAttributesOpt _AttributesOpt,
                                   IModifiersOpt _ModifiersOpt,
                                   IOperatorDeclarator _OperatorDeclarator,
                                   IOperatorBody _OperatorBody)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ModifiersOpt = _ModifiersOpt;
            this._OperatorDeclarator = _OperatorDeclarator;
            this._OperatorBody = _OperatorBody;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof OperatorDeclaration)) return false;
            OperatorDeclaration other = (OperatorDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_ModifiersOpt == null && other.getModifiersOpt() != null) return false;
            else if (! _ModifiersOpt.equals(other.getModifiersOpt())) return false;
            if (! _OperatorDeclarator.equals(other.getOperatorDeclarator())) return false;
            if (! _OperatorBody.equals(other.getOperatorBody())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getModifiersOpt() == null ? 0 : getModifiersOpt().hashCode());
            hash = hash * 31 + (getOperatorDeclarator().hashCode());
            hash = hash * 31 + (getOperatorBody().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 422:  SymbolOperatorDeclarator ::= Type operator OverloadableOperator ( FormalParameterList )
     *</b>
     */
    static public class SymbolOperatorDeclarator extends Ast implements ISymbolOperatorDeclarator
    {
        private IType _Type;
        private IOverloadableOperator _OverloadableOperator;
        private IFormalParameterList _FormalParameterList;

        public IType getType() { return _Type; }
        public IOverloadableOperator getOverloadableOperator() { return _OverloadableOperator; }
        public IFormalParameterList getFormalParameterList() { return _FormalParameterList; }

        public SymbolOperatorDeclarator(IToken leftIToken, IToken rightIToken,
                                        IType _Type,
                                        IOverloadableOperator _OverloadableOperator,
                                        IFormalParameterList _FormalParameterList)
        {
            super(leftIToken, rightIToken);

            this._Type = _Type;
            this._OverloadableOperator = _OverloadableOperator;
            this._FormalParameterList = _FormalParameterList;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof SymbolOperatorDeclarator)) return false;
            SymbolOperatorDeclarator other = (SymbolOperatorDeclarator    ) o;
            if (! _Type.equals(other.getType())) return false;
            if (! _OverloadableOperator.equals(other.getOverloadableOperator())) return false;
            if (! _FormalParameterList.equals(other.getFormalParameterList())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getOverloadableOperator().hashCode());
            hash = hash * 31 + (getFormalParameterList().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 447:  OperatorBody ::= Block
     *</em>
     *<p>
     *<b>
     *<li>Rule 448:  OperatorBody ::= ;
     *</b>
     */
    static public class OperatorBody extends AstToken implements IOperatorBody
    {
        public OperatorBody(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 449:  ConstructorDeclaration ::= AttributesOpt ModifiersOpt ConstructorDeclarator ConstructorBody
     *</b>
     */
    static public class ConstructorDeclaration extends Ast implements IConstructorDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private IModifiersOpt _ModifiersOpt;
        private ConstructorDeclarator _ConstructorDeclarator;
        private IConstructorBody _ConstructorBody;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getModifiersOpt</b> may be <b>null</b>
         */
        public IModifiersOpt getModifiersOpt() { return _ModifiersOpt; }
        public ConstructorDeclarator getConstructorDeclarator() { return _ConstructorDeclarator; }
        public IConstructorBody getConstructorBody() { return _ConstructorBody; }

        public ConstructorDeclaration(IToken leftIToken, IToken rightIToken,
                                      IAttributesOpt _AttributesOpt,
                                      IModifiersOpt _ModifiersOpt,
                                      ConstructorDeclarator _ConstructorDeclarator,
                                      IConstructorBody _ConstructorBody)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ModifiersOpt = _ModifiersOpt;
            this._ConstructorDeclarator = _ConstructorDeclarator;
            this._ConstructorBody = _ConstructorBody;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ConstructorDeclaration)) return false;
            ConstructorDeclaration other = (ConstructorDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_ModifiersOpt == null && other.getModifiersOpt() != null) return false;
            else if (! _ModifiersOpt.equals(other.getModifiersOpt())) return false;
            if (! _ConstructorDeclarator.equals(other.getConstructorDeclarator())) return false;
            if (! _ConstructorBody.equals(other.getConstructorBody())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getModifiersOpt() == null ? 0 : getModifiersOpt().hashCode());
            hash = hash * 31 + (getConstructorDeclarator().hashCode());
            hash = hash * 31 + (getConstructorBody().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 450:  ConstructorDeclarator ::= identifier ( FormalParameterListOpt ) ConstructorInitializerOpt
     *</b>
     */
    static public class ConstructorDeclarator extends Ast implements IConstructorDeclarator
    {
        private IFormalParameterListOpt _FormalParameterListOpt;
        private IConstructorInitializerOpt _ConstructorInitializerOpt;

        /**
         * The value returned by <b>getFormalParameterListOpt</b> may be <b>null</b>
         */
        public IFormalParameterListOpt getFormalParameterListOpt() { return _FormalParameterListOpt; }
        /**
         * The value returned by <b>getConstructorInitializerOpt</b> may be <b>null</b>
         */
        public IConstructorInitializerOpt getConstructorInitializerOpt() { return _ConstructorInitializerOpt; }

        public ConstructorDeclarator(IToken leftIToken, IToken rightIToken,
                                     IFormalParameterListOpt _FormalParameterListOpt,
                                     IConstructorInitializerOpt _ConstructorInitializerOpt)
        {
            super(leftIToken, rightIToken);

            this._FormalParameterListOpt = _FormalParameterListOpt;
            this._ConstructorInitializerOpt = _ConstructorInitializerOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ConstructorDeclarator)) return false;
            ConstructorDeclarator other = (ConstructorDeclarator    ) o;
            if (_FormalParameterListOpt == null && other.getFormalParameterListOpt() != null) return false;
            else if (! _FormalParameterListOpt.equals(other.getFormalParameterListOpt())) return false;
            if (_ConstructorInitializerOpt == null && other.getConstructorInitializerOpt() != null) return false;
            else if (! _ConstructorInitializerOpt.equals(other.getConstructorInitializerOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getFormalParameterListOpt() == null ? 0 : getFormalParameterListOpt().hashCode());
            hash = hash * 31 + (getConstructorInitializerOpt() == null ? 0 : getConstructorInitializerOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 455:  ConstructorBody ::= Block
     *</em>
     *<p>
     *<b>
     *<li>Rule 456:  ConstructorBody ::= ;
     *</b>
     */
    static public class ConstructorBody extends AstToken implements IConstructorBody
    {
        public ConstructorBody(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 457:  FinalizerDeclaration ::= AttributesOpt ExternOpt ~ identifier ( ) FinalizerBody
     *</b>
     */
    static public class FinalizerDeclaration extends Ast implements IFinalizerDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private ExternOpt _ExternOpt;
        private IFinalizerBody _FinalizerBody;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getExternOpt</b> may be <b>null</b>
         */
        public ExternOpt getExternOpt() { return _ExternOpt; }
        public IFinalizerBody getFinalizerBody() { return _FinalizerBody; }

        public FinalizerDeclaration(IToken leftIToken, IToken rightIToken,
                                    IAttributesOpt _AttributesOpt,
                                    ExternOpt _ExternOpt,
                                    IFinalizerBody _FinalizerBody)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ExternOpt = _ExternOpt;
            this._FinalizerBody = _FinalizerBody;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof FinalizerDeclaration)) return false;
            FinalizerDeclaration other = (FinalizerDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_ExternOpt == null && other.getExternOpt() != null) return false;
            else if (! _ExternOpt.equals(other.getExternOpt())) return false;
            if (! _FinalizerBody.equals(other.getFinalizerBody())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getExternOpt() == null ? 0 : getExternOpt().hashCode());
            hash = hash * 31 + (getFinalizerBody().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 458:  FinalizerBody ::= Block
     *</em>
     *<p>
     *<b>
     *<li>Rule 459:  FinalizerBody ::= ;
     *</b>
     */
    static public class FinalizerBody extends AstToken implements IFinalizerBody
    {
        public FinalizerBody(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 460:  StructDeclaration ::= AttributesOpt ModifiersOpt PartialOpt struct identifier TypeParameterListOpt StructInterfacesOpt TypeParameterConstraintsClausesOpt StructBody SemiOpt
     *</b>
     */
    static public class StructDeclaration extends Ast implements IStructDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private IModifiersOpt _ModifiersOpt;
        private PartialOpt _PartialOpt;
        private TypeParameterList _TypeParameterListOpt;
        private StructInterfacesOpt _StructInterfacesOpt;
        private ITypeParameterConstraintsClausesOpt _TypeParameterConstraintsClausesOpt;
        private StructBody _StructBody;
        private SemiOpt _SemiOpt;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getModifiersOpt</b> may be <b>null</b>
         */
        public IModifiersOpt getModifiersOpt() { return _ModifiersOpt; }
        /**
         * The value returned by <b>getPartialOpt</b> may be <b>null</b>
         */
        public PartialOpt getPartialOpt() { return _PartialOpt; }
        /**
         * The value returned by <b>getTypeParameterListOpt</b> may be <b>null</b>
         */
        public TypeParameterList getTypeParameterListOpt() { return _TypeParameterListOpt; }
        /**
         * The value returned by <b>getStructInterfacesOpt</b> may be <b>null</b>
         */
        public StructInterfacesOpt getStructInterfacesOpt() { return _StructInterfacesOpt; }
        /**
         * The value returned by <b>getTypeParameterConstraintsClausesOpt</b> may be <b>null</b>
         */
        public ITypeParameterConstraintsClausesOpt getTypeParameterConstraintsClausesOpt() { return _TypeParameterConstraintsClausesOpt; }
        public StructBody getStructBody() { return _StructBody; }
        /**
         * The value returned by <b>getSemiOpt</b> may be <b>null</b>
         */
        public SemiOpt getSemiOpt() { return _SemiOpt; }

        public StructDeclaration(IToken leftIToken, IToken rightIToken,
                                 IAttributesOpt _AttributesOpt,
                                 IModifiersOpt _ModifiersOpt,
                                 PartialOpt _PartialOpt,
                                 TypeParameterList _TypeParameterListOpt,
                                 StructInterfacesOpt _StructInterfacesOpt,
                                 ITypeParameterConstraintsClausesOpt _TypeParameterConstraintsClausesOpt,
                                 StructBody _StructBody,
                                 SemiOpt _SemiOpt)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ModifiersOpt = _ModifiersOpt;
            this._PartialOpt = _PartialOpt;
            this._TypeParameterListOpt = _TypeParameterListOpt;
            this._StructInterfacesOpt = _StructInterfacesOpt;
            this._TypeParameterConstraintsClausesOpt = _TypeParameterConstraintsClausesOpt;
            this._StructBody = _StructBody;
            this._SemiOpt = _SemiOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof StructDeclaration)) return false;
            StructDeclaration other = (StructDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_ModifiersOpt == null && other.getModifiersOpt() != null) return false;
            else if (! _ModifiersOpt.equals(other.getModifiersOpt())) return false;
            if (_PartialOpt == null && other.getPartialOpt() != null) return false;
            else if (! _PartialOpt.equals(other.getPartialOpt())) return false;
            if (_TypeParameterListOpt == null && other.getTypeParameterListOpt() != null) return false;
            else if (! _TypeParameterListOpt.equals(other.getTypeParameterListOpt())) return false;
            if (_StructInterfacesOpt == null && other.getStructInterfacesOpt() != null) return false;
            else if (! _StructInterfacesOpt.equals(other.getStructInterfacesOpt())) return false;
            if (_TypeParameterConstraintsClausesOpt == null && other.getTypeParameterConstraintsClausesOpt() != null) return false;
            else if (! _TypeParameterConstraintsClausesOpt.equals(other.getTypeParameterConstraintsClausesOpt())) return false;
            if (! _StructBody.equals(other.getStructBody())) return false;
            if (_SemiOpt == null && other.getSemiOpt() != null) return false;
            else if (! _SemiOpt.equals(other.getSemiOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getModifiersOpt() == null ? 0 : getModifiersOpt().hashCode());
            hash = hash * 31 + (getPartialOpt() == null ? 0 : getPartialOpt().hashCode());
            hash = hash * 31 + (getTypeParameterListOpt() == null ? 0 : getTypeParameterListOpt().hashCode());
            hash = hash * 31 + (getStructInterfacesOpt() == null ? 0 : getStructInterfacesOpt().hashCode());
            hash = hash * 31 + (getTypeParameterConstraintsClausesOpt() == null ? 0 : getTypeParameterConstraintsClausesOpt().hashCode());
            hash = hash * 31 + (getStructBody().hashCode());
            hash = hash * 31 + (getSemiOpt() == null ? 0 : getSemiOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 461:  StructInterfacesOpt ::= $Empty
     *</em>
     *<p>
     *<b>
     *<li>Rule 462:  StructInterfacesOpt ::= : StructInterfaces
     *</b>
     */
    static public class StructInterfacesOpt extends Ast implements IStructInterfacesOpt
    {
        private IStructInterfaces _StructInterfaces;

        public IStructInterfaces getStructInterfaces() { return _StructInterfaces; }

        public StructInterfacesOpt(IToken leftIToken, IToken rightIToken,
                                   IStructInterfaces _StructInterfaces)
        {
            super(leftIToken, rightIToken);

            this._StructInterfaces = _StructInterfaces;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof StructInterfacesOpt)) return false;
            StructInterfacesOpt other = (StructInterfacesOpt    ) o;
            if (! _StructInterfaces.equals(other.getStructInterfaces())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getStructInterfaces().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 463:  StructInterfaces ::= ClassType
     *</em>
     *<p>
     *<b>
     *<li>Rule 464:  StructInterfaces ::= StructInterfaces , ClassType
     *</b>
     */
    static public class StructInterfaces extends Ast implements IStructInterfaces
    {
        private IStructInterfaces _StructInterfaces;
        private IClassType _ClassType;

        public IStructInterfaces getStructInterfaces() { return _StructInterfaces; }
        public IClassType getClassType() { return _ClassType; }

        public StructInterfaces(IToken leftIToken, IToken rightIToken,
                                IStructInterfaces _StructInterfaces,
                                IClassType _ClassType)
        {
            super(leftIToken, rightIToken);

            this._StructInterfaces = _StructInterfaces;
            this._ClassType = _ClassType;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof StructInterfaces)) return false;
            StructInterfaces other = (StructInterfaces    ) o;
            if (! _StructInterfaces.equals(other.getStructInterfaces())) return false;
            if (! _ClassType.equals(other.getClassType())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getStructInterfaces().hashCode());
            hash = hash * 31 + (getClassType().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 465:  StructBody ::= { StructMemberDeclarationsOpt }
     *</b>
     */
    static public class StructBody extends Ast implements IStructBody
    {
        private IStructMemberDeclarationsOpt _StructMemberDeclarationsOpt;

        /**
         * The value returned by <b>getStructMemberDeclarationsOpt</b> may be <b>null</b>
         */
        public IStructMemberDeclarationsOpt getStructMemberDeclarationsOpt() { return _StructMemberDeclarationsOpt; }

        public StructBody(IToken leftIToken, IToken rightIToken,
                          IStructMemberDeclarationsOpt _StructMemberDeclarationsOpt)
        {
            super(leftIToken, rightIToken);

            this._StructMemberDeclarationsOpt = _StructMemberDeclarationsOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof StructBody)) return false;
            StructBody other = (StructBody    ) o;
            if (_StructMemberDeclarationsOpt == null && other.getStructMemberDeclarationsOpt() != null) return false;
            else if (! _StructMemberDeclarationsOpt.equals(other.getStructMemberDeclarationsOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getStructMemberDeclarationsOpt() == null ? 0 : getStructMemberDeclarationsOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 468:  StructMemberDeclarations ::= StructMemberDeclaration
     *</em>
     *<p>
     *<b>
     *<li>Rule 469:  StructMemberDeclarations ::= StructMemberDeclarations StructMemberDeclaration
     *</b>
     */
    static public class StructMemberDeclarations extends Ast implements IStructMemberDeclarations
    {
        private IStructMemberDeclarations _StructMemberDeclarations;
        private IStructMemberDeclaration _StructMemberDeclaration;

        public IStructMemberDeclarations getStructMemberDeclarations() { return _StructMemberDeclarations; }
        public IStructMemberDeclaration getStructMemberDeclaration() { return _StructMemberDeclaration; }

        public StructMemberDeclarations(IToken leftIToken, IToken rightIToken,
                                        IStructMemberDeclarations _StructMemberDeclarations,
                                        IStructMemberDeclaration _StructMemberDeclaration)
        {
            super(leftIToken, rightIToken);

            this._StructMemberDeclarations = _StructMemberDeclarations;
            this._StructMemberDeclaration = _StructMemberDeclaration;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof StructMemberDeclarations)) return false;
            StructMemberDeclarations other = (StructMemberDeclarations    ) o;
            if (! _StructMemberDeclarations.equals(other.getStructMemberDeclarations())) return false;
            if (! _StructMemberDeclaration.equals(other.getStructMemberDeclaration())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getStructMemberDeclarations().hashCode());
            hash = hash * 31 + (getStructMemberDeclaration().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 479:  ArrayType ::= NonArrayType RankSpecifiers
     *</b>
     */
    static public class ArrayType extends Ast implements IArrayType
    {
        private INonArrayType _NonArrayType;
        private IRankSpecifiers _RankSpecifiers;

        public INonArrayType getNonArrayType() { return _NonArrayType; }
        public IRankSpecifiers getRankSpecifiers() { return _RankSpecifiers; }

        public ArrayType(IToken leftIToken, IToken rightIToken,
                         INonArrayType _NonArrayType,
                         IRankSpecifiers _RankSpecifiers)
        {
            super(leftIToken, rightIToken);

            this._NonArrayType = _NonArrayType;
            this._RankSpecifiers = _RankSpecifiers;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ArrayType)) return false;
            ArrayType other = (ArrayType    ) o;
            if (! _NonArrayType.equals(other.getNonArrayType())) return false;
            if (! _RankSpecifiers.equals(other.getRankSpecifiers())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getNonArrayType().hashCode());
            hash = hash * 31 + (getRankSpecifiers().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 485:  RankSpecifiers ::= RankSpecifier
     *</em>
     *<p>
     *<b>
     *<li>Rule 486:  RankSpecifiers ::= RankSpecifiers RankSpecifier
     *</b>
     */
    static public class RankSpecifiers extends Ast implements IRankSpecifiers
    {
        private IRankSpecifiers _RankSpecifiers;
        private RankSpecifier _RankSpecifier;

        public IRankSpecifiers getRankSpecifiers() { return _RankSpecifiers; }
        public RankSpecifier getRankSpecifier() { return _RankSpecifier; }

        public RankSpecifiers(IToken leftIToken, IToken rightIToken,
                              IRankSpecifiers _RankSpecifiers,
                              RankSpecifier _RankSpecifier)
        {
            super(leftIToken, rightIToken);

            this._RankSpecifiers = _RankSpecifiers;
            this._RankSpecifier = _RankSpecifier;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof RankSpecifiers)) return false;
            RankSpecifiers other = (RankSpecifiers    ) o;
            if (! _RankSpecifiers.equals(other.getRankSpecifiers())) return false;
            if (! _RankSpecifier.equals(other.getRankSpecifier())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getRankSpecifiers().hashCode());
            hash = hash * 31 + (getRankSpecifier().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 487:  RankSpecifier ::= [ DimSeparatorsOpt ]
     *</b>
     */
    static public class RankSpecifier extends Ast implements IRankSpecifier
    {
        private IDimSeparatorsOpt _DimSeparatorsOpt;

        /**
         * The value returned by <b>getDimSeparatorsOpt</b> may be <b>null</b>
         */
        public IDimSeparatorsOpt getDimSeparatorsOpt() { return _DimSeparatorsOpt; }

        public RankSpecifier(IToken leftIToken, IToken rightIToken,
                             IDimSeparatorsOpt _DimSeparatorsOpt)
        {
            super(leftIToken, rightIToken);

            this._DimSeparatorsOpt = _DimSeparatorsOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof RankSpecifier)) return false;
            RankSpecifier other = (RankSpecifier    ) o;
            if (_DimSeparatorsOpt == null && other.getDimSeparatorsOpt() != null) return false;
            else if (! _DimSeparatorsOpt.equals(other.getDimSeparatorsOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getDimSeparatorsOpt() == null ? 0 : getDimSeparatorsOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 498:  VariableInitializerList ::= VariableInitializer
     *</em>
     *<p>
     *<b>
     *<li>Rule 499:  VariableInitializerList ::= VariableInitializerList , VariableInitializer
     *</b>
     */
    static public class VariableInitializerList extends Ast implements IVariableInitializerList
    {
        private IVariableInitializerList _VariableInitializerList;
        private IVariableInitializer _VariableInitializer;

        public IVariableInitializerList getVariableInitializerList() { return _VariableInitializerList; }
        public IVariableInitializer getVariableInitializer() { return _VariableInitializer; }

        public VariableInitializerList(IToken leftIToken, IToken rightIToken,
                                       IVariableInitializerList _VariableInitializerList,
                                       IVariableInitializer _VariableInitializer)
        {
            super(leftIToken, rightIToken);

            this._VariableInitializerList = _VariableInitializerList;
            this._VariableInitializer = _VariableInitializer;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof VariableInitializerList)) return false;
            VariableInitializerList other = (VariableInitializerList    ) o;
            if (! _VariableInitializerList.equals(other.getVariableInitializerList())) return false;
            if (! _VariableInitializer.equals(other.getVariableInitializer())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getVariableInitializerList().hashCode());
            hash = hash * 31 + (getVariableInitializer().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 500:  InterfaceDeclaration ::= AttributesOpt ModifiersOpt PartialOpt interface identifier TypeParameterListOpt InterfaceBaseOpt TypeParameterConstraintsClausesOpt InterfaceBody SemiOpt
     *</b>
     */
    static public class InterfaceDeclaration extends Ast implements IInterfaceDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private IModifiersOpt _ModifiersOpt;
        private PartialOpt _PartialOpt;
        private TypeParameterList _TypeParameterListOpt;
        private IInterfaceBaseOpt _InterfaceBaseOpt;
        private ITypeParameterConstraintsClausesOpt _TypeParameterConstraintsClausesOpt;
        private InterfaceBody _InterfaceBody;
        private SemiOpt _SemiOpt;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getModifiersOpt</b> may be <b>null</b>
         */
        public IModifiersOpt getModifiersOpt() { return _ModifiersOpt; }
        /**
         * The value returned by <b>getPartialOpt</b> may be <b>null</b>
         */
        public PartialOpt getPartialOpt() { return _PartialOpt; }
        /**
         * The value returned by <b>getTypeParameterListOpt</b> may be <b>null</b>
         */
        public TypeParameterList getTypeParameterListOpt() { return _TypeParameterListOpt; }
        /**
         * The value returned by <b>getInterfaceBaseOpt</b> may be <b>null</b>
         */
        public IInterfaceBaseOpt getInterfaceBaseOpt() { return _InterfaceBaseOpt; }
        /**
         * The value returned by <b>getTypeParameterConstraintsClausesOpt</b> may be <b>null</b>
         */
        public ITypeParameterConstraintsClausesOpt getTypeParameterConstraintsClausesOpt() { return _TypeParameterConstraintsClausesOpt; }
        public InterfaceBody getInterfaceBody() { return _InterfaceBody; }
        /**
         * The value returned by <b>getSemiOpt</b> may be <b>null</b>
         */
        public SemiOpt getSemiOpt() { return _SemiOpt; }

        public InterfaceDeclaration(IToken leftIToken, IToken rightIToken,
                                    IAttributesOpt _AttributesOpt,
                                    IModifiersOpt _ModifiersOpt,
                                    PartialOpt _PartialOpt,
                                    TypeParameterList _TypeParameterListOpt,
                                    IInterfaceBaseOpt _InterfaceBaseOpt,
                                    ITypeParameterConstraintsClausesOpt _TypeParameterConstraintsClausesOpt,
                                    InterfaceBody _InterfaceBody,
                                    SemiOpt _SemiOpt)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ModifiersOpt = _ModifiersOpt;
            this._PartialOpt = _PartialOpt;
            this._TypeParameterListOpt = _TypeParameterListOpt;
            this._InterfaceBaseOpt = _InterfaceBaseOpt;
            this._TypeParameterConstraintsClausesOpt = _TypeParameterConstraintsClausesOpt;
            this._InterfaceBody = _InterfaceBody;
            this._SemiOpt = _SemiOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof InterfaceDeclaration)) return false;
            InterfaceDeclaration other = (InterfaceDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_ModifiersOpt == null && other.getModifiersOpt() != null) return false;
            else if (! _ModifiersOpt.equals(other.getModifiersOpt())) return false;
            if (_PartialOpt == null && other.getPartialOpt() != null) return false;
            else if (! _PartialOpt.equals(other.getPartialOpt())) return false;
            if (_TypeParameterListOpt == null && other.getTypeParameterListOpt() != null) return false;
            else if (! _TypeParameterListOpt.equals(other.getTypeParameterListOpt())) return false;
            if (_InterfaceBaseOpt == null && other.getInterfaceBaseOpt() != null) return false;
            else if (! _InterfaceBaseOpt.equals(other.getInterfaceBaseOpt())) return false;
            if (_TypeParameterConstraintsClausesOpt == null && other.getTypeParameterConstraintsClausesOpt() != null) return false;
            else if (! _TypeParameterConstraintsClausesOpt.equals(other.getTypeParameterConstraintsClausesOpt())) return false;
            if (! _InterfaceBody.equals(other.getInterfaceBody())) return false;
            if (_SemiOpt == null && other.getSemiOpt() != null) return false;
            else if (! _SemiOpt.equals(other.getSemiOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getModifiersOpt() == null ? 0 : getModifiersOpt().hashCode());
            hash = hash * 31 + (getPartialOpt() == null ? 0 : getPartialOpt().hashCode());
            hash = hash * 31 + (getTypeParameterListOpt() == null ? 0 : getTypeParameterListOpt().hashCode());
            hash = hash * 31 + (getInterfaceBaseOpt() == null ? 0 : getInterfaceBaseOpt().hashCode());
            hash = hash * 31 + (getTypeParameterConstraintsClausesOpt() == null ? 0 : getTypeParameterConstraintsClausesOpt().hashCode());
            hash = hash * 31 + (getInterfaceBody().hashCode());
            hash = hash * 31 + (getSemiOpt() == null ? 0 : getSemiOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 503:  InterfaceBase ::= Name
     *</em>
     *<p>
     *<b>
     *<li>Rule 504:  InterfaceBase ::= InterfaceBase , Name
     *</b>
     */
    static public class InterfaceBase extends Ast implements IInterfaceBase
    {
        private IInterfaceBase _InterfaceBase;
        private IName _Name;

        public IInterfaceBase getInterfaceBase() { return _InterfaceBase; }
        public IName getName() { return _Name; }

        public InterfaceBase(IToken leftIToken, IToken rightIToken,
                             IInterfaceBase _InterfaceBase,
                             IName _Name)
        {
            super(leftIToken, rightIToken);

            this._InterfaceBase = _InterfaceBase;
            this._Name = _Name;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof InterfaceBase)) return false;
            InterfaceBase other = (InterfaceBase    ) o;
            if (! _InterfaceBase.equals(other.getInterfaceBase())) return false;
            if (! _Name.equals(other.getName())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getInterfaceBase().hashCode());
            hash = hash * 31 + (getName().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 505:  InterfaceBody ::= { InterfaceMemberDeclarationsOpt }
     *</b>
     */
    static public class InterfaceBody extends Ast implements IInterfaceBody
    {
        private IInterfaceMemberDeclarationsOpt _InterfaceMemberDeclarationsOpt;

        /**
         * The value returned by <b>getInterfaceMemberDeclarationsOpt</b> may be <b>null</b>
         */
        public IInterfaceMemberDeclarationsOpt getInterfaceMemberDeclarationsOpt() { return _InterfaceMemberDeclarationsOpt; }

        public InterfaceBody(IToken leftIToken, IToken rightIToken,
                             IInterfaceMemberDeclarationsOpt _InterfaceMemberDeclarationsOpt)
        {
            super(leftIToken, rightIToken);

            this._InterfaceMemberDeclarationsOpt = _InterfaceMemberDeclarationsOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof InterfaceBody)) return false;
            InterfaceBody other = (InterfaceBody    ) o;
            if (_InterfaceMemberDeclarationsOpt == null && other.getInterfaceMemberDeclarationsOpt() != null) return false;
            else if (! _InterfaceMemberDeclarationsOpt.equals(other.getInterfaceMemberDeclarationsOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getInterfaceMemberDeclarationsOpt() == null ? 0 : getInterfaceMemberDeclarationsOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 508:  InterfaceMemberDeclarations ::= InterfaceMemberDeclaration
     *</em>
     *<p>
     *<b>
     *<li>Rule 509:  InterfaceMemberDeclarations ::= InterfaceMemberDeclarations InterfaceMemberDeclaration
     *</b>
     */
    static public class InterfaceMemberDeclarations extends Ast implements IInterfaceMemberDeclarations
    {
        private IInterfaceMemberDeclarations _InterfaceMemberDeclarations;
        private IInterfaceMemberDeclaration _InterfaceMemberDeclaration;

        public IInterfaceMemberDeclarations getInterfaceMemberDeclarations() { return _InterfaceMemberDeclarations; }
        public IInterfaceMemberDeclaration getInterfaceMemberDeclaration() { return _InterfaceMemberDeclaration; }

        public InterfaceMemberDeclarations(IToken leftIToken, IToken rightIToken,
                                           IInterfaceMemberDeclarations _InterfaceMemberDeclarations,
                                           IInterfaceMemberDeclaration _InterfaceMemberDeclaration)
        {
            super(leftIToken, rightIToken);

            this._InterfaceMemberDeclarations = _InterfaceMemberDeclarations;
            this._InterfaceMemberDeclaration = _InterfaceMemberDeclaration;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof InterfaceMemberDeclarations)) return false;
            InterfaceMemberDeclarations other = (InterfaceMemberDeclarations    ) o;
            if (! _InterfaceMemberDeclarations.equals(other.getInterfaceMemberDeclarations())) return false;
            if (! _InterfaceMemberDeclaration.equals(other.getInterfaceMemberDeclaration())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getInterfaceMemberDeclarations().hashCode());
            hash = hash * 31 + (getInterfaceMemberDeclaration().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 514:  InterfaceMethodDeclaration ::= AttributesOpt NewOpt Type identifier TypeParameterListOpt ( FormalParameterListOpt ) TypeParameterConstraintsClausesOpt ;
     *</b>
     */
    static public class InterfaceMethodDeclaration extends Ast implements IInterfaceMethodDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private NewOpt _NewOpt;
        private IType _Type;
        private TypeParameterList _TypeParameterListOpt;
        private IFormalParameterListOpt _FormalParameterListOpt;
        private ITypeParameterConstraintsClausesOpt _TypeParameterConstraintsClausesOpt;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getNewOpt</b> may be <b>null</b>
         */
        public NewOpt getNewOpt() { return _NewOpt; }
        public IType getType() { return _Type; }
        /**
         * The value returned by <b>getTypeParameterListOpt</b> may be <b>null</b>
         */
        public TypeParameterList getTypeParameterListOpt() { return _TypeParameterListOpt; }
        /**
         * The value returned by <b>getFormalParameterListOpt</b> may be <b>null</b>
         */
        public IFormalParameterListOpt getFormalParameterListOpt() { return _FormalParameterListOpt; }
        /**
         * The value returned by <b>getTypeParameterConstraintsClausesOpt</b> may be <b>null</b>
         */
        public ITypeParameterConstraintsClausesOpt getTypeParameterConstraintsClausesOpt() { return _TypeParameterConstraintsClausesOpt; }

        public InterfaceMethodDeclaration(IToken leftIToken, IToken rightIToken,
                                          IAttributesOpt _AttributesOpt,
                                          NewOpt _NewOpt,
                                          IType _Type,
                                          TypeParameterList _TypeParameterListOpt,
                                          IFormalParameterListOpt _FormalParameterListOpt,
                                          ITypeParameterConstraintsClausesOpt _TypeParameterConstraintsClausesOpt)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._NewOpt = _NewOpt;
            this._Type = _Type;
            this._TypeParameterListOpt = _TypeParameterListOpt;
            this._FormalParameterListOpt = _FormalParameterListOpt;
            this._TypeParameterConstraintsClausesOpt = _TypeParameterConstraintsClausesOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof InterfaceMethodDeclaration)) return false;
            InterfaceMethodDeclaration other = (InterfaceMethodDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_NewOpt == null && other.getNewOpt() != null) return false;
            else if (! _NewOpt.equals(other.getNewOpt())) return false;
            if (! _Type.equals(other.getType())) return false;
            if (_TypeParameterListOpt == null && other.getTypeParameterListOpt() != null) return false;
            else if (! _TypeParameterListOpt.equals(other.getTypeParameterListOpt())) return false;
            if (_FormalParameterListOpt == null && other.getFormalParameterListOpt() != null) return false;
            else if (! _FormalParameterListOpt.equals(other.getFormalParameterListOpt())) return false;
            if (_TypeParameterConstraintsClausesOpt == null && other.getTypeParameterConstraintsClausesOpt() != null) return false;
            else if (! _TypeParameterConstraintsClausesOpt.equals(other.getTypeParameterConstraintsClausesOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getNewOpt() == null ? 0 : getNewOpt().hashCode());
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getTypeParameterListOpt() == null ? 0 : getTypeParameterListOpt().hashCode());
            hash = hash * 31 + (getFormalParameterListOpt() == null ? 0 : getFormalParameterListOpt().hashCode());
            hash = hash * 31 + (getTypeParameterConstraintsClausesOpt() == null ? 0 : getTypeParameterConstraintsClausesOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 515:  InterfacePropertyDeclaration ::= AttributesOpt NewOpt Type identifier { InterfaceAccessors }
     *</b>
     */
    static public class InterfacePropertyDeclaration extends Ast implements IInterfacePropertyDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private NewOpt _NewOpt;
        private IType _Type;
        private IInterfaceAccessors _InterfaceAccessors;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getNewOpt</b> may be <b>null</b>
         */
        public NewOpt getNewOpt() { return _NewOpt; }
        public IType getType() { return _Type; }
        public IInterfaceAccessors getInterfaceAccessors() { return _InterfaceAccessors; }

        public InterfacePropertyDeclaration(IToken leftIToken, IToken rightIToken,
                                            IAttributesOpt _AttributesOpt,
                                            NewOpt _NewOpt,
                                            IType _Type,
                                            IInterfaceAccessors _InterfaceAccessors)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._NewOpt = _NewOpt;
            this._Type = _Type;
            this._InterfaceAccessors = _InterfaceAccessors;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof InterfacePropertyDeclaration)) return false;
            InterfacePropertyDeclaration other = (InterfacePropertyDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_NewOpt == null && other.getNewOpt() != null) return false;
            else if (! _NewOpt.equals(other.getNewOpt())) return false;
            if (! _Type.equals(other.getType())) return false;
            if (! _InterfaceAccessors.equals(other.getInterfaceAccessors())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getNewOpt() == null ? 0 : getNewOpt().hashCode());
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getInterfaceAccessors().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 520:  InterfaceEventDeclaration ::= AttributesOpt NewOpt event Type identifier ;
     *</b>
     */
    static public class InterfaceEventDeclaration extends Ast implements IInterfaceEventDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private NewOpt _NewOpt;
        private IType _Type;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getNewOpt</b> may be <b>null</b>
         */
        public NewOpt getNewOpt() { return _NewOpt; }
        public IType getType() { return _Type; }

        public InterfaceEventDeclaration(IToken leftIToken, IToken rightIToken,
                                         IAttributesOpt _AttributesOpt,
                                         NewOpt _NewOpt,
                                         IType _Type)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._NewOpt = _NewOpt;
            this._Type = _Type;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof InterfaceEventDeclaration)) return false;
            InterfaceEventDeclaration other = (InterfaceEventDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_NewOpt == null && other.getNewOpt() != null) return false;
            else if (! _NewOpt.equals(other.getNewOpt())) return false;
            if (! _Type.equals(other.getType())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getNewOpt() == null ? 0 : getNewOpt().hashCode());
            hash = hash * 31 + (getType().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 521:  InterfaceIndexerDeclaration ::= AttributesOpt NewOpt Type this [ FormalParameterList ] { InterfaceAccessors }
     *</b>
     */
    static public class InterfaceIndexerDeclaration extends Ast implements IInterfaceIndexerDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private NewOpt _NewOpt;
        private IType _Type;
        private IFormalParameterList _FormalParameterList;
        private IInterfaceAccessors _InterfaceAccessors;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getNewOpt</b> may be <b>null</b>
         */
        public NewOpt getNewOpt() { return _NewOpt; }
        public IType getType() { return _Type; }
        public IFormalParameterList getFormalParameterList() { return _FormalParameterList; }
        public IInterfaceAccessors getInterfaceAccessors() { return _InterfaceAccessors; }

        public InterfaceIndexerDeclaration(IToken leftIToken, IToken rightIToken,
                                           IAttributesOpt _AttributesOpt,
                                           NewOpt _NewOpt,
                                           IType _Type,
                                           IFormalParameterList _FormalParameterList,
                                           IInterfaceAccessors _InterfaceAccessors)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._NewOpt = _NewOpt;
            this._Type = _Type;
            this._FormalParameterList = _FormalParameterList;
            this._InterfaceAccessors = _InterfaceAccessors;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof InterfaceIndexerDeclaration)) return false;
            InterfaceIndexerDeclaration other = (InterfaceIndexerDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_NewOpt == null && other.getNewOpt() != null) return false;
            else if (! _NewOpt.equals(other.getNewOpt())) return false;
            if (! _Type.equals(other.getType())) return false;
            if (! _FormalParameterList.equals(other.getFormalParameterList())) return false;
            if (! _InterfaceAccessors.equals(other.getInterfaceAccessors())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getNewOpt() == null ? 0 : getNewOpt().hashCode());
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getFormalParameterList().hashCode());
            hash = hash * 31 + (getInterfaceAccessors().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 522:  EnumDeclaration ::= AttributesOpt ModifiersOpt enum identifier EnumBaseOpt EnumBody SemiOpt
     *</b>
     */
    static public class EnumDeclaration extends Ast implements IEnumDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private IModifiersOpt _ModifiersOpt;
        private EnumBase _EnumBaseOpt;
        private IEnumBody _EnumBody;
        private SemiOpt _SemiOpt;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getModifiersOpt</b> may be <b>null</b>
         */
        public IModifiersOpt getModifiersOpt() { return _ModifiersOpt; }
        /**
         * The value returned by <b>getEnumBaseOpt</b> may be <b>null</b>
         */
        public EnumBase getEnumBaseOpt() { return _EnumBaseOpt; }
        public IEnumBody getEnumBody() { return _EnumBody; }
        /**
         * The value returned by <b>getSemiOpt</b> may be <b>null</b>
         */
        public SemiOpt getSemiOpt() { return _SemiOpt; }

        public EnumDeclaration(IToken leftIToken, IToken rightIToken,
                               IAttributesOpt _AttributesOpt,
                               IModifiersOpt _ModifiersOpt,
                               EnumBase _EnumBaseOpt,
                               IEnumBody _EnumBody,
                               SemiOpt _SemiOpt)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ModifiersOpt = _ModifiersOpt;
            this._EnumBaseOpt = _EnumBaseOpt;
            this._EnumBody = _EnumBody;
            this._SemiOpt = _SemiOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof EnumDeclaration)) return false;
            EnumDeclaration other = (EnumDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_ModifiersOpt == null && other.getModifiersOpt() != null) return false;
            else if (! _ModifiersOpt.equals(other.getModifiersOpt())) return false;
            if (_EnumBaseOpt == null && other.getEnumBaseOpt() != null) return false;
            else if (! _EnumBaseOpt.equals(other.getEnumBaseOpt())) return false;
            if (! _EnumBody.equals(other.getEnumBody())) return false;
            if (_SemiOpt == null && other.getSemiOpt() != null) return false;
            else if (! _SemiOpt.equals(other.getSemiOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getModifiersOpt() == null ? 0 : getModifiersOpt().hashCode());
            hash = hash * 31 + (getEnumBaseOpt() == null ? 0 : getEnumBaseOpt().hashCode());
            hash = hash * 31 + (getEnumBody().hashCode());
            hash = hash * 31 + (getSemiOpt() == null ? 0 : getSemiOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 525:  EnumBase ::= : IntegralType
     *</b>
     */
    static public class EnumBase extends Ast implements IEnumBase
    {
        private IIntegralType _IntegralType;

        public IIntegralType getIntegralType() { return _IntegralType; }

        public EnumBase(IToken leftIToken, IToken rightIToken,
                        IIntegralType _IntegralType)
        {
            super(leftIToken, rightIToken);

            this._IntegralType = _IntegralType;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof EnumBase)) return false;
            EnumBase other = (EnumBase    ) o;
            if (! _IntegralType.equals(other.getIntegralType())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getIntegralType().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 530:  EnumMemberDeclarations ::= EnumMemberDeclaration
     *</em>
     *<p>
     *<b>
     *<li>Rule 531:  EnumMemberDeclarations ::= EnumMemberDeclarations , EnumMemberDeclaration
     *</b>
     */
    static public class EnumMemberDeclarations extends Ast implements IEnumMemberDeclarations
    {
        private IEnumMemberDeclarations _EnumMemberDeclarations;
        private IEnumMemberDeclaration _EnumMemberDeclaration;

        public IEnumMemberDeclarations getEnumMemberDeclarations() { return _EnumMemberDeclarations; }
        public IEnumMemberDeclaration getEnumMemberDeclaration() { return _EnumMemberDeclaration; }

        public EnumMemberDeclarations(IToken leftIToken, IToken rightIToken,
                                      IEnumMemberDeclarations _EnumMemberDeclarations,
                                      IEnumMemberDeclaration _EnumMemberDeclaration)
        {
            super(leftIToken, rightIToken);

            this._EnumMemberDeclarations = _EnumMemberDeclarations;
            this._EnumMemberDeclaration = _EnumMemberDeclaration;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof EnumMemberDeclarations)) return false;
            EnumMemberDeclarations other = (EnumMemberDeclarations    ) o;
            if (! _EnumMemberDeclarations.equals(other.getEnumMemberDeclarations())) return false;
            if (! _EnumMemberDeclaration.equals(other.getEnumMemberDeclaration())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getEnumMemberDeclarations().hashCode());
            hash = hash * 31 + (getEnumMemberDeclaration().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 534:  DelegateDeclaration ::= AttributesOpt ModifiersOpt delegate Type identifier TypeParameterListOpt ( FormalParameterListOpt ) TypeParameterConstraintsClausesOpt ;
     *</b>
     */
    static public class DelegateDeclaration extends Ast implements IDelegateDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private IModifiersOpt _ModifiersOpt;
        private IType _Type;
        private TypeParameterList _TypeParameterListOpt;
        private IFormalParameterListOpt _FormalParameterListOpt;
        private ITypeParameterConstraintsClausesOpt _TypeParameterConstraintsClausesOpt;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getModifiersOpt</b> may be <b>null</b>
         */
        public IModifiersOpt getModifiersOpt() { return _ModifiersOpt; }
        public IType getType() { return _Type; }
        /**
         * The value returned by <b>getTypeParameterListOpt</b> may be <b>null</b>
         */
        public TypeParameterList getTypeParameterListOpt() { return _TypeParameterListOpt; }
        /**
         * The value returned by <b>getFormalParameterListOpt</b> may be <b>null</b>
         */
        public IFormalParameterListOpt getFormalParameterListOpt() { return _FormalParameterListOpt; }
        /**
         * The value returned by <b>getTypeParameterConstraintsClausesOpt</b> may be <b>null</b>
         */
        public ITypeParameterConstraintsClausesOpt getTypeParameterConstraintsClausesOpt() { return _TypeParameterConstraintsClausesOpt; }

        public DelegateDeclaration(IToken leftIToken, IToken rightIToken,
                                   IAttributesOpt _AttributesOpt,
                                   IModifiersOpt _ModifiersOpt,
                                   IType _Type,
                                   TypeParameterList _TypeParameterListOpt,
                                   IFormalParameterListOpt _FormalParameterListOpt,
                                   ITypeParameterConstraintsClausesOpt _TypeParameterConstraintsClausesOpt)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ModifiersOpt = _ModifiersOpt;
            this._Type = _Type;
            this._TypeParameterListOpt = _TypeParameterListOpt;
            this._FormalParameterListOpt = _FormalParameterListOpt;
            this._TypeParameterConstraintsClausesOpt = _TypeParameterConstraintsClausesOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof DelegateDeclaration)) return false;
            DelegateDeclaration other = (DelegateDeclaration    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_ModifiersOpt == null && other.getModifiersOpt() != null) return false;
            else if (! _ModifiersOpt.equals(other.getModifiersOpt())) return false;
            if (! _Type.equals(other.getType())) return false;
            if (_TypeParameterListOpt == null && other.getTypeParameterListOpt() != null) return false;
            else if (! _TypeParameterListOpt.equals(other.getTypeParameterListOpt())) return false;
            if (_FormalParameterListOpt == null && other.getFormalParameterListOpt() != null) return false;
            else if (! _FormalParameterListOpt.equals(other.getFormalParameterListOpt())) return false;
            if (_TypeParameterConstraintsClausesOpt == null && other.getTypeParameterConstraintsClausesOpt() != null) return false;
            else if (! _TypeParameterConstraintsClausesOpt.equals(other.getTypeParameterConstraintsClausesOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getModifiersOpt() == null ? 0 : getModifiersOpt().hashCode());
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getTypeParameterListOpt() == null ? 0 : getTypeParameterListOpt().hashCode());
            hash = hash * 31 + (getFormalParameterListOpt() == null ? 0 : getFormalParameterListOpt().hashCode());
            hash = hash * 31 + (getTypeParameterConstraintsClausesOpt() == null ? 0 : getTypeParameterConstraintsClausesOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 538:  AttributeSections ::= AttributeSection
     *</em>
     *<p>
     *<b>
     *<li>Rule 539:  AttributeSections ::= AttributeSections AttributeSection
     *</b>
     */
    static public class AttributeSections extends Ast implements IAttributeSections
    {
        private IAttributeSections _AttributeSections;
        private IAttributeSection _AttributeSection;

        public IAttributeSections getAttributeSections() { return _AttributeSections; }
        public IAttributeSection getAttributeSection() { return _AttributeSection; }

        public AttributeSections(IToken leftIToken, IToken rightIToken,
                                 IAttributeSections _AttributeSections,
                                 IAttributeSection _AttributeSection)
        {
            super(leftIToken, rightIToken);

            this._AttributeSections = _AttributeSections;
            this._AttributeSection = _AttributeSection;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AttributeSections)) return false;
            AttributeSections other = (AttributeSections    ) o;
            if (! _AttributeSections.equals(other.getAttributeSections())) return false;
            if (! _AttributeSection.equals(other.getAttributeSection())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributeSections().hashCode());
            hash = hash * 31 + (getAttributeSection().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 544:  AttributeTargetSpecifier ::= AttributeTarget :
     *</b>
     */
    static public class AttributeTargetSpecifier extends Ast implements IAttributeTargetSpecifier
    {
        private IAttributeTarget _AttributeTarget;

        public IAttributeTarget getAttributeTarget() { return _AttributeTarget; }

        public AttributeTargetSpecifier(IToken leftIToken, IToken rightIToken,
                                        IAttributeTarget _AttributeTarget)
        {
            super(leftIToken, rightIToken);

            this._AttributeTarget = _AttributeTarget;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AttributeTargetSpecifier)) return false;
            AttributeTargetSpecifier other = (AttributeTargetSpecifier    ) o;
            if (! _AttributeTarget.equals(other.getAttributeTarget())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributeTarget().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 546:  AttributeTarget ::= Keyword
     *</em>
     *<p>
     *<b>
     *<li>Rule 545:  AttributeTarget ::= identifier
     *</b>
     */
    static public class AttributeTarget extends AstToken implements IAttributeTarget
    {
        public AttributeTarget(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 632:  AttributeList ::= Attribute
     *</em>
     *<p>
     *<b>
     *<li>Rule 633:  AttributeList ::= AttributeList , Attribute
     *</b>
     */
    static public class AttributeList extends Ast implements IAttributeList
    {
        private IAttributeList _AttributeList;
        private Attribute _Attribute;

        public IAttributeList getAttributeList() { return _AttributeList; }
        public Attribute getAttribute() { return _Attribute; }

        public AttributeList(IToken leftIToken, IToken rightIToken,
                             IAttributeList _AttributeList,
                             Attribute _Attribute)
        {
            super(leftIToken, rightIToken);

            this._AttributeList = _AttributeList;
            this._Attribute = _Attribute;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AttributeList)) return false;
            AttributeList other = (AttributeList    ) o;
            if (! _AttributeList.equals(other.getAttributeList())) return false;
            if (! _Attribute.equals(other.getAttribute())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributeList().hashCode());
            hash = hash * 31 + (getAttribute().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 634:  Attribute ::= AttributeName AttributeArgumentsOpt
     *</b>
     */
    static public class Attribute extends Ast implements IAttribute
    {
        private IAttributeName _AttributeName;
        private IAttributeArgumentsOpt _AttributeArgumentsOpt;

        public IAttributeName getAttributeName() { return _AttributeName; }
        /**
         * The value returned by <b>getAttributeArgumentsOpt</b> may be <b>null</b>
         */
        public IAttributeArgumentsOpt getAttributeArgumentsOpt() { return _AttributeArgumentsOpt; }

        public Attribute(IToken leftIToken, IToken rightIToken,
                         IAttributeName _AttributeName,
                         IAttributeArgumentsOpt _AttributeArgumentsOpt)
        {
            super(leftIToken, rightIToken);

            this._AttributeName = _AttributeName;
            this._AttributeArgumentsOpt = _AttributeArgumentsOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof Attribute)) return false;
            Attribute other = (Attribute    ) o;
            if (! _AttributeName.equals(other.getAttributeName())) return false;
            if (_AttributeArgumentsOpt == null && other.getAttributeArgumentsOpt() != null) return false;
            else if (! _AttributeArgumentsOpt.equals(other.getAttributeArgumentsOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributeName().hashCode());
            hash = hash * 31 + (getAttributeArgumentsOpt() == null ? 0 : getAttributeArgumentsOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 643:  PositionalArgumentList ::= PositionalArgument
     *</em>
     *<p>
     *<b>
     *<li>Rule 644:  PositionalArgumentList ::= PositionalArgumentList , PositionalArgument
     *</b>
     */
    static public class PositionalArgumentList extends Ast implements IPositionalArgumentList
    {
        private IPositionalArgumentList _PositionalArgumentList;
        private IPositionalArgument _PositionalArgument;

        public IPositionalArgumentList getPositionalArgumentList() { return _PositionalArgumentList; }
        public IPositionalArgument getPositionalArgument() { return _PositionalArgument; }

        public PositionalArgumentList(IToken leftIToken, IToken rightIToken,
                                      IPositionalArgumentList _PositionalArgumentList,
                                      IPositionalArgument _PositionalArgument)
        {
            super(leftIToken, rightIToken);

            this._PositionalArgumentList = _PositionalArgumentList;
            this._PositionalArgument = _PositionalArgument;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof PositionalArgumentList)) return false;
            PositionalArgumentList other = (PositionalArgumentList    ) o;
            if (! _PositionalArgumentList.equals(other.getPositionalArgumentList())) return false;
            if (! _PositionalArgument.equals(other.getPositionalArgument())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getPositionalArgumentList().hashCode());
            hash = hash * 31 + (getPositionalArgument().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 646:  NamedArgumentList ::= NamedArgument
     *</em>
     *<p>
     *<b>
     *<li>Rule 647:  NamedArgumentList ::= NamedArgumentList , NamedArgument
     *</b>
     */
    static public class NamedArgumentList extends Ast implements INamedArgumentList
    {
        private INamedArgumentList _NamedArgumentList;
        private NamedArgument _NamedArgument;

        public INamedArgumentList getNamedArgumentList() { return _NamedArgumentList; }
        public NamedArgument getNamedArgument() { return _NamedArgument; }

        public NamedArgumentList(IToken leftIToken, IToken rightIToken,
                                 INamedArgumentList _NamedArgumentList,
                                 NamedArgument _NamedArgument)
        {
            super(leftIToken, rightIToken);

            this._NamedArgumentList = _NamedArgumentList;
            this._NamedArgument = _NamedArgument;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof NamedArgumentList)) return false;
            NamedArgumentList other = (NamedArgumentList    ) o;
            if (! _NamedArgumentList.equals(other.getNamedArgumentList())) return false;
            if (! _NamedArgument.equals(other.getNamedArgument())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getNamedArgumentList().hashCode());
            hash = hash * 31 + (getNamedArgument().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 648:  NamedArgument ::= identifier = AttributeArgumentExpression
     *</b>
     */
    static public class NamedArgument extends Ast implements INamedArgument
    {
        private IAttributeArgumentExpression _AttributeArgumentExpression;

        public IAttributeArgumentExpression getAttributeArgumentExpression() { return _AttributeArgumentExpression; }

        public NamedArgument(IToken leftIToken, IToken rightIToken,
                             IAttributeArgumentExpression _AttributeArgumentExpression)
        {
            super(leftIToken, rightIToken);

            this._AttributeArgumentExpression = _AttributeArgumentExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof NamedArgument)) return false;
            NamedArgument other = (NamedArgument    ) o;
            if (! _AttributeArgumentExpression.equals(other.getAttributeArgumentExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributeArgumentExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 652:  TypeParameterList ::= < TypeParameters >
     *</b>
     */
    static public class TypeParameterList extends Ast implements ITypeParameterList
    {
        private ITypeParameters _TypeParameters;

        public ITypeParameters getTypeParameters() { return _TypeParameters; }

        public TypeParameterList(IToken leftIToken, IToken rightIToken,
                                 ITypeParameters _TypeParameters)
        {
            super(leftIToken, rightIToken);

            this._TypeParameters = _TypeParameters;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof TypeParameterList)) return false;
            TypeParameterList other = (TypeParameterList    ) o;
            if (! _TypeParameters.equals(other.getTypeParameters())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getTypeParameters().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 655:  TypeParameter ::= identifier
     *</b>
     */
    static public class TypeParameter extends AstToken implements ITypeParameter
    {
        public TypeParameter(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 658:  TypeArgumentList ::= < TypeArguments >
     *</b>
     */
    static public class TypeArgumentList extends Ast implements ITypeArgumentList
    {
        private ITypeArguments _TypeArguments;

        public ITypeArguments getTypeArguments() { return _TypeArguments; }

        public TypeArgumentList(IToken leftIToken, IToken rightIToken,
                                ITypeArguments _TypeArguments)
        {
            super(leftIToken, rightIToken);

            this._TypeArguments = _TypeArguments;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof TypeArgumentList)) return false;
            TypeArgumentList other = (TypeArgumentList    ) o;
            if (! _TypeArguments.equals(other.getTypeArguments())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getTypeArguments().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 659:  TypeArguments ::= TypeArgument
     *</em>
     *<p>
     *<b>
     *<li>Rule 660:  TypeArguments ::= TypeArguments , TypeArgument
     *</b>
     */
    static public class TypeArguments extends Ast implements ITypeArguments
    {
        private ITypeArguments _TypeArguments;
        private ITypeArgument _TypeArgument;

        public ITypeArguments getTypeArguments() { return _TypeArguments; }
        public ITypeArgument getTypeArgument() { return _TypeArgument; }

        public TypeArguments(IToken leftIToken, IToken rightIToken,
                             ITypeArguments _TypeArguments,
                             ITypeArgument _TypeArgument)
        {
            super(leftIToken, rightIToken);

            this._TypeArguments = _TypeArguments;
            this._TypeArgument = _TypeArgument;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof TypeArguments)) return false;
            TypeArguments other = (TypeArguments    ) o;
            if (! _TypeArguments.equals(other.getTypeArguments())) return false;
            if (! _TypeArgument.equals(other.getTypeArgument())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getTypeArguments().hashCode());
            hash = hash * 31 + (getTypeArgument().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 664:  TypeParameterConstraintsClauses ::= TypeParameterConstraintsClause
     *</em>
     *<p>
     *<b>
     *<li>Rule 665:  TypeParameterConstraintsClauses ::= TypeParameterConstraintsClauses TypeParameterConstraintsClause
     *</b>
     */
    static public class TypeParameterConstraintsClauses extends Ast implements ITypeParameterConstraintsClauses
    {
        private ITypeParameterConstraintsClauses _TypeParameterConstraintsClauses;
        private TypeParameterConstraintsClause _TypeParameterConstraintsClause;

        public ITypeParameterConstraintsClauses getTypeParameterConstraintsClauses() { return _TypeParameterConstraintsClauses; }
        public TypeParameterConstraintsClause getTypeParameterConstraintsClause() { return _TypeParameterConstraintsClause; }

        public TypeParameterConstraintsClauses(IToken leftIToken, IToken rightIToken,
                                               ITypeParameterConstraintsClauses _TypeParameterConstraintsClauses,
                                               TypeParameterConstraintsClause _TypeParameterConstraintsClause)
        {
            super(leftIToken, rightIToken);

            this._TypeParameterConstraintsClauses = _TypeParameterConstraintsClauses;
            this._TypeParameterConstraintsClause = _TypeParameterConstraintsClause;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof TypeParameterConstraintsClauses)) return false;
            TypeParameterConstraintsClauses other = (TypeParameterConstraintsClauses    ) o;
            if (! _TypeParameterConstraintsClauses.equals(other.getTypeParameterConstraintsClauses())) return false;
            if (! _TypeParameterConstraintsClause.equals(other.getTypeParameterConstraintsClause())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getTypeParameterConstraintsClauses().hashCode());
            hash = hash * 31 + (getTypeParameterConstraintsClause().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 666:  TypeParameterConstraintsClause ::= where TypeParameter : TypeParameterConstraints
     *</b>
     */
    static public class TypeParameterConstraintsClause extends Ast implements ITypeParameterConstraintsClause
    {
        private TypeParameter _TypeParameter;
        private ITypeParameterConstraints _TypeParameterConstraints;

        public TypeParameter getTypeParameter() { return _TypeParameter; }
        public ITypeParameterConstraints getTypeParameterConstraints() { return _TypeParameterConstraints; }

        public TypeParameterConstraintsClause(IToken leftIToken, IToken rightIToken,
                                              TypeParameter _TypeParameter,
                                              ITypeParameterConstraints _TypeParameterConstraints)
        {
            super(leftIToken, rightIToken);

            this._TypeParameter = _TypeParameter;
            this._TypeParameterConstraints = _TypeParameterConstraints;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof TypeParameterConstraintsClause)) return false;
            TypeParameterConstraintsClause other = (TypeParameterConstraintsClause    ) o;
            if (! _TypeParameter.equals(other.getTypeParameter())) return false;
            if (! _TypeParameterConstraints.equals(other.getTypeParameterConstraints())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getTypeParameter().hashCode());
            hash = hash * 31 + (getTypeParameterConstraints().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 667:  TypeParameterConstraints ::= Constraints
     *<li>Rule 668:  TypeParameterConstraints ::= ConstructorConstraint
     *</em>
     *<p>
     *<b>
     *<li>Rule 669:  TypeParameterConstraints ::= Constraint , ConstructorConstraint
     *</b>
     */
    static public class TypeParameterConstraints extends Ast implements ITypeParameterConstraints
    {
        private IConstraint _Constraint;
        private ConstructorConstraint _ConstructorConstraint;

        public IConstraint getConstraint() { return _Constraint; }
        public ConstructorConstraint getConstructorConstraint() { return _ConstructorConstraint; }

        public TypeParameterConstraints(IToken leftIToken, IToken rightIToken,
                                        IConstraint _Constraint,
                                        ConstructorConstraint _ConstructorConstraint)
        {
            super(leftIToken, rightIToken);

            this._Constraint = _Constraint;
            this._ConstructorConstraint = _ConstructorConstraint;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof TypeParameterConstraints)) return false;
            TypeParameterConstraints other = (TypeParameterConstraints    ) o;
            if (! _Constraint.equals(other.getConstraint())) return false;
            if (! _ConstructorConstraint.equals(other.getConstructorConstraint())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getConstraint().hashCode());
            hash = hash * 31 + (getConstructorConstraint().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<em>
     *<li>Rule 670:  Constraints ::= Constraint
     *</em>
     *<p>
     *<b>
     *<li>Rule 671:  Constraints ::= Constraints , Constraint
     *</b>
     */
    static public class Constraints extends Ast implements IConstraints
    {
        private IConstraints _Constraints;
        private IConstraint _Constraint;

        public IConstraints getConstraints() { return _Constraints; }
        public IConstraint getConstraint() { return _Constraint; }

        public Constraints(IToken leftIToken, IToken rightIToken,
                           IConstraints _Constraints,
                           IConstraint _Constraint)
        {
            super(leftIToken, rightIToken);

            this._Constraints = _Constraints;
            this._Constraint = _Constraint;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof Constraints)) return false;
            Constraints other = (Constraints    ) o;
            if (! _Constraints.equals(other.getConstraints())) return false;
            if (! _Constraint.equals(other.getConstraint())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getConstraints().hashCode());
            hash = hash * 31 + (getConstraint().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 675:  ConstructorConstraint ::= new ( )
     *</b>
     */
    static public class ConstructorConstraint extends Ast implements IConstructorConstraint
    {
        public ConstructorConstraint(IToken leftIToken, IToken rightIToken)
        {
            super(leftIToken, rightIToken);

            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ConstructorConstraint)) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 12:  BooleanLiteral ::= true
     *</b>
     */
    static public class BooleanLiteral0 extends AstToken implements IBooleanLiteral
    {
        public BooleanLiteral0(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 13:  BooleanLiteral ::= false
     *</b>
     */
    static public class BooleanLiteral1 extends AstToken implements IBooleanLiteral
    {
        public BooleanLiteral1(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 15:  Name ::= identifier TypeArgumentListOpt
     *</b>
     */
    static public class Name0 extends Ast implements IName
    {
        private TypeArgumentList _TypeArgumentListOpt;

        /**
         * The value returned by <b>getTypeArgumentListOpt</b> may be <b>null</b>
         */
        public TypeArgumentList getTypeArgumentListOpt() { return _TypeArgumentListOpt; }

        public Name0(IToken leftIToken, IToken rightIToken,
                     TypeArgumentList _TypeArgumentListOpt)
        {
            super(leftIToken, rightIToken);

            this._TypeArgumentListOpt = _TypeArgumentListOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof Name0)) return false;
            Name0 other = (Name0    ) o;
            if (_TypeArgumentListOpt == null && other.getTypeArgumentListOpt() != null) return false;
            else if (! _TypeArgumentListOpt.equals(other.getTypeArgumentListOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getTypeArgumentListOpt() == null ? 0 : getTypeArgumentListOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 16:  Name ::= Name . identifier TypeArgumentListOpt
     *</b>
     */
    static public class Name1 extends Ast implements IName
    {
        private IName _Name;
        private TypeArgumentList _TypeArgumentListOpt;

        public IName getName() { return _Name; }
        /**
         * The value returned by <b>getTypeArgumentListOpt</b> may be <b>null</b>
         */
        public TypeArgumentList getTypeArgumentListOpt() { return _TypeArgumentListOpt; }

        public Name1(IToken leftIToken, IToken rightIToken,
                     IName _Name,
                     TypeArgumentList _TypeArgumentListOpt)
        {
            super(leftIToken, rightIToken);

            this._Name = _Name;
            this._TypeArgumentListOpt = _TypeArgumentListOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof Name1)) return false;
            Name1 other = (Name1    ) o;
            if (! _Name.equals(other.getName())) return false;
            if (_TypeArgumentListOpt == null && other.getTypeArgumentListOpt() != null) return false;
            else if (! _TypeArgumentListOpt.equals(other.getTypeArgumentListOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getName().hashCode());
            hash = hash * 31 + (getTypeArgumentListOpt() == null ? 0 : getTypeArgumentListOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 17:  Name ::= Name :: identifier TypeArgumentListOpt
     *</b>
     */
    static public class Name2 extends Ast implements IName
    {
        private IName _Name;
        private TypeArgumentList _TypeArgumentListOpt;

        public IName getName() { return _Name; }
        /**
         * The value returned by <b>getTypeArgumentListOpt</b> may be <b>null</b>
         */
        public TypeArgumentList getTypeArgumentListOpt() { return _TypeArgumentListOpt; }

        public Name2(IToken leftIToken, IToken rightIToken,
                     IName _Name,
                     TypeArgumentList _TypeArgumentListOpt)
        {
            super(leftIToken, rightIToken);

            this._Name = _Name;
            this._TypeArgumentListOpt = _TypeArgumentListOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof Name2)) return false;
            Name2 other = (Name2    ) o;
            if (! _Name.equals(other.getName())) return false;
            if (_TypeArgumentListOpt == null && other.getTypeArgumentListOpt() != null) return false;
            else if (! _TypeArgumentListOpt.equals(other.getTypeArgumentListOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getName().hashCode());
            hash = hash * 31 + (getTypeArgumentListOpt() == null ? 0 : getTypeArgumentListOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 25:  NonNamedType ::= object
     *</b>
     */
    static public class NonNamedType0 extends AstToken implements INonNamedType
    {
        public NonNamedType0(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 26:  NonNamedType ::= string
     *</b>
     */
    static public class NonNamedType1 extends AstToken implements INonNamedType
    {
        public NonNamedType1(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 33:  IntegralType ::= sbyte
     *</b>
     */
    static public class IntegralType0 extends AstToken implements IIntegralType
    {
        public IntegralType0(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 34:  IntegralType ::= byte
     *</b>
     */
    static public class IntegralType1 extends AstToken implements IIntegralType
    {
        public IntegralType1(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 35:  IntegralType ::= short
     *</b>
     */
    static public class IntegralType2 extends AstToken implements IIntegralType
    {
        public IntegralType2(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 36:  IntegralType ::= ushort
     *</b>
     */
    static public class IntegralType3 extends AstToken implements IIntegralType
    {
        public IntegralType3(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 37:  IntegralType ::= int
     *</b>
     */
    static public class IntegralType4 extends AstToken implements IIntegralType
    {
        public IntegralType4(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 38:  IntegralType ::= uint
     *</b>
     */
    static public class IntegralType5 extends AstToken implements IIntegralType
    {
        public IntegralType5(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 39:  IntegralType ::= long
     *</b>
     */
    static public class IntegralType6 extends AstToken implements IIntegralType
    {
        public IntegralType6(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 40:  IntegralType ::= ulong
     *</b>
     */
    static public class IntegralType7 extends AstToken implements IIntegralType
    {
        public IntegralType7(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 41:  IntegralType ::= char
     *</b>
     */
    static public class IntegralType8 extends AstToken implements IIntegralType
    {
        public IntegralType8(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 42:  FloatingPointType ::= float
     *</b>
     */
    static public class FloatingPointType0 extends AstToken implements IFloatingPointType
    {
        public FloatingPointType0(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 43:  FloatingPointType ::= double
     *</b>
     */
    static public class FloatingPointType1 extends AstToken implements IFloatingPointType
    {
        public FloatingPointType1(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 46:  ClassType ::= object
     *</b>
     */
    static public class ClassType0 extends AstToken implements IClassType
    {
        public ClassType0(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 47:  ClassType ::= string
     *</b>
     */
    static public class ClassType1 extends AstToken implements IClassType
    {
        public ClassType1(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 54:  Argument ::= ref VariableReference
     *</b>
     */
    static public class Argument0 extends Ast implements IArgument
    {
        private IVariableReference _VariableReference;

        public IVariableReference getVariableReference() { return _VariableReference; }

        public Argument0(IToken leftIToken, IToken rightIToken,
                         IVariableReference _VariableReference)
        {
            super(leftIToken, rightIToken);

            this._VariableReference = _VariableReference;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof Argument0)) return false;
            Argument0 other = (Argument0    ) o;
            if (! _VariableReference.equals(other.getVariableReference())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getVariableReference().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 55:  Argument ::= out VariableReference
     *</b>
     */
    static public class Argument1 extends Ast implements IArgument
    {
        private IVariableReference _VariableReference;

        public IVariableReference getVariableReference() { return _VariableReference; }

        public Argument1(IToken leftIToken, IToken rightIToken,
                         IVariableReference _VariableReference)
        {
            super(leftIToken, rightIToken);

            this._VariableReference = _VariableReference;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof Argument1)) return false;
            Argument1 other = (Argument1    ) o;
            if (! _VariableReference.equals(other.getVariableReference())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getVariableReference().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 75:  MemberAccess ::= ArrayCreationExpression . identifier TypeArgumentListOpt
     *</b>
     */
    static public class MemberAccess0 extends Ast implements IMemberAccess
    {
        private IArrayCreationExpression _ArrayCreationExpression;
        private TypeArgumentList _TypeArgumentListOpt;

        public IArrayCreationExpression getArrayCreationExpression() { return _ArrayCreationExpression; }
        /**
         * The value returned by <b>getTypeArgumentListOpt</b> may be <b>null</b>
         */
        public TypeArgumentList getTypeArgumentListOpt() { return _TypeArgumentListOpt; }

        public MemberAccess0(IToken leftIToken, IToken rightIToken,
                             IArrayCreationExpression _ArrayCreationExpression,
                             TypeArgumentList _TypeArgumentListOpt)
        {
            super(leftIToken, rightIToken);

            this._ArrayCreationExpression = _ArrayCreationExpression;
            this._TypeArgumentListOpt = _TypeArgumentListOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof MemberAccess0)) return false;
            MemberAccess0 other = (MemberAccess0    ) o;
            if (! _ArrayCreationExpression.equals(other.getArrayCreationExpression())) return false;
            if (_TypeArgumentListOpt == null && other.getTypeArgumentListOpt() != null) return false;
            else if (! _TypeArgumentListOpt.equals(other.getTypeArgumentListOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getArrayCreationExpression().hashCode());
            hash = hash * 31 + (getTypeArgumentListOpt() == null ? 0 : getTypeArgumentListOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 76:  MemberAccess ::= PrimaryNoArrayCreationExpression . identifier TypeArgumentListOpt
     *</b>
     */
    static public class MemberAccess1 extends Ast implements IMemberAccess
    {
        private IPrimaryNoArrayCreationExpression _PrimaryNoArrayCreationExpression;
        private TypeArgumentList _TypeArgumentListOpt;

        public IPrimaryNoArrayCreationExpression getPrimaryNoArrayCreationExpression() { return _PrimaryNoArrayCreationExpression; }
        /**
         * The value returned by <b>getTypeArgumentListOpt</b> may be <b>null</b>
         */
        public TypeArgumentList getTypeArgumentListOpt() { return _TypeArgumentListOpt; }

        public MemberAccess1(IToken leftIToken, IToken rightIToken,
                             IPrimaryNoArrayCreationExpression _PrimaryNoArrayCreationExpression,
                             TypeArgumentList _TypeArgumentListOpt)
        {
            super(leftIToken, rightIToken);

            this._PrimaryNoArrayCreationExpression = _PrimaryNoArrayCreationExpression;
            this._TypeArgumentListOpt = _TypeArgumentListOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof MemberAccess1)) return false;
            MemberAccess1 other = (MemberAccess1    ) o;
            if (! _PrimaryNoArrayCreationExpression.equals(other.getPrimaryNoArrayCreationExpression())) return false;
            if (_TypeArgumentListOpt == null && other.getTypeArgumentListOpt() != null) return false;
            else if (! _TypeArgumentListOpt.equals(other.getTypeArgumentListOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getPrimaryNoArrayCreationExpression().hashCode());
            hash = hash * 31 + (getTypeArgumentListOpt() == null ? 0 : getTypeArgumentListOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 77:  MemberAccess ::= PredefinedType . identifier TypeArgumentListOpt
     *</b>
     */
    static public class MemberAccess2 extends Ast implements IMemberAccess
    {
        private IPredefinedType _PredefinedType;
        private TypeArgumentList _TypeArgumentListOpt;

        public IPredefinedType getPredefinedType() { return _PredefinedType; }
        /**
         * The value returned by <b>getTypeArgumentListOpt</b> may be <b>null</b>
         */
        public TypeArgumentList getTypeArgumentListOpt() { return _TypeArgumentListOpt; }

        public MemberAccess2(IToken leftIToken, IToken rightIToken,
                             IPredefinedType _PredefinedType,
                             TypeArgumentList _TypeArgumentListOpt)
        {
            super(leftIToken, rightIToken);

            this._PredefinedType = _PredefinedType;
            this._TypeArgumentListOpt = _TypeArgumentListOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof MemberAccess2)) return false;
            MemberAccess2 other = (MemberAccess2    ) o;
            if (! _PredefinedType.equals(other.getPredefinedType())) return false;
            if (_TypeArgumentListOpt == null && other.getTypeArgumentListOpt() != null) return false;
            else if (! _TypeArgumentListOpt.equals(other.getTypeArgumentListOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getPredefinedType().hashCode());
            hash = hash * 31 + (getTypeArgumentListOpt() == null ? 0 : getTypeArgumentListOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 78:  PredefinedType ::= bool
     *</b>
     */
    static public class PredefinedType0 extends AstToken implements IPredefinedType
    {
        public PredefinedType0(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 79:  PredefinedType ::= byte
     *</b>
     */
    static public class PredefinedType1 extends AstToken implements IPredefinedType
    {
        public PredefinedType1(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 80:  PredefinedType ::= char
     *</b>
     */
    static public class PredefinedType2 extends AstToken implements IPredefinedType
    {
        public PredefinedType2(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 81:  PredefinedType ::= decimal
     *</b>
     */
    static public class PredefinedType3 extends AstToken implements IPredefinedType
    {
        public PredefinedType3(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 82:  PredefinedType ::= double
     *</b>
     */
    static public class PredefinedType4 extends AstToken implements IPredefinedType
    {
        public PredefinedType4(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 83:  PredefinedType ::= float
     *</b>
     */
    static public class PredefinedType5 extends AstToken implements IPredefinedType
    {
        public PredefinedType5(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 84:  PredefinedType ::= int
     *</b>
     */
    static public class PredefinedType6 extends AstToken implements IPredefinedType
    {
        public PredefinedType6(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 85:  PredefinedType ::= long
     *</b>
     */
    static public class PredefinedType7 extends AstToken implements IPredefinedType
    {
        public PredefinedType7(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 86:  PredefinedType ::= object
     *</b>
     */
    static public class PredefinedType8 extends AstToken implements IPredefinedType
    {
        public PredefinedType8(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 87:  PredefinedType ::= sbyte
     *</b>
     */
    static public class PredefinedType9 extends AstToken implements IPredefinedType
    {
        public PredefinedType9(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 88:  PredefinedType ::= short
     *</b>
     */
    static public class PredefinedType10 extends AstToken implements IPredefinedType
    {
        public PredefinedType10(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 89:  PredefinedType ::= string
     *</b>
     */
    static public class PredefinedType11 extends AstToken implements IPredefinedType
    {
        public PredefinedType11(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 90:  PredefinedType ::= uint
     *</b>
     */
    static public class PredefinedType12 extends AstToken implements IPredefinedType
    {
        public PredefinedType12(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 91:  PredefinedType ::= ulong
     *</b>
     */
    static public class PredefinedType13 extends AstToken implements IPredefinedType
    {
        public PredefinedType13(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 92:  PredefinedType ::= ushort
     *</b>
     */
    static public class PredefinedType14 extends AstToken implements IPredefinedType
    {
        public PredefinedType14(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 98:  BaseAccess ::= base . identifier TypeArgumentListOpt
     *</b>
     */
    static public class BaseAccess0 extends Ast implements IBaseAccess
    {
        private TypeArgumentList _TypeArgumentListOpt;

        /**
         * The value returned by <b>getTypeArgumentListOpt</b> may be <b>null</b>
         */
        public TypeArgumentList getTypeArgumentListOpt() { return _TypeArgumentListOpt; }

        public BaseAccess0(IToken leftIToken, IToken rightIToken,
                           TypeArgumentList _TypeArgumentListOpt)
        {
            super(leftIToken, rightIToken);

            this._TypeArgumentListOpt = _TypeArgumentListOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof BaseAccess0)) return false;
            BaseAccess0 other = (BaseAccess0    ) o;
            if (_TypeArgumentListOpt == null && other.getTypeArgumentListOpt() != null) return false;
            else if (! _TypeArgumentListOpt.equals(other.getTypeArgumentListOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getTypeArgumentListOpt() == null ? 0 : getTypeArgumentListOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 99:  BaseAccess ::= base [ ExpressionList ]
     *</b>
     */
    static public class BaseAccess1 extends Ast implements IBaseAccess
    {
        private IExpressionList _ExpressionList;

        public IExpressionList getExpressionList() { return _ExpressionList; }

        public BaseAccess1(IToken leftIToken, IToken rightIToken,
                           IExpressionList _ExpressionList)
        {
            super(leftIToken, rightIToken);

            this._ExpressionList = _ExpressionList;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof BaseAccess1)) return false;
            BaseAccess1 other = (BaseAccess1    ) o;
            if (! _ExpressionList.equals(other.getExpressionList())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getExpressionList().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 103:  ArrayCreationExpression ::= new NonArrayType [ ExpressionList ] RankSpecifiersOpt ArrayInitializerOpt
     *</b>
     */
    static public class ArrayCreationExpression0 extends Ast implements IArrayCreationExpression
    {
        private INonArrayType _NonArrayType;
        private IExpressionList _ExpressionList;
        private IRankSpecifiersOpt _RankSpecifiersOpt;
        private IArrayInitializerOpt _ArrayInitializerOpt;

        public INonArrayType getNonArrayType() { return _NonArrayType; }
        public IExpressionList getExpressionList() { return _ExpressionList; }
        /**
         * The value returned by <b>getRankSpecifiersOpt</b> may be <b>null</b>
         */
        public IRankSpecifiersOpt getRankSpecifiersOpt() { return _RankSpecifiersOpt; }
        /**
         * The value returned by <b>getArrayInitializerOpt</b> may be <b>null</b>
         */
        public IArrayInitializerOpt getArrayInitializerOpt() { return _ArrayInitializerOpt; }

        public ArrayCreationExpression0(IToken leftIToken, IToken rightIToken,
                                        INonArrayType _NonArrayType,
                                        IExpressionList _ExpressionList,
                                        IRankSpecifiersOpt _RankSpecifiersOpt,
                                        IArrayInitializerOpt _ArrayInitializerOpt)
        {
            super(leftIToken, rightIToken);

            this._NonArrayType = _NonArrayType;
            this._ExpressionList = _ExpressionList;
            this._RankSpecifiersOpt = _RankSpecifiersOpt;
            this._ArrayInitializerOpt = _ArrayInitializerOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ArrayCreationExpression0)) return false;
            ArrayCreationExpression0 other = (ArrayCreationExpression0    ) o;
            if (! _NonArrayType.equals(other.getNonArrayType())) return false;
            if (! _ExpressionList.equals(other.getExpressionList())) return false;
            if (_RankSpecifiersOpt == null && other.getRankSpecifiersOpt() != null) return false;
            else if (! _RankSpecifiersOpt.equals(other.getRankSpecifiersOpt())) return false;
            if (_ArrayInitializerOpt == null && other.getArrayInitializerOpt() != null) return false;
            else if (! _ArrayInitializerOpt.equals(other.getArrayInitializerOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getNonArrayType().hashCode());
            hash = hash * 31 + (getExpressionList().hashCode());
            hash = hash * 31 + (getRankSpecifiersOpt() == null ? 0 : getRankSpecifiersOpt().hashCode());
            hash = hash * 31 + (getArrayInitializerOpt() == null ? 0 : getArrayInitializerOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 104:  ArrayCreationExpression ::= new ArrayType ArrayInitializer
     *</b>
     */
    static public class ArrayCreationExpression1 extends Ast implements IArrayCreationExpression
    {
        private ArrayType _ArrayType;
        private IArrayInitializer _ArrayInitializer;

        public ArrayType getArrayType() { return _ArrayType; }
        public IArrayInitializer getArrayInitializer() { return _ArrayInitializer; }

        public ArrayCreationExpression1(IToken leftIToken, IToken rightIToken,
                                        ArrayType _ArrayType,
                                        IArrayInitializer _ArrayInitializer)
        {
            super(leftIToken, rightIToken);

            this._ArrayType = _ArrayType;
            this._ArrayInitializer = _ArrayInitializer;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ArrayCreationExpression1)) return false;
            ArrayCreationExpression1 other = (ArrayCreationExpression1    ) o;
            if (! _ArrayType.equals(other.getArrayType())) return false;
            if (! _ArrayInitializer.equals(other.getArrayInitializer())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getArrayType().hashCode());
            hash = hash * 31 + (getArrayInitializer().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 105:  TypeofExpression ::= typeof ( Type )
     *</b>
     */
    static public class TypeofExpression0 extends Ast implements ITypeofExpression
    {
        private IType _Type;

        public IType getType() { return _Type; }

        public TypeofExpression0(IToken leftIToken, IToken rightIToken,
                                 IType _Type)
        {
            super(leftIToken, rightIToken);

            this._Type = _Type;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof TypeofExpression0)) return false;
            TypeofExpression0 other = (TypeofExpression0    ) o;
            if (! _Type.equals(other.getType())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getType().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 106:  TypeofExpression ::= typeof ( UnboundTypeName )
     *</b>
     */
    static public class TypeofExpression1 extends Ast implements ITypeofExpression
    {
        private IUnboundTypeName _UnboundTypeName;

        public IUnboundTypeName getUnboundTypeName() { return _UnboundTypeName; }

        public TypeofExpression1(IToken leftIToken, IToken rightIToken,
                                 IUnboundTypeName _UnboundTypeName)
        {
            super(leftIToken, rightIToken);

            this._UnboundTypeName = _UnboundTypeName;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof TypeofExpression1)) return false;
            TypeofExpression1 other = (TypeofExpression1    ) o;
            if (! _UnboundTypeName.equals(other.getUnboundTypeName())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getUnboundTypeName().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 107:  UnboundTypeName ::= identifier GenericDimensionSpecifierOpt
     *</b>
     */
    static public class UnboundTypeName0 extends Ast implements IUnboundTypeName
    {
        private GenericDimensionSpecifier _GenericDimensionSpecifierOpt;

        /**
         * The value returned by <b>getGenericDimensionSpecifierOpt</b> may be <b>null</b>
         */
        public GenericDimensionSpecifier getGenericDimensionSpecifierOpt() { return _GenericDimensionSpecifierOpt; }

        public UnboundTypeName0(IToken leftIToken, IToken rightIToken,
                                GenericDimensionSpecifier _GenericDimensionSpecifierOpt)
        {
            super(leftIToken, rightIToken);

            this._GenericDimensionSpecifierOpt = _GenericDimensionSpecifierOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof UnboundTypeName0)) return false;
            UnboundTypeName0 other = (UnboundTypeName0    ) o;
            if (_GenericDimensionSpecifierOpt == null && other.getGenericDimensionSpecifierOpt() != null) return false;
            else if (! _GenericDimensionSpecifierOpt.equals(other.getGenericDimensionSpecifierOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getGenericDimensionSpecifierOpt() == null ? 0 : getGenericDimensionSpecifierOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 108:  UnboundTypeName ::= identifier :: identifier GenericDimensionSpecifierOpt
     *</b>
     */
    static public class UnboundTypeName1 extends Ast implements IUnboundTypeName
    {
        private GenericDimensionSpecifier _GenericDimensionSpecifierOpt;

        /**
         * The value returned by <b>getGenericDimensionSpecifierOpt</b> may be <b>null</b>
         */
        public GenericDimensionSpecifier getGenericDimensionSpecifierOpt() { return _GenericDimensionSpecifierOpt; }

        public UnboundTypeName1(IToken leftIToken, IToken rightIToken,
                                GenericDimensionSpecifier _GenericDimensionSpecifierOpt)
        {
            super(leftIToken, rightIToken);

            this._GenericDimensionSpecifierOpt = _GenericDimensionSpecifierOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof UnboundTypeName1)) return false;
            UnboundTypeName1 other = (UnboundTypeName1    ) o;
            if (_GenericDimensionSpecifierOpt == null && other.getGenericDimensionSpecifierOpt() != null) return false;
            else if (! _GenericDimensionSpecifierOpt.equals(other.getGenericDimensionSpecifierOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getGenericDimensionSpecifierOpt() == null ? 0 : getGenericDimensionSpecifierOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 109:  UnboundTypeName ::= UnboundTypeName . identifier GenericDimensionSpecifierOpt
     *</b>
     */
    static public class UnboundTypeName2 extends Ast implements IUnboundTypeName
    {
        private IUnboundTypeName _UnboundTypeName;
        private GenericDimensionSpecifier _GenericDimensionSpecifierOpt;

        public IUnboundTypeName getUnboundTypeName() { return _UnboundTypeName; }
        /**
         * The value returned by <b>getGenericDimensionSpecifierOpt</b> may be <b>null</b>
         */
        public GenericDimensionSpecifier getGenericDimensionSpecifierOpt() { return _GenericDimensionSpecifierOpt; }

        public UnboundTypeName2(IToken leftIToken, IToken rightIToken,
                                IUnboundTypeName _UnboundTypeName,
                                GenericDimensionSpecifier _GenericDimensionSpecifierOpt)
        {
            super(leftIToken, rightIToken);

            this._UnboundTypeName = _UnboundTypeName;
            this._GenericDimensionSpecifierOpt = _GenericDimensionSpecifierOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof UnboundTypeName2)) return false;
            UnboundTypeName2 other = (UnboundTypeName2    ) o;
            if (! _UnboundTypeName.equals(other.getUnboundTypeName())) return false;
            if (_GenericDimensionSpecifierOpt == null && other.getGenericDimensionSpecifierOpt() != null) return false;
            else if (! _GenericDimensionSpecifierOpt.equals(other.getGenericDimensionSpecifierOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getUnboundTypeName().hashCode());
            hash = hash * 31 + (getGenericDimensionSpecifierOpt() == null ? 0 : getGenericDimensionSpecifierOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 115:  Commas ::= ,
     *</b>
     */
    static public class Commas0 extends AstToken implements ICommas
    {
        public Commas0(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 116:  Commas ::= Commas ,
     *</b>
     */
    static public class Commas1 extends Ast implements ICommas
    {
        private ICommas _Commas;

        public ICommas getCommas() { return _Commas; }

        public Commas1(IToken leftIToken, IToken rightIToken,
                       ICommas _Commas)
        {
            super(leftIToken, rightIToken);

            this._Commas = _Commas;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof Commas1)) return false;
            Commas1 other = (Commas1    ) o;
            if (! _Commas.equals(other.getCommas())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getCommas().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 130:  UnaryExpression ::= + UnaryExpression
     *</b>
     */
    static public class UnaryExpression0 extends Ast implements IUnaryExpression
    {
        private IUnaryExpression _UnaryExpression;

        public IUnaryExpression getUnaryExpression() { return _UnaryExpression; }

        public UnaryExpression0(IToken leftIToken, IToken rightIToken,
                                IUnaryExpression _UnaryExpression)
        {
            super(leftIToken, rightIToken);

            this._UnaryExpression = _UnaryExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof UnaryExpression0)) return false;
            UnaryExpression0 other = (UnaryExpression0    ) o;
            if (! _UnaryExpression.equals(other.getUnaryExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getUnaryExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 131:  UnaryExpression ::= - UnaryExpression
     *</b>
     */
    static public class UnaryExpression1 extends Ast implements IUnaryExpression
    {
        private IUnaryExpression _UnaryExpression;

        public IUnaryExpression getUnaryExpression() { return _UnaryExpression; }

        public UnaryExpression1(IToken leftIToken, IToken rightIToken,
                                IUnaryExpression _UnaryExpression)
        {
            super(leftIToken, rightIToken);

            this._UnaryExpression = _UnaryExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof UnaryExpression1)) return false;
            UnaryExpression1 other = (UnaryExpression1    ) o;
            if (! _UnaryExpression.equals(other.getUnaryExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getUnaryExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 132:  UnaryExpression ::= ! UnaryExpression
     *</b>
     */
    static public class UnaryExpression2 extends Ast implements IUnaryExpression
    {
        private IUnaryExpression _UnaryExpression;

        public IUnaryExpression getUnaryExpression() { return _UnaryExpression; }

        public UnaryExpression2(IToken leftIToken, IToken rightIToken,
                                IUnaryExpression _UnaryExpression)
        {
            super(leftIToken, rightIToken);

            this._UnaryExpression = _UnaryExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof UnaryExpression2)) return false;
            UnaryExpression2 other = (UnaryExpression2    ) o;
            if (! _UnaryExpression.equals(other.getUnaryExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getUnaryExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 133:  UnaryExpression ::= ~ UnaryExpression
     *</b>
     */
    static public class UnaryExpression3 extends Ast implements IUnaryExpression
    {
        private IUnaryExpression _UnaryExpression;

        public IUnaryExpression getUnaryExpression() { return _UnaryExpression; }

        public UnaryExpression3(IToken leftIToken, IToken rightIToken,
                                IUnaryExpression _UnaryExpression)
        {
            super(leftIToken, rightIToken);

            this._UnaryExpression = _UnaryExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof UnaryExpression3)) return false;
            UnaryExpression3 other = (UnaryExpression3    ) o;
            if (! _UnaryExpression.equals(other.getUnaryExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getUnaryExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 141:  MultiplicativeExpression ::= MultiplicativeExpression * UnaryExpression
     *</b>
     */
    static public class MultiplicativeExpression0 extends Ast implements IMultiplicativeExpression
    {
        private IMultiplicativeExpression _MultiplicativeExpression;
        private IUnaryExpression _UnaryExpression;

        public IMultiplicativeExpression getMultiplicativeExpression() { return _MultiplicativeExpression; }
        public IUnaryExpression getUnaryExpression() { return _UnaryExpression; }

        public MultiplicativeExpression0(IToken leftIToken, IToken rightIToken,
                                         IMultiplicativeExpression _MultiplicativeExpression,
                                         IUnaryExpression _UnaryExpression)
        {
            super(leftIToken, rightIToken);

            this._MultiplicativeExpression = _MultiplicativeExpression;
            this._UnaryExpression = _UnaryExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof MultiplicativeExpression0)) return false;
            MultiplicativeExpression0 other = (MultiplicativeExpression0    ) o;
            if (! _MultiplicativeExpression.equals(other.getMultiplicativeExpression())) return false;
            if (! _UnaryExpression.equals(other.getUnaryExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getMultiplicativeExpression().hashCode());
            hash = hash * 31 + (getUnaryExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 142:  MultiplicativeExpression ::= MultiplicativeExpression / UnaryExpression
     *</b>
     */
    static public class MultiplicativeExpression1 extends Ast implements IMultiplicativeExpression
    {
        private IMultiplicativeExpression _MultiplicativeExpression;
        private IUnaryExpression _UnaryExpression;

        public IMultiplicativeExpression getMultiplicativeExpression() { return _MultiplicativeExpression; }
        public IUnaryExpression getUnaryExpression() { return _UnaryExpression; }

        public MultiplicativeExpression1(IToken leftIToken, IToken rightIToken,
                                         IMultiplicativeExpression _MultiplicativeExpression,
                                         IUnaryExpression _UnaryExpression)
        {
            super(leftIToken, rightIToken);

            this._MultiplicativeExpression = _MultiplicativeExpression;
            this._UnaryExpression = _UnaryExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof MultiplicativeExpression1)) return false;
            MultiplicativeExpression1 other = (MultiplicativeExpression1    ) o;
            if (! _MultiplicativeExpression.equals(other.getMultiplicativeExpression())) return false;
            if (! _UnaryExpression.equals(other.getUnaryExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getMultiplicativeExpression().hashCode());
            hash = hash * 31 + (getUnaryExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 143:  MultiplicativeExpression ::= MultiplicativeExpression % UnaryExpression
     *</b>
     */
    static public class MultiplicativeExpression2 extends Ast implements IMultiplicativeExpression
    {
        private IMultiplicativeExpression _MultiplicativeExpression;
        private IUnaryExpression _UnaryExpression;

        public IMultiplicativeExpression getMultiplicativeExpression() { return _MultiplicativeExpression; }
        public IUnaryExpression getUnaryExpression() { return _UnaryExpression; }

        public MultiplicativeExpression2(IToken leftIToken, IToken rightIToken,
                                         IMultiplicativeExpression _MultiplicativeExpression,
                                         IUnaryExpression _UnaryExpression)
        {
            super(leftIToken, rightIToken);

            this._MultiplicativeExpression = _MultiplicativeExpression;
            this._UnaryExpression = _UnaryExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof MultiplicativeExpression2)) return false;
            MultiplicativeExpression2 other = (MultiplicativeExpression2    ) o;
            if (! _MultiplicativeExpression.equals(other.getMultiplicativeExpression())) return false;
            if (! _UnaryExpression.equals(other.getUnaryExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getMultiplicativeExpression().hashCode());
            hash = hash * 31 + (getUnaryExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 145:  AdditiveExpression ::= AdditiveExpression + MultiplicativeExpression
     *</b>
     */
    static public class AdditiveExpression0 extends Ast implements IAdditiveExpression
    {
        private IAdditiveExpression _AdditiveExpression;
        private IMultiplicativeExpression _MultiplicativeExpression;

        public IAdditiveExpression getAdditiveExpression() { return _AdditiveExpression; }
        public IMultiplicativeExpression getMultiplicativeExpression() { return _MultiplicativeExpression; }

        public AdditiveExpression0(IToken leftIToken, IToken rightIToken,
                                   IAdditiveExpression _AdditiveExpression,
                                   IMultiplicativeExpression _MultiplicativeExpression)
        {
            super(leftIToken, rightIToken);

            this._AdditiveExpression = _AdditiveExpression;
            this._MultiplicativeExpression = _MultiplicativeExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AdditiveExpression0)) return false;
            AdditiveExpression0 other = (AdditiveExpression0    ) o;
            if (! _AdditiveExpression.equals(other.getAdditiveExpression())) return false;
            if (! _MultiplicativeExpression.equals(other.getMultiplicativeExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAdditiveExpression().hashCode());
            hash = hash * 31 + (getMultiplicativeExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 146:  AdditiveExpression ::= AdditiveExpression - MultiplicativeExpression
     *</b>
     */
    static public class AdditiveExpression1 extends Ast implements IAdditiveExpression
    {
        private IAdditiveExpression _AdditiveExpression;
        private IMultiplicativeExpression _MultiplicativeExpression;

        public IAdditiveExpression getAdditiveExpression() { return _AdditiveExpression; }
        public IMultiplicativeExpression getMultiplicativeExpression() { return _MultiplicativeExpression; }

        public AdditiveExpression1(IToken leftIToken, IToken rightIToken,
                                   IAdditiveExpression _AdditiveExpression,
                                   IMultiplicativeExpression _MultiplicativeExpression)
        {
            super(leftIToken, rightIToken);

            this._AdditiveExpression = _AdditiveExpression;
            this._MultiplicativeExpression = _MultiplicativeExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AdditiveExpression1)) return false;
            AdditiveExpression1 other = (AdditiveExpression1    ) o;
            if (! _AdditiveExpression.equals(other.getAdditiveExpression())) return false;
            if (! _MultiplicativeExpression.equals(other.getMultiplicativeExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAdditiveExpression().hashCode());
            hash = hash * 31 + (getMultiplicativeExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 148:  ShiftExpression ::= ShiftExpression << AdditiveExpression
     *</b>
     */
    static public class ShiftExpression0 extends Ast implements IShiftExpression
    {
        private IShiftExpression _ShiftExpression;
        private IAdditiveExpression _AdditiveExpression;

        public IShiftExpression getShiftExpression() { return _ShiftExpression; }
        public IAdditiveExpression getAdditiveExpression() { return _AdditiveExpression; }

        public ShiftExpression0(IToken leftIToken, IToken rightIToken,
                                IShiftExpression _ShiftExpression,
                                IAdditiveExpression _AdditiveExpression)
        {
            super(leftIToken, rightIToken);

            this._ShiftExpression = _ShiftExpression;
            this._AdditiveExpression = _AdditiveExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ShiftExpression0)) return false;
            ShiftExpression0 other = (ShiftExpression0    ) o;
            if (! _ShiftExpression.equals(other.getShiftExpression())) return false;
            if (! _AdditiveExpression.equals(other.getAdditiveExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getShiftExpression().hashCode());
            hash = hash * 31 + (getAdditiveExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 149:  ShiftExpression ::= ShiftExpression >> AdditiveExpression
     *</b>
     */
    static public class ShiftExpression1 extends Ast implements IShiftExpression
    {
        private IShiftExpression _ShiftExpression;
        private IAdditiveExpression _AdditiveExpression;

        public IShiftExpression getShiftExpression() { return _ShiftExpression; }
        public IAdditiveExpression getAdditiveExpression() { return _AdditiveExpression; }

        public ShiftExpression1(IToken leftIToken, IToken rightIToken,
                                IShiftExpression _ShiftExpression,
                                IAdditiveExpression _AdditiveExpression)
        {
            super(leftIToken, rightIToken);

            this._ShiftExpression = _ShiftExpression;
            this._AdditiveExpression = _AdditiveExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ShiftExpression1)) return false;
            ShiftExpression1 other = (ShiftExpression1    ) o;
            if (! _ShiftExpression.equals(other.getShiftExpression())) return false;
            if (! _AdditiveExpression.equals(other.getAdditiveExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getShiftExpression().hashCode());
            hash = hash * 31 + (getAdditiveExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 151:  RelationalExpression ::= RelationalExpression < ShiftExpression
     *</b>
     */
    static public class RelationalExpression0 extends Ast implements IRelationalExpression
    {
        private IRelationalExpression _RelationalExpression;
        private IShiftExpression _ShiftExpression;

        public IRelationalExpression getRelationalExpression() { return _RelationalExpression; }
        public IShiftExpression getShiftExpression() { return _ShiftExpression; }

        public RelationalExpression0(IToken leftIToken, IToken rightIToken,
                                     IRelationalExpression _RelationalExpression,
                                     IShiftExpression _ShiftExpression)
        {
            super(leftIToken, rightIToken);

            this._RelationalExpression = _RelationalExpression;
            this._ShiftExpression = _ShiftExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof RelationalExpression0)) return false;
            RelationalExpression0 other = (RelationalExpression0    ) o;
            if (! _RelationalExpression.equals(other.getRelationalExpression())) return false;
            if (! _ShiftExpression.equals(other.getShiftExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getRelationalExpression().hashCode());
            hash = hash * 31 + (getShiftExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 152:  RelationalExpression ::= RelationalExpression > ShiftExpression
     *</b>
     */
    static public class RelationalExpression1 extends Ast implements IRelationalExpression
    {
        private IRelationalExpression _RelationalExpression;
        private IShiftExpression _ShiftExpression;

        public IRelationalExpression getRelationalExpression() { return _RelationalExpression; }
        public IShiftExpression getShiftExpression() { return _ShiftExpression; }

        public RelationalExpression1(IToken leftIToken, IToken rightIToken,
                                     IRelationalExpression _RelationalExpression,
                                     IShiftExpression _ShiftExpression)
        {
            super(leftIToken, rightIToken);

            this._RelationalExpression = _RelationalExpression;
            this._ShiftExpression = _ShiftExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof RelationalExpression1)) return false;
            RelationalExpression1 other = (RelationalExpression1    ) o;
            if (! _RelationalExpression.equals(other.getRelationalExpression())) return false;
            if (! _ShiftExpression.equals(other.getShiftExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getRelationalExpression().hashCode());
            hash = hash * 31 + (getShiftExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 153:  RelationalExpression ::= RelationalExpression <= ShiftExpression
     *</b>
     */
    static public class RelationalExpression2 extends Ast implements IRelationalExpression
    {
        private IRelationalExpression _RelationalExpression;
        private IShiftExpression _ShiftExpression;

        public IRelationalExpression getRelationalExpression() { return _RelationalExpression; }
        public IShiftExpression getShiftExpression() { return _ShiftExpression; }

        public RelationalExpression2(IToken leftIToken, IToken rightIToken,
                                     IRelationalExpression _RelationalExpression,
                                     IShiftExpression _ShiftExpression)
        {
            super(leftIToken, rightIToken);

            this._RelationalExpression = _RelationalExpression;
            this._ShiftExpression = _ShiftExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof RelationalExpression2)) return false;
            RelationalExpression2 other = (RelationalExpression2    ) o;
            if (! _RelationalExpression.equals(other.getRelationalExpression())) return false;
            if (! _ShiftExpression.equals(other.getShiftExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getRelationalExpression().hashCode());
            hash = hash * 31 + (getShiftExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 154:  RelationalExpression ::= RelationalExpression >= ShiftExpression
     *</b>
     */
    static public class RelationalExpression3 extends Ast implements IRelationalExpression
    {
        private IRelationalExpression _RelationalExpression;
        private IShiftExpression _ShiftExpression;

        public IRelationalExpression getRelationalExpression() { return _RelationalExpression; }
        public IShiftExpression getShiftExpression() { return _ShiftExpression; }

        public RelationalExpression3(IToken leftIToken, IToken rightIToken,
                                     IRelationalExpression _RelationalExpression,
                                     IShiftExpression _ShiftExpression)
        {
            super(leftIToken, rightIToken);

            this._RelationalExpression = _RelationalExpression;
            this._ShiftExpression = _ShiftExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof RelationalExpression3)) return false;
            RelationalExpression3 other = (RelationalExpression3    ) o;
            if (! _RelationalExpression.equals(other.getRelationalExpression())) return false;
            if (! _ShiftExpression.equals(other.getShiftExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getRelationalExpression().hashCode());
            hash = hash * 31 + (getShiftExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 155:  RelationalExpression ::= RelationalExpression is Type
     *</b>
     */
    static public class RelationalExpression4 extends Ast implements IRelationalExpression
    {
        private IRelationalExpression _RelationalExpression;
        private IType _Type;

        public IRelationalExpression getRelationalExpression() { return _RelationalExpression; }
        public IType getType() { return _Type; }

        public RelationalExpression4(IToken leftIToken, IToken rightIToken,
                                     IRelationalExpression _RelationalExpression,
                                     IType _Type)
        {
            super(leftIToken, rightIToken);

            this._RelationalExpression = _RelationalExpression;
            this._Type = _Type;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof RelationalExpression4)) return false;
            RelationalExpression4 other = (RelationalExpression4    ) o;
            if (! _RelationalExpression.equals(other.getRelationalExpression())) return false;
            if (! _Type.equals(other.getType())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getRelationalExpression().hashCode());
            hash = hash * 31 + (getType().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 156:  RelationalExpression ::= RelationalExpression as Type
     *</b>
     */
    static public class RelationalExpression5 extends Ast implements IRelationalExpression
    {
        private IRelationalExpression _RelationalExpression;
        private IType _Type;

        public IRelationalExpression getRelationalExpression() { return _RelationalExpression; }
        public IType getType() { return _Type; }

        public RelationalExpression5(IToken leftIToken, IToken rightIToken,
                                     IRelationalExpression _RelationalExpression,
                                     IType _Type)
        {
            super(leftIToken, rightIToken);

            this._RelationalExpression = _RelationalExpression;
            this._Type = _Type;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof RelationalExpression5)) return false;
            RelationalExpression5 other = (RelationalExpression5    ) o;
            if (! _RelationalExpression.equals(other.getRelationalExpression())) return false;
            if (! _Type.equals(other.getType())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getRelationalExpression().hashCode());
            hash = hash * 31 + (getType().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 158:  EqualityExpression ::= EqualityExpression == RelationalExpression
     *</b>
     */
    static public class EqualityExpression0 extends Ast implements IEqualityExpression
    {
        private IEqualityExpression _EqualityExpression;
        private IRelationalExpression _RelationalExpression;

        public IEqualityExpression getEqualityExpression() { return _EqualityExpression; }
        public IRelationalExpression getRelationalExpression() { return _RelationalExpression; }

        public EqualityExpression0(IToken leftIToken, IToken rightIToken,
                                   IEqualityExpression _EqualityExpression,
                                   IRelationalExpression _RelationalExpression)
        {
            super(leftIToken, rightIToken);

            this._EqualityExpression = _EqualityExpression;
            this._RelationalExpression = _RelationalExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof EqualityExpression0)) return false;
            EqualityExpression0 other = (EqualityExpression0    ) o;
            if (! _EqualityExpression.equals(other.getEqualityExpression())) return false;
            if (! _RelationalExpression.equals(other.getRelationalExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getEqualityExpression().hashCode());
            hash = hash * 31 + (getRelationalExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 159:  EqualityExpression ::= EqualityExpression != RelationalExpression
     *</b>
     */
    static public class EqualityExpression1 extends Ast implements IEqualityExpression
    {
        private IEqualityExpression _EqualityExpression;
        private IRelationalExpression _RelationalExpression;

        public IEqualityExpression getEqualityExpression() { return _EqualityExpression; }
        public IRelationalExpression getRelationalExpression() { return _RelationalExpression; }

        public EqualityExpression1(IToken leftIToken, IToken rightIToken,
                                   IEqualityExpression _EqualityExpression,
                                   IRelationalExpression _RelationalExpression)
        {
            super(leftIToken, rightIToken);

            this._EqualityExpression = _EqualityExpression;
            this._RelationalExpression = _RelationalExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof EqualityExpression1)) return false;
            EqualityExpression1 other = (EqualityExpression1    ) o;
            if (! _EqualityExpression.equals(other.getEqualityExpression())) return false;
            if (! _RelationalExpression.equals(other.getRelationalExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getEqualityExpression().hashCode());
            hash = hash * 31 + (getRelationalExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 175:  AssignmentOperator ::= =
     *</b>
     */
    static public class AssignmentOperator0 extends AstToken implements IAssignmentOperator
    {
        public AssignmentOperator0(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 176:  AssignmentOperator ::= +=
     *</b>
     */
    static public class AssignmentOperator1 extends AstToken implements IAssignmentOperator
    {
        public AssignmentOperator1(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 177:  AssignmentOperator ::= -=
     *</b>
     */
    static public class AssignmentOperator2 extends AstToken implements IAssignmentOperator
    {
        public AssignmentOperator2(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 178:  AssignmentOperator ::= *=
     *</b>
     */
    static public class AssignmentOperator3 extends AstToken implements IAssignmentOperator
    {
        public AssignmentOperator3(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 179:  AssignmentOperator ::= /=
     *</b>
     */
    static public class AssignmentOperator4 extends AstToken implements IAssignmentOperator
    {
        public AssignmentOperator4(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 180:  AssignmentOperator ::= %=
     *</b>
     */
    static public class AssignmentOperator5 extends AstToken implements IAssignmentOperator
    {
        public AssignmentOperator5(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 181:  AssignmentOperator ::= &=
     *</b>
     */
    static public class AssignmentOperator6 extends AstToken implements IAssignmentOperator
    {
        public AssignmentOperator6(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 182:  AssignmentOperator ::= |=
     *</b>
     */
    static public class AssignmentOperator7 extends AstToken implements IAssignmentOperator
    {
        public AssignmentOperator7(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 183:  AssignmentOperator ::= ^=
     *</b>
     */
    static public class AssignmentOperator8 extends AstToken implements IAssignmentOperator
    {
        public AssignmentOperator8(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 184:  AssignmentOperator ::= <<=
     *</b>
     */
    static public class AssignmentOperator9 extends AstToken implements IAssignmentOperator
    {
        public AssignmentOperator9(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 185:  AssignmentOperator ::= >>=
     *</b>
     */
    static public class AssignmentOperator10 extends AstToken implements IAssignmentOperator
    {
        public AssignmentOperator10(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 214:  DeclarationStatement ::= LocalVariableDeclaration ;
     *</b>
     */
    static public class DeclarationStatement0 extends Ast implements IDeclarationStatement
    {
        private LocalVariableDeclaration _LocalVariableDeclaration;

        public LocalVariableDeclaration getLocalVariableDeclaration() { return _LocalVariableDeclaration; }

        public DeclarationStatement0(IToken leftIToken, IToken rightIToken,
                                     LocalVariableDeclaration _LocalVariableDeclaration)
        {
            super(leftIToken, rightIToken);

            this._LocalVariableDeclaration = _LocalVariableDeclaration;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof DeclarationStatement0)) return false;
            DeclarationStatement0 other = (DeclarationStatement0    ) o;
            if (! _LocalVariableDeclaration.equals(other.getLocalVariableDeclaration())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getLocalVariableDeclaration().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 215:  DeclarationStatement ::= LocalConstantDeclaration ;
     *</b>
     */
    static public class DeclarationStatement1 extends Ast implements IDeclarationStatement
    {
        private LocalConstantDeclaration _LocalConstantDeclaration;

        public LocalConstantDeclaration getLocalConstantDeclaration() { return _LocalConstantDeclaration; }

        public DeclarationStatement1(IToken leftIToken, IToken rightIToken,
                                     LocalConstantDeclaration _LocalConstantDeclaration)
        {
            super(leftIToken, rightIToken);

            this._LocalConstantDeclaration = _LocalConstantDeclaration;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof DeclarationStatement1)) return false;
            DeclarationStatement1 other = (DeclarationStatement1    ) o;
            if (! _LocalConstantDeclaration.equals(other.getLocalConstantDeclaration())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getLocalConstantDeclaration().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 219:  LocalVariableDeclarator ::= identifier
     *</b>
     */
    static public class LocalVariableDeclarator0 extends AstToken implements ILocalVariableDeclarator
    {
        public LocalVariableDeclarator0(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 220:  LocalVariableDeclarator ::= identifier = LocalVariableInitializer
     *</b>
     */
    static public class LocalVariableDeclarator1 extends Ast implements ILocalVariableDeclarator
    {
        private ILocalVariableInitializer _LocalVariableInitializer;

        public ILocalVariableInitializer getLocalVariableInitializer() { return _LocalVariableInitializer; }

        public LocalVariableDeclarator1(IToken leftIToken, IToken rightIToken,
                                        ILocalVariableInitializer _LocalVariableInitializer)
        {
            super(leftIToken, rightIToken);

            this._LocalVariableInitializer = _LocalVariableInitializer;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof LocalVariableDeclarator1)) return false;
            LocalVariableDeclarator1 other = (LocalVariableDeclarator1    ) o;
            if (! _LocalVariableInitializer.equals(other.getLocalVariableInitializer())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getLocalVariableInitializer().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 246:  SwitchLabel ::= case ConstantExpression :
     *</b>
     */
    static public class SwitchLabel0 extends Ast implements ISwitchLabel
    {
        private IConstantExpression _ConstantExpression;

        public IConstantExpression getConstantExpression() { return _ConstantExpression; }

        public SwitchLabel0(IToken leftIToken, IToken rightIToken,
                            IConstantExpression _ConstantExpression)
        {
            super(leftIToken, rightIToken);

            this._ConstantExpression = _ConstantExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof SwitchLabel0)) return false;
            SwitchLabel0 other = (SwitchLabel0    ) o;
            if (! _ConstantExpression.equals(other.getConstantExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getConstantExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 247:  SwitchLabel ::= default :
     *</b>
     */
    static public class SwitchLabel1 extends Ast implements ISwitchLabel
    {
        public SwitchLabel1(IToken leftIToken, IToken rightIToken)
        {
            super(leftIToken, rightIToken);

            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof SwitchLabel1)) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 275:  GotoStatement ::= goto identifier ;
     *</b>
     */
    static public class GotoStatement0 extends Ast implements IGotoStatement
    {
        public GotoStatement0(IToken leftIToken, IToken rightIToken)
        {
            super(leftIToken, rightIToken);

            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof GotoStatement0)) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 276:  GotoStatement ::= goto case ConstantExpression ;
     *</b>
     */
    static public class GotoStatement1 extends Ast implements IGotoStatement
    {
        private IConstantExpression _ConstantExpression;

        public IConstantExpression getConstantExpression() { return _ConstantExpression; }

        public GotoStatement1(IToken leftIToken, IToken rightIToken,
                              IConstantExpression _ConstantExpression)
        {
            super(leftIToken, rightIToken);

            this._ConstantExpression = _ConstantExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof GotoStatement1)) return false;
            GotoStatement1 other = (GotoStatement1    ) o;
            if (! _ConstantExpression.equals(other.getConstantExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getConstantExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 277:  GotoStatement ::= goto default ;
     *</b>
     */
    static public class GotoStatement2 extends Ast implements IGotoStatement
    {
        public GotoStatement2(IToken leftIToken, IToken rightIToken)
        {
            super(leftIToken, rightIToken);

            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof GotoStatement2)) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 280:  TryStatement ::= try Block CatchClauses
     *</b>
     */
    static public class TryStatement0 extends Ast implements ITryStatement
    {
        private Block _Block;
        private ICatchClauses _CatchClauses;

        public Block getBlock() { return _Block; }
        public ICatchClauses getCatchClauses() { return _CatchClauses; }

        public TryStatement0(IToken leftIToken, IToken rightIToken,
                             Block _Block,
                             ICatchClauses _CatchClauses)
        {
            super(leftIToken, rightIToken);

            this._Block = _Block;
            this._CatchClauses = _CatchClauses;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof TryStatement0)) return false;
            TryStatement0 other = (TryStatement0    ) o;
            if (! _Block.equals(other.getBlock())) return false;
            if (! _CatchClauses.equals(other.getCatchClauses())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getBlock().hashCode());
            hash = hash * 31 + (getCatchClauses().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 281:  TryStatement ::= try Block CatchClausesOpt FinallyClause
     *</b>
     */
    static public class TryStatement1 extends Ast implements ITryStatement
    {
        private Block _Block;
        private ICatchClausesOpt _CatchClausesOpt;
        private FinallyClause _FinallyClause;

        public Block getBlock() { return _Block; }
        /**
         * The value returned by <b>getCatchClausesOpt</b> may be <b>null</b>
         */
        public ICatchClausesOpt getCatchClausesOpt() { return _CatchClausesOpt; }
        public FinallyClause getFinallyClause() { return _FinallyClause; }

        public TryStatement1(IToken leftIToken, IToken rightIToken,
                             Block _Block,
                             ICatchClausesOpt _CatchClausesOpt,
                             FinallyClause _FinallyClause)
        {
            super(leftIToken, rightIToken);

            this._Block = _Block;
            this._CatchClausesOpt = _CatchClausesOpt;
            this._FinallyClause = _FinallyClause;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof TryStatement1)) return false;
            TryStatement1 other = (TryStatement1    ) o;
            if (! _Block.equals(other.getBlock())) return false;
            if (_CatchClausesOpt == null && other.getCatchClausesOpt() != null) return false;
            else if (! _CatchClausesOpt.equals(other.getCatchClausesOpt())) return false;
            if (! _FinallyClause.equals(other.getFinallyClause())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getBlock().hashCode());
            hash = hash * 31 + (getCatchClausesOpt() == null ? 0 : getCatchClausesOpt().hashCode());
            hash = hash * 31 + (getFinallyClause().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 299:  YieldStatement ::= yield return Expression ;
     *</b>
     */
    static public class YieldStatement0 extends Ast implements IYieldStatement
    {
        private IExpression _Expression;

        public IExpression getExpression() { return _Expression; }

        public YieldStatement0(IToken leftIToken, IToken rightIToken,
                               IExpression _Expression)
        {
            super(leftIToken, rightIToken);

            this._Expression = _Expression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof YieldStatement0)) return false;
            YieldStatement0 other = (YieldStatement0    ) o;
            if (! _Expression.equals(other.getExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 300:  YieldStatement ::= yield break ;
     *</b>
     */
    static public class YieldStatement1 extends Ast implements IYieldStatement
    {
        public YieldStatement1(IToken leftIToken, IToken rightIToken)
        {
            super(leftIToken, rightIToken);

            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof YieldStatement1)) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 331:  Modifier ::= new
     *</b>
     */
    static public class Modifier0 extends AstToken implements IModifier
    {
        public Modifier0(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 332:  Modifier ::= public
     *</b>
     */
    static public class Modifier1 extends AstToken implements IModifier
    {
        public Modifier1(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 333:  Modifier ::= protected
     *</b>
     */
    static public class Modifier2 extends AstToken implements IModifier
    {
        public Modifier2(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 334:  Modifier ::= internal
     *</b>
     */
    static public class Modifier3 extends AstToken implements IModifier
    {
        public Modifier3(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 335:  Modifier ::= private
     *</b>
     */
    static public class Modifier4 extends AstToken implements IModifier
    {
        public Modifier4(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 336:  Modifier ::= abstract
     *</b>
     */
    static public class Modifier5 extends AstToken implements IModifier
    {
        public Modifier5(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 337:  Modifier ::= sealed
     *</b>
     */
    static public class Modifier6 extends AstToken implements IModifier
    {
        public Modifier6(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 338:  Modifier ::= static
     *</b>
     */
    static public class Modifier7 extends AstToken implements IModifier
    {
        public Modifier7(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 339:  Modifier ::= readonly
     *</b>
     */
    static public class Modifier8 extends AstToken implements IModifier
    {
        public Modifier8(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 340:  Modifier ::= volatile
     *</b>
     */
    static public class Modifier9 extends AstToken implements IModifier
    {
        public Modifier9(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 341:  Modifier ::= virtual
     *</b>
     */
    static public class Modifier10 extends AstToken implements IModifier
    {
        public Modifier10(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 342:  Modifier ::= override
     *</b>
     */
    static public class Modifier11 extends AstToken implements IModifier
    {
        public Modifier11(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 343:  Modifier ::= extern
     *</b>
     */
    static public class Modifier12 extends AstToken implements IModifier
    {
        public Modifier12(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 371:  VariableDeclarator ::= identifier
     *</b>
     */
    static public class VariableDeclarator0 extends AstToken implements IVariableDeclarator
    {
        public VariableDeclarator0(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 372:  VariableDeclarator ::= identifier = VariableInitializer
     *</b>
     */
    static public class VariableDeclarator1 extends Ast implements IVariableDeclarator
    {
        private IVariableInitializer _VariableInitializer;

        public IVariableInitializer getVariableInitializer() { return _VariableInitializer; }

        public VariableDeclarator1(IToken leftIToken, IToken rightIToken,
                                   IVariableInitializer _VariableInitializer)
        {
            super(leftIToken, rightIToken);

            this._VariableInitializer = _VariableInitializer;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof VariableDeclarator1)) return false;
            VariableDeclarator1 other = (VariableDeclarator1    ) o;
            if (! _VariableInitializer.equals(other.getVariableInitializer())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getVariableInitializer().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 389:  ParameterModifier ::= ref
     *</b>
     */
    static public class ParameterModifier0 extends AstToken implements IParameterModifier
    {
        public ParameterModifier0(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 390:  ParameterModifier ::= out
     *</b>
     */
    static public class ParameterModifier1 extends AstToken implements IParameterModifier
    {
        public ParameterModifier1(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 393:  AccessorDeclarations ::= GetAccessorDeclaration SetAccessorDeclarationOpt
     *</b>
     */
    static public class AccessorDeclarations0 extends Ast implements IAccessorDeclarations
    {
        private GetAccessorDeclaration _GetAccessorDeclaration;
        private SetAccessorDeclaration _SetAccessorDeclarationOpt;

        public GetAccessorDeclaration getGetAccessorDeclaration() { return _GetAccessorDeclaration; }
        /**
         * The value returned by <b>getSetAccessorDeclarationOpt</b> may be <b>null</b>
         */
        public SetAccessorDeclaration getSetAccessorDeclarationOpt() { return _SetAccessorDeclarationOpt; }

        public AccessorDeclarations0(IToken leftIToken, IToken rightIToken,
                                     GetAccessorDeclaration _GetAccessorDeclaration,
                                     SetAccessorDeclaration _SetAccessorDeclarationOpt)
        {
            super(leftIToken, rightIToken);

            this._GetAccessorDeclaration = _GetAccessorDeclaration;
            this._SetAccessorDeclarationOpt = _SetAccessorDeclarationOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AccessorDeclarations0)) return false;
            AccessorDeclarations0 other = (AccessorDeclarations0    ) o;
            if (! _GetAccessorDeclaration.equals(other.getGetAccessorDeclaration())) return false;
            if (_SetAccessorDeclarationOpt == null && other.getSetAccessorDeclarationOpt() != null) return false;
            else if (! _SetAccessorDeclarationOpt.equals(other.getSetAccessorDeclarationOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getGetAccessorDeclaration().hashCode());
            hash = hash * 31 + (getSetAccessorDeclarationOpt() == null ? 0 : getSetAccessorDeclarationOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 394:  AccessorDeclarations ::= SetAccessorDeclaration GetAccessorDeclarationOpt
     *</b>
     */
    static public class AccessorDeclarations1 extends Ast implements IAccessorDeclarations
    {
        private SetAccessorDeclaration _SetAccessorDeclaration;
        private GetAccessorDeclaration _GetAccessorDeclarationOpt;

        public SetAccessorDeclaration getSetAccessorDeclaration() { return _SetAccessorDeclaration; }
        /**
         * The value returned by <b>getGetAccessorDeclarationOpt</b> may be <b>null</b>
         */
        public GetAccessorDeclaration getGetAccessorDeclarationOpt() { return _GetAccessorDeclarationOpt; }

        public AccessorDeclarations1(IToken leftIToken, IToken rightIToken,
                                     SetAccessorDeclaration _SetAccessorDeclaration,
                                     GetAccessorDeclaration _GetAccessorDeclarationOpt)
        {
            super(leftIToken, rightIToken);

            this._SetAccessorDeclaration = _SetAccessorDeclaration;
            this._GetAccessorDeclarationOpt = _GetAccessorDeclarationOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AccessorDeclarations1)) return false;
            AccessorDeclarations1 other = (AccessorDeclarations1    ) o;
            if (! _SetAccessorDeclaration.equals(other.getSetAccessorDeclaration())) return false;
            if (_GetAccessorDeclarationOpt == null && other.getGetAccessorDeclarationOpt() != null) return false;
            else if (! _GetAccessorDeclarationOpt.equals(other.getGetAccessorDeclarationOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getSetAccessorDeclaration().hashCode());
            hash = hash * 31 + (getGetAccessorDeclarationOpt() == null ? 0 : getGetAccessorDeclarationOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 403:  AccessorModifier ::= protected
     *</b>
     */
    static public class AccessorModifier0 extends AstToken implements IAccessorModifier
    {
        public AccessorModifier0(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 404:  AccessorModifier ::= internal
     *</b>
     */
    static public class AccessorModifier1 extends AstToken implements IAccessorModifier
    {
        public AccessorModifier1(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 405:  AccessorModifier ::= private
     *</b>
     */
    static public class AccessorModifier2 extends AstToken implements IAccessorModifier
    {
        public AccessorModifier2(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 406:  AccessorModifier ::= protected internal
     *</b>
     */
    static public class AccessorModifier3 extends Ast implements IAccessorModifier
    {
        public AccessorModifier3(IToken leftIToken, IToken rightIToken)
        {
            super(leftIToken, rightIToken);

            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AccessorModifier3)) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 407:  AccessorModifier ::= internal protected
     *</b>
     */
    static public class AccessorModifier4 extends Ast implements IAccessorModifier
    {
        public AccessorModifier4(IToken leftIToken, IToken rightIToken)
        {
            super(leftIToken, rightIToken);

            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AccessorModifier4)) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 410:  EventDeclaration ::= AttributesOpt ModifiersOpt event Type VariableDeclarators ;
     *</b>
     */
    static public class EventDeclaration0 extends Ast implements IEventDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private IModifiersOpt _ModifiersOpt;
        private IType _Type;
        private IVariableDeclarators _VariableDeclarators;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getModifiersOpt</b> may be <b>null</b>
         */
        public IModifiersOpt getModifiersOpt() { return _ModifiersOpt; }
        public IType getType() { return _Type; }
        public IVariableDeclarators getVariableDeclarators() { return _VariableDeclarators; }

        public EventDeclaration0(IToken leftIToken, IToken rightIToken,
                                 IAttributesOpt _AttributesOpt,
                                 IModifiersOpt _ModifiersOpt,
                                 IType _Type,
                                 IVariableDeclarators _VariableDeclarators)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ModifiersOpt = _ModifiersOpt;
            this._Type = _Type;
            this._VariableDeclarators = _VariableDeclarators;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof EventDeclaration0)) return false;
            EventDeclaration0 other = (EventDeclaration0    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_ModifiersOpt == null && other.getModifiersOpt() != null) return false;
            else if (! _ModifiersOpt.equals(other.getModifiersOpt())) return false;
            if (! _Type.equals(other.getType())) return false;
            if (! _VariableDeclarators.equals(other.getVariableDeclarators())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getModifiersOpt() == null ? 0 : getModifiersOpt().hashCode());
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getVariableDeclarators().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 411:  EventDeclaration ::= AttributesOpt ModifiersOpt event Type Name { EventAccessorDeclarations }
     *</b>
     */
    static public class EventDeclaration1 extends Ast implements IEventDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private IModifiersOpt _ModifiersOpt;
        private IType _Type;
        private IName _Name;
        private IEventAccessorDeclarations _EventAccessorDeclarations;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getModifiersOpt</b> may be <b>null</b>
         */
        public IModifiersOpt getModifiersOpt() { return _ModifiersOpt; }
        public IType getType() { return _Type; }
        public IName getName() { return _Name; }
        public IEventAccessorDeclarations getEventAccessorDeclarations() { return _EventAccessorDeclarations; }

        public EventDeclaration1(IToken leftIToken, IToken rightIToken,
                                 IAttributesOpt _AttributesOpt,
                                 IModifiersOpt _ModifiersOpt,
                                 IType _Type,
                                 IName _Name,
                                 IEventAccessorDeclarations _EventAccessorDeclarations)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ModifiersOpt = _ModifiersOpt;
            this._Type = _Type;
            this._Name = _Name;
            this._EventAccessorDeclarations = _EventAccessorDeclarations;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof EventDeclaration1)) return false;
            EventDeclaration1 other = (EventDeclaration1    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_ModifiersOpt == null && other.getModifiersOpt() != null) return false;
            else if (! _ModifiersOpt.equals(other.getModifiersOpt())) return false;
            if (! _Type.equals(other.getType())) return false;
            if (! _Name.equals(other.getName())) return false;
            if (! _EventAccessorDeclarations.equals(other.getEventAccessorDeclarations())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getModifiersOpt() == null ? 0 : getModifiersOpt().hashCode());
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getName().hashCode());
            hash = hash * 31 + (getEventAccessorDeclarations().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 412:  EventAccessorDeclarations ::= AddAccessorDeclaration RemoveAccessorDeclaration
     *</b>
     */
    static public class EventAccessorDeclarations0 extends Ast implements IEventAccessorDeclarations
    {
        private AddAccessorDeclaration _AddAccessorDeclaration;
        private RemoveAccessorDeclaration _RemoveAccessorDeclaration;

        public AddAccessorDeclaration getAddAccessorDeclaration() { return _AddAccessorDeclaration; }
        public RemoveAccessorDeclaration getRemoveAccessorDeclaration() { return _RemoveAccessorDeclaration; }

        public EventAccessorDeclarations0(IToken leftIToken, IToken rightIToken,
                                          AddAccessorDeclaration _AddAccessorDeclaration,
                                          RemoveAccessorDeclaration _RemoveAccessorDeclaration)
        {
            super(leftIToken, rightIToken);

            this._AddAccessorDeclaration = _AddAccessorDeclaration;
            this._RemoveAccessorDeclaration = _RemoveAccessorDeclaration;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof EventAccessorDeclarations0)) return false;
            EventAccessorDeclarations0 other = (EventAccessorDeclarations0    ) o;
            if (! _AddAccessorDeclaration.equals(other.getAddAccessorDeclaration())) return false;
            if (! _RemoveAccessorDeclaration.equals(other.getRemoveAccessorDeclaration())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAddAccessorDeclaration().hashCode());
            hash = hash * 31 + (getRemoveAccessorDeclaration().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 413:  EventAccessorDeclarations ::= RemoveAccessorDeclaration AddAccessorDeclaration
     *</b>
     */
    static public class EventAccessorDeclarations1 extends Ast implements IEventAccessorDeclarations
    {
        private RemoveAccessorDeclaration _RemoveAccessorDeclaration;
        private AddAccessorDeclaration _AddAccessorDeclaration;

        public RemoveAccessorDeclaration getRemoveAccessorDeclaration() { return _RemoveAccessorDeclaration; }
        public AddAccessorDeclaration getAddAccessorDeclaration() { return _AddAccessorDeclaration; }

        public EventAccessorDeclarations1(IToken leftIToken, IToken rightIToken,
                                          RemoveAccessorDeclaration _RemoveAccessorDeclaration,
                                          AddAccessorDeclaration _AddAccessorDeclaration)
        {
            super(leftIToken, rightIToken);

            this._RemoveAccessorDeclaration = _RemoveAccessorDeclaration;
            this._AddAccessorDeclaration = _AddAccessorDeclaration;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof EventAccessorDeclarations1)) return false;
            EventAccessorDeclarations1 other = (EventAccessorDeclarations1    ) o;
            if (! _RemoveAccessorDeclaration.equals(other.getRemoveAccessorDeclaration())) return false;
            if (! _AddAccessorDeclaration.equals(other.getAddAccessorDeclaration())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getRemoveAccessorDeclaration().hashCode());
            hash = hash * 31 + (getAddAccessorDeclaration().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 417:  IndexerDeclarator ::= Type this [ FormalParameterList ]
     *</b>
     */
    static public class IndexerDeclarator0 extends Ast implements IIndexerDeclarator
    {
        private IType _Type;
        private IFormalParameterList _FormalParameterList;

        public IType getType() { return _Type; }
        public IFormalParameterList getFormalParameterList() { return _FormalParameterList; }

        public IndexerDeclarator0(IToken leftIToken, IToken rightIToken,
                                  IType _Type,
                                  IFormalParameterList _FormalParameterList)
        {
            super(leftIToken, rightIToken);

            this._Type = _Type;
            this._FormalParameterList = _FormalParameterList;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof IndexerDeclarator0)) return false;
            IndexerDeclarator0 other = (IndexerDeclarator0    ) o;
            if (! _Type.equals(other.getType())) return false;
            if (! _FormalParameterList.equals(other.getFormalParameterList())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getFormalParameterList().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 418:  IndexerDeclarator ::= Type Name . this [ FormalParameterList ]
     *</b>
     */
    static public class IndexerDeclarator1 extends Ast implements IIndexerDeclarator
    {
        private IType _Type;
        private IName _Name;
        private IFormalParameterList _FormalParameterList;

        public IType getType() { return _Type; }
        public IName getName() { return _Name; }
        public IFormalParameterList getFormalParameterList() { return _FormalParameterList; }

        public IndexerDeclarator1(IToken leftIToken, IToken rightIToken,
                                  IType _Type,
                                  IName _Name,
                                  IFormalParameterList _FormalParameterList)
        {
            super(leftIToken, rightIToken);

            this._Type = _Type;
            this._Name = _Name;
            this._FormalParameterList = _FormalParameterList;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof IndexerDeclarator1)) return false;
            IndexerDeclarator1 other = (IndexerDeclarator1    ) o;
            if (! _Type.equals(other.getType())) return false;
            if (! _Name.equals(other.getName())) return false;
            if (! _FormalParameterList.equals(other.getFormalParameterList())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getName().hashCode());
            hash = hash * 31 + (getFormalParameterList().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 423:  OverloadableOperator ::= +
     *</b>
     */
    static public class OverloadableOperator0 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator0(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 424:  OverloadableOperator ::= -
     *</b>
     */
    static public class OverloadableOperator1 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator1(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 425:  OverloadableOperator ::= !
     *</b>
     */
    static public class OverloadableOperator2 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator2(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 426:  OverloadableOperator ::= ~
     *</b>
     */
    static public class OverloadableOperator3 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator3(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 427:  OverloadableOperator ::= ++
     *</b>
     */
    static public class OverloadableOperator4 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator4(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 428:  OverloadableOperator ::= --
     *</b>
     */
    static public class OverloadableOperator5 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator5(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 429:  OverloadableOperator ::= true
     *</b>
     */
    static public class OverloadableOperator6 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator6(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 430:  OverloadableOperator ::= false
     *</b>
     */
    static public class OverloadableOperator7 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator7(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 431:  OverloadableOperator ::= *
     *</b>
     */
    static public class OverloadableOperator8 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator8(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 432:  OverloadableOperator ::= /
     *</b>
     */
    static public class OverloadableOperator9 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator9(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 433:  OverloadableOperator ::= %
     *</b>
     */
    static public class OverloadableOperator10 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator10(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 434:  OverloadableOperator ::= &
     *</b>
     */
    static public class OverloadableOperator11 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator11(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 435:  OverloadableOperator ::= |
     *</b>
     */
    static public class OverloadableOperator12 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator12(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 436:  OverloadableOperator ::= ^
     *</b>
     */
    static public class OverloadableOperator13 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator13(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 437:  OverloadableOperator ::= <<
     *</b>
     */
    static public class OverloadableOperator14 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator14(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 438:  OverloadableOperator ::= >>
     *</b>
     */
    static public class OverloadableOperator15 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator15(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 439:  OverloadableOperator ::= ==
     *</b>
     */
    static public class OverloadableOperator16 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator16(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 440:  OverloadableOperator ::= !=
     *</b>
     */
    static public class OverloadableOperator17 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator17(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 441:  OverloadableOperator ::= >
     *</b>
     */
    static public class OverloadableOperator18 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator18(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 442:  OverloadableOperator ::= <
     *</b>
     */
    static public class OverloadableOperator19 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator19(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 443:  OverloadableOperator ::= >=
     *</b>
     */
    static public class OverloadableOperator20 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator20(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 444:  OverloadableOperator ::= <=
     *</b>
     */
    static public class OverloadableOperator21 extends AstToken implements IOverloadableOperator
    {
        public OverloadableOperator21(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 445:  ConversionOperatorDeclarator ::= implicit operator Type ( Type identifier )
     *</b>
     */
    static public class ConversionOperatorDeclarator0 extends Ast implements IConversionOperatorDeclarator
    {
        private IType _Type;
        private IType _Type5;

        public IType getType() { return _Type; }
        public IType getType5() { return _Type5; }

        public ConversionOperatorDeclarator0(IToken leftIToken, IToken rightIToken,
                                             IType _Type,
                                             IType _Type5)
        {
            super(leftIToken, rightIToken);

            this._Type = _Type;
            this._Type5 = _Type5;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ConversionOperatorDeclarator0)) return false;
            ConversionOperatorDeclarator0 other = (ConversionOperatorDeclarator0    ) o;
            if (! _Type.equals(other.getType())) return false;
            if (! _Type5.equals(other.getType5())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getType5().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 446:  ConversionOperatorDeclarator ::= explicit operator Type ( Type identifier )
     *</b>
     */
    static public class ConversionOperatorDeclarator1 extends Ast implements IConversionOperatorDeclarator
    {
        private IType _Type;
        private IType _Type5;

        public IType getType() { return _Type; }
        public IType getType5() { return _Type5; }

        public ConversionOperatorDeclarator1(IToken leftIToken, IToken rightIToken,
                                             IType _Type,
                                             IType _Type5)
        {
            super(leftIToken, rightIToken);

            this._Type = _Type;
            this._Type5 = _Type5;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ConversionOperatorDeclarator1)) return false;
            ConversionOperatorDeclarator1 other = (ConversionOperatorDeclarator1    ) o;
            if (! _Type.equals(other.getType())) return false;
            if (! _Type5.equals(other.getType5())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getType().hashCode());
            hash = hash * 31 + (getType5().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 453:  ConstructorInitializer ::= base ( ArgumentListOpt )
     *</b>
     */
    static public class ConstructorInitializer0 extends Ast implements IConstructorInitializer
    {
        private IArgumentListOpt _ArgumentListOpt;

        /**
         * The value returned by <b>getArgumentListOpt</b> may be <b>null</b>
         */
        public IArgumentListOpt getArgumentListOpt() { return _ArgumentListOpt; }

        public ConstructorInitializer0(IToken leftIToken, IToken rightIToken,
                                       IArgumentListOpt _ArgumentListOpt)
        {
            super(leftIToken, rightIToken);

            this._ArgumentListOpt = _ArgumentListOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ConstructorInitializer0)) return false;
            ConstructorInitializer0 other = (ConstructorInitializer0    ) o;
            if (_ArgumentListOpt == null && other.getArgumentListOpt() != null) return false;
            else if (! _ArgumentListOpt.equals(other.getArgumentListOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getArgumentListOpt() == null ? 0 : getArgumentListOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 454:  ConstructorInitializer ::= this ( ArgumentListOpt )
     *</b>
     */
    static public class ConstructorInitializer1 extends Ast implements IConstructorInitializer
    {
        private IArgumentListOpt _ArgumentListOpt;

        /**
         * The value returned by <b>getArgumentListOpt</b> may be <b>null</b>
         */
        public IArgumentListOpt getArgumentListOpt() { return _ArgumentListOpt; }

        public ConstructorInitializer1(IToken leftIToken, IToken rightIToken,
                                       IArgumentListOpt _ArgumentListOpt)
        {
            super(leftIToken, rightIToken);

            this._ArgumentListOpt = _ArgumentListOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ConstructorInitializer1)) return false;
            ConstructorInitializer1 other = (ConstructorInitializer1    ) o;
            if (_ArgumentListOpt == null && other.getArgumentListOpt() != null) return false;
            else if (! _ArgumentListOpt.equals(other.getArgumentListOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getArgumentListOpt() == null ? 0 : getArgumentListOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 490:  DimSeparators ::= ,
     *</b>
     */
    static public class DimSeparators0 extends AstToken implements IDimSeparators
    {
        public DimSeparators0(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 491:  DimSeparators ::= DimSeparators ,
     *</b>
     */
    static public class DimSeparators1 extends Ast implements IDimSeparators
    {
        private IDimSeparators _DimSeparators;

        public IDimSeparators getDimSeparators() { return _DimSeparators; }

        public DimSeparators1(IToken leftIToken, IToken rightIToken,
                              IDimSeparators _DimSeparators)
        {
            super(leftIToken, rightIToken);

            this._DimSeparators = _DimSeparators;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof DimSeparators1)) return false;
            DimSeparators1 other = (DimSeparators1    ) o;
            if (! _DimSeparators.equals(other.getDimSeparators())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getDimSeparators().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 494:  ArrayInitializer ::= { VariableInitializerListOpt }
     *</b>
     */
    static public class ArrayInitializer0 extends Ast implements IArrayInitializer
    {
        private IVariableInitializerListOpt _VariableInitializerListOpt;

        /**
         * The value returned by <b>getVariableInitializerListOpt</b> may be <b>null</b>
         */
        public IVariableInitializerListOpt getVariableInitializerListOpt() { return _VariableInitializerListOpt; }

        public ArrayInitializer0(IToken leftIToken, IToken rightIToken,
                                 IVariableInitializerListOpt _VariableInitializerListOpt)
        {
            super(leftIToken, rightIToken);

            this._VariableInitializerListOpt = _VariableInitializerListOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ArrayInitializer0)) return false;
            ArrayInitializer0 other = (ArrayInitializer0    ) o;
            if (_VariableInitializerListOpt == null && other.getVariableInitializerListOpt() != null) return false;
            else if (! _VariableInitializerListOpt.equals(other.getVariableInitializerListOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getVariableInitializerListOpt() == null ? 0 : getVariableInitializerListOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 495:  ArrayInitializer ::= { VariableInitializerList , }
     *</b>
     */
    static public class ArrayInitializer1 extends Ast implements IArrayInitializer
    {
        private IVariableInitializerList _VariableInitializerList;

        public IVariableInitializerList getVariableInitializerList() { return _VariableInitializerList; }

        public ArrayInitializer1(IToken leftIToken, IToken rightIToken,
                                 IVariableInitializerList _VariableInitializerList)
        {
            super(leftIToken, rightIToken);

            this._VariableInitializerList = _VariableInitializerList;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof ArrayInitializer1)) return false;
            ArrayInitializer1 other = (ArrayInitializer1    ) o;
            if (! _VariableInitializerList.equals(other.getVariableInitializerList())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getVariableInitializerList().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 516:  InterfaceAccessors ::= AttributesOpt get ;
     *</b>
     */
    static public class InterfaceAccessors0 extends Ast implements IInterfaceAccessors
    {
        private IAttributesOpt _AttributesOpt;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }

        public InterfaceAccessors0(IToken leftIToken, IToken rightIToken,
                                   IAttributesOpt _AttributesOpt)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof InterfaceAccessors0)) return false;
            InterfaceAccessors0 other = (InterfaceAccessors0    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 517:  InterfaceAccessors ::= AttributesOpt set ;
     *</b>
     */
    static public class InterfaceAccessors1 extends Ast implements IInterfaceAccessors
    {
        private IAttributesOpt _AttributesOpt;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }

        public InterfaceAccessors1(IToken leftIToken, IToken rightIToken,
                                   IAttributesOpt _AttributesOpt)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof InterfaceAccessors1)) return false;
            InterfaceAccessors1 other = (InterfaceAccessors1    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 518:  InterfaceAccessors ::= AttributesOpt get ; AttributesOpt set ;
     *</b>
     */
    static public class InterfaceAccessors2 extends Ast implements IInterfaceAccessors
    {
        private IAttributesOpt _AttributesOpt;
        private IAttributesOpt _AttributesOpt4;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getAttributesOpt4</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt4() { return _AttributesOpt4; }

        public InterfaceAccessors2(IToken leftIToken, IToken rightIToken,
                                   IAttributesOpt _AttributesOpt,
                                   IAttributesOpt _AttributesOpt4)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._AttributesOpt4 = _AttributesOpt4;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof InterfaceAccessors2)) return false;
            InterfaceAccessors2 other = (InterfaceAccessors2    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_AttributesOpt4 == null && other.getAttributesOpt4() != null) return false;
            else if (! _AttributesOpt4.equals(other.getAttributesOpt4())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getAttributesOpt4() == null ? 0 : getAttributesOpt4().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 519:  InterfaceAccessors ::= AttributesOpt set ; AttributesOpt get ;
     *</b>
     */
    static public class InterfaceAccessors3 extends Ast implements IInterfaceAccessors
    {
        private IAttributesOpt _AttributesOpt;
        private IAttributesOpt _AttributesOpt4;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        /**
         * The value returned by <b>getAttributesOpt4</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt4() { return _AttributesOpt4; }

        public InterfaceAccessors3(IToken leftIToken, IToken rightIToken,
                                   IAttributesOpt _AttributesOpt,
                                   IAttributesOpt _AttributesOpt4)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._AttributesOpt4 = _AttributesOpt4;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof InterfaceAccessors3)) return false;
            InterfaceAccessors3 other = (InterfaceAccessors3    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (_AttributesOpt4 == null && other.getAttributesOpt4() != null) return false;
            else if (! _AttributesOpt4.equals(other.getAttributesOpt4())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getAttributesOpt4() == null ? 0 : getAttributesOpt4().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 526:  EnumBody ::= { EnumMemberDeclarationsOpt }
     *</b>
     */
    static public class EnumBody0 extends Ast implements IEnumBody
    {
        private IEnumMemberDeclarationsOpt _EnumMemberDeclarationsOpt;

        /**
         * The value returned by <b>getEnumMemberDeclarationsOpt</b> may be <b>null</b>
         */
        public IEnumMemberDeclarationsOpt getEnumMemberDeclarationsOpt() { return _EnumMemberDeclarationsOpt; }

        public EnumBody0(IToken leftIToken, IToken rightIToken,
                         IEnumMemberDeclarationsOpt _EnumMemberDeclarationsOpt)
        {
            super(leftIToken, rightIToken);

            this._EnumMemberDeclarationsOpt = _EnumMemberDeclarationsOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof EnumBody0)) return false;
            EnumBody0 other = (EnumBody0    ) o;
            if (_EnumMemberDeclarationsOpt == null && other.getEnumMemberDeclarationsOpt() != null) return false;
            else if (! _EnumMemberDeclarationsOpt.equals(other.getEnumMemberDeclarationsOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getEnumMemberDeclarationsOpt() == null ? 0 : getEnumMemberDeclarationsOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 527:  EnumBody ::= { EnumMemberDeclarations , }
     *</b>
     */
    static public class EnumBody1 extends Ast implements IEnumBody
    {
        private IEnumMemberDeclarations _EnumMemberDeclarations;

        public IEnumMemberDeclarations getEnumMemberDeclarations() { return _EnumMemberDeclarations; }

        public EnumBody1(IToken leftIToken, IToken rightIToken,
                         IEnumMemberDeclarations _EnumMemberDeclarations)
        {
            super(leftIToken, rightIToken);

            this._EnumMemberDeclarations = _EnumMemberDeclarations;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof EnumBody1)) return false;
            EnumBody1 other = (EnumBody1    ) o;
            if (! _EnumMemberDeclarations.equals(other.getEnumMemberDeclarations())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getEnumMemberDeclarations().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 532:  EnumMemberDeclaration ::= AttributesOpt identifier
     *</b>
     */
    static public class EnumMemberDeclaration0 extends Ast implements IEnumMemberDeclaration
    {
        private IAttributesOpt _AttributesOpt;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }

        public EnumMemberDeclaration0(IToken leftIToken, IToken rightIToken,
                                      IAttributesOpt _AttributesOpt)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof EnumMemberDeclaration0)) return false;
            EnumMemberDeclaration0 other = (EnumMemberDeclaration0    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 533:  EnumMemberDeclaration ::= AttributesOpt identifier = ConstantExpression
     *</b>
     */
    static public class EnumMemberDeclaration1 extends Ast implements IEnumMemberDeclaration
    {
        private IAttributesOpt _AttributesOpt;
        private IConstantExpression _ConstantExpression;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        public IConstantExpression getConstantExpression() { return _ConstantExpression; }

        public EnumMemberDeclaration1(IToken leftIToken, IToken rightIToken,
                                      IAttributesOpt _AttributesOpt,
                                      IConstantExpression _ConstantExpression)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._ConstantExpression = _ConstantExpression;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof EnumMemberDeclaration1)) return false;
            EnumMemberDeclaration1 other = (EnumMemberDeclaration1    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (! _ConstantExpression.equals(other.getConstantExpression())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getConstantExpression().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 540:  AttributeSection ::= [ AttributeTargetSpecifierOpt AttributeList ]
     *</b>
     */
    static public class AttributeSection0 extends Ast implements IAttributeSection
    {
        private AttributeTargetSpecifier _AttributeTargetSpecifierOpt;
        private IAttributeList _AttributeList;

        /**
         * The value returned by <b>getAttributeTargetSpecifierOpt</b> may be <b>null</b>
         */
        public AttributeTargetSpecifier getAttributeTargetSpecifierOpt() { return _AttributeTargetSpecifierOpt; }
        public IAttributeList getAttributeList() { return _AttributeList; }

        public AttributeSection0(IToken leftIToken, IToken rightIToken,
                                 AttributeTargetSpecifier _AttributeTargetSpecifierOpt,
                                 IAttributeList _AttributeList)
        {
            super(leftIToken, rightIToken);

            this._AttributeTargetSpecifierOpt = _AttributeTargetSpecifierOpt;
            this._AttributeList = _AttributeList;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AttributeSection0)) return false;
            AttributeSection0 other = (AttributeSection0    ) o;
            if (_AttributeTargetSpecifierOpt == null && other.getAttributeTargetSpecifierOpt() != null) return false;
            else if (! _AttributeTargetSpecifierOpt.equals(other.getAttributeTargetSpecifierOpt())) return false;
            if (! _AttributeList.equals(other.getAttributeList())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributeTargetSpecifierOpt() == null ? 0 : getAttributeTargetSpecifierOpt().hashCode());
            hash = hash * 31 + (getAttributeList().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 541:  AttributeSection ::= [ AttributeTargetSpecifierOpt AttributeList , ]
     *</b>
     */
    static public class AttributeSection1 extends Ast implements IAttributeSection
    {
        private AttributeTargetSpecifier _AttributeTargetSpecifierOpt;
        private IAttributeList _AttributeList;

        /**
         * The value returned by <b>getAttributeTargetSpecifierOpt</b> may be <b>null</b>
         */
        public AttributeTargetSpecifier getAttributeTargetSpecifierOpt() { return _AttributeTargetSpecifierOpt; }
        public IAttributeList getAttributeList() { return _AttributeList; }

        public AttributeSection1(IToken leftIToken, IToken rightIToken,
                                 AttributeTargetSpecifier _AttributeTargetSpecifierOpt,
                                 IAttributeList _AttributeList)
        {
            super(leftIToken, rightIToken);

            this._AttributeTargetSpecifierOpt = _AttributeTargetSpecifierOpt;
            this._AttributeList = _AttributeList;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AttributeSection1)) return false;
            AttributeSection1 other = (AttributeSection1    ) o;
            if (_AttributeTargetSpecifierOpt == null && other.getAttributeTargetSpecifierOpt() != null) return false;
            else if (! _AttributeTargetSpecifierOpt.equals(other.getAttributeTargetSpecifierOpt())) return false;
            if (! _AttributeList.equals(other.getAttributeList())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributeTargetSpecifierOpt() == null ? 0 : getAttributeTargetSpecifierOpt().hashCode());
            hash = hash * 31 + (getAttributeList().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 547:  Keyword ::= abstract
     *</b>
     */
    static public class Keyword0 extends AstToken implements IKeyword
    {
        public Keyword0(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 548:  Keyword ::= add
     *</b>
     */
    static public class Keyword1 extends AstToken implements IKeyword
    {
        public Keyword1(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 549:  Keyword ::= alias
     *</b>
     */
    static public class Keyword2 extends AstToken implements IKeyword
    {
        public Keyword2(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 550:  Keyword ::= as
     *</b>
     */
    static public class Keyword3 extends AstToken implements IKeyword
    {
        public Keyword3(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 551:  Keyword ::= base
     *</b>
     */
    static public class Keyword4 extends AstToken implements IKeyword
    {
        public Keyword4(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 552:  Keyword ::= bool
     *</b>
     */
    static public class Keyword5 extends AstToken implements IKeyword
    {
        public Keyword5(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 553:  Keyword ::= break
     *</b>
     */
    static public class Keyword6 extends AstToken implements IKeyword
    {
        public Keyword6(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 554:  Keyword ::= byte
     *</b>
     */
    static public class Keyword7 extends AstToken implements IKeyword
    {
        public Keyword7(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 555:  Keyword ::= case
     *</b>
     */
    static public class Keyword8 extends AstToken implements IKeyword
    {
        public Keyword8(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 556:  Keyword ::= catch
     *</b>
     */
    static public class Keyword9 extends AstToken implements IKeyword
    {
        public Keyword9(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 557:  Keyword ::= char
     *</b>
     */
    static public class Keyword10 extends AstToken implements IKeyword
    {
        public Keyword10(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 558:  Keyword ::= checked
     *</b>
     */
    static public class Keyword11 extends AstToken implements IKeyword
    {
        public Keyword11(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 559:  Keyword ::= class
     *</b>
     */
    static public class Keyword12 extends AstToken implements IKeyword
    {
        public Keyword12(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 560:  Keyword ::= const
     *</b>
     */
    static public class Keyword13 extends AstToken implements IKeyword
    {
        public Keyword13(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 561:  Keyword ::= continue
     *</b>
     */
    static public class Keyword14 extends AstToken implements IKeyword
    {
        public Keyword14(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 562:  Keyword ::= decimal
     *</b>
     */
    static public class Keyword15 extends AstToken implements IKeyword
    {
        public Keyword15(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 563:  Keyword ::= default
     *</b>
     */
    static public class Keyword16 extends AstToken implements IKeyword
    {
        public Keyword16(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 564:  Keyword ::= delegate
     *</b>
     */
    static public class Keyword17 extends AstToken implements IKeyword
    {
        public Keyword17(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 565:  Keyword ::= do
     *</b>
     */
    static public class Keyword18 extends AstToken implements IKeyword
    {
        public Keyword18(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 566:  Keyword ::= double
     *</b>
     */
    static public class Keyword19 extends AstToken implements IKeyword
    {
        public Keyword19(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 567:  Keyword ::= else
     *</b>
     */
    static public class Keyword20 extends AstToken implements IKeyword
    {
        public Keyword20(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 568:  Keyword ::= enum
     *</b>
     */
    static public class Keyword21 extends AstToken implements IKeyword
    {
        public Keyword21(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 569:  Keyword ::= event
     *</b>
     */
    static public class Keyword22 extends AstToken implements IKeyword
    {
        public Keyword22(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 570:  Keyword ::= explicit
     *</b>
     */
    static public class Keyword23 extends AstToken implements IKeyword
    {
        public Keyword23(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 571:  Keyword ::= extern
     *</b>
     */
    static public class Keyword24 extends AstToken implements IKeyword
    {
        public Keyword24(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 572:  Keyword ::= false
     *</b>
     */
    static public class Keyword25 extends AstToken implements IKeyword
    {
        public Keyword25(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 573:  Keyword ::= finally
     *</b>
     */
    static public class Keyword26 extends AstToken implements IKeyword
    {
        public Keyword26(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 574:  Keyword ::= fixed
     *</b>
     */
    static public class Keyword27 extends AstToken implements IKeyword
    {
        public Keyword27(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 575:  Keyword ::= float
     *</b>
     */
    static public class Keyword28 extends AstToken implements IKeyword
    {
        public Keyword28(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 576:  Keyword ::= for
     *</b>
     */
    static public class Keyword29 extends AstToken implements IKeyword
    {
        public Keyword29(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 577:  Keyword ::= foreach
     *</b>
     */
    static public class Keyword30 extends AstToken implements IKeyword
    {
        public Keyword30(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 578:  Keyword ::= get
     *</b>
     */
    static public class Keyword31 extends AstToken implements IKeyword
    {
        public Keyword31(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 579:  Keyword ::= goto
     *</b>
     */
    static public class Keyword32 extends AstToken implements IKeyword
    {
        public Keyword32(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 580:  Keyword ::= if
     *</b>
     */
    static public class Keyword33 extends AstToken implements IKeyword
    {
        public Keyword33(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 581:  Keyword ::= implicit
     *</b>
     */
    static public class Keyword34 extends AstToken implements IKeyword
    {
        public Keyword34(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 582:  Keyword ::= in
     *</b>
     */
    static public class Keyword35 extends AstToken implements IKeyword
    {
        public Keyword35(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 583:  Keyword ::= int
     *</b>
     */
    static public class Keyword36 extends AstToken implements IKeyword
    {
        public Keyword36(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 584:  Keyword ::= interface
     *</b>
     */
    static public class Keyword37 extends AstToken implements IKeyword
    {
        public Keyword37(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 585:  Keyword ::= internal
     *</b>
     */
    static public class Keyword38 extends AstToken implements IKeyword
    {
        public Keyword38(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 586:  Keyword ::= is
     *</b>
     */
    static public class Keyword39 extends AstToken implements IKeyword
    {
        public Keyword39(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 587:  Keyword ::= lock
     *</b>
     */
    static public class Keyword40 extends AstToken implements IKeyword
    {
        public Keyword40(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 588:  Keyword ::= long
     *</b>
     */
    static public class Keyword41 extends AstToken implements IKeyword
    {
        public Keyword41(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 589:  Keyword ::= namespace
     *</b>
     */
    static public class Keyword42 extends AstToken implements IKeyword
    {
        public Keyword42(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 590:  Keyword ::= new
     *</b>
     */
    static public class Keyword43 extends AstToken implements IKeyword
    {
        public Keyword43(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 591:  Keyword ::= null
     *</b>
     */
    static public class Keyword44 extends AstToken implements IKeyword
    {
        public Keyword44(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 592:  Keyword ::= object
     *</b>
     */
    static public class Keyword45 extends AstToken implements IKeyword
    {
        public Keyword45(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 593:  Keyword ::= operator
     *</b>
     */
    static public class Keyword46 extends AstToken implements IKeyword
    {
        public Keyword46(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 594:  Keyword ::= out
     *</b>
     */
    static public class Keyword47 extends AstToken implements IKeyword
    {
        public Keyword47(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 595:  Keyword ::= override
     *</b>
     */
    static public class Keyword48 extends AstToken implements IKeyword
    {
        public Keyword48(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 596:  Keyword ::= params
     *</b>
     */
    static public class Keyword49 extends AstToken implements IKeyword
    {
        public Keyword49(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 597:  Keyword ::= partial
     *</b>
     */
    static public class Keyword50 extends AstToken implements IKeyword
    {
        public Keyword50(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 598:  Keyword ::= private
     *</b>
     */
    static public class Keyword51 extends AstToken implements IKeyword
    {
        public Keyword51(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 599:  Keyword ::= protected
     *</b>
     */
    static public class Keyword52 extends AstToken implements IKeyword
    {
        public Keyword52(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 600:  Keyword ::= public
     *</b>
     */
    static public class Keyword53 extends AstToken implements IKeyword
    {
        public Keyword53(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 601:  Keyword ::= readonly
     *</b>
     */
    static public class Keyword54 extends AstToken implements IKeyword
    {
        public Keyword54(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 602:  Keyword ::= ref
     *</b>
     */
    static public class Keyword55 extends AstToken implements IKeyword
    {
        public Keyword55(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 603:  Keyword ::= remove
     *</b>
     */
    static public class Keyword56 extends AstToken implements IKeyword
    {
        public Keyword56(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 604:  Keyword ::= return
     *</b>
     */
    static public class Keyword57 extends AstToken implements IKeyword
    {
        public Keyword57(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 605:  Keyword ::= sbyte
     *</b>
     */
    static public class Keyword58 extends AstToken implements IKeyword
    {
        public Keyword58(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 606:  Keyword ::= sealed
     *</b>
     */
    static public class Keyword59 extends AstToken implements IKeyword
    {
        public Keyword59(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 607:  Keyword ::= set
     *</b>
     */
    static public class Keyword60 extends AstToken implements IKeyword
    {
        public Keyword60(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 608:  Keyword ::= short
     *</b>
     */
    static public class Keyword61 extends AstToken implements IKeyword
    {
        public Keyword61(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 609:  Keyword ::= sizeof
     *</b>
     */
    static public class Keyword62 extends AstToken implements IKeyword
    {
        public Keyword62(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 610:  Keyword ::= stackalloc
     *</b>
     */
    static public class Keyword63 extends AstToken implements IKeyword
    {
        public Keyword63(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 611:  Keyword ::= static
     *</b>
     */
    static public class Keyword64 extends AstToken implements IKeyword
    {
        public Keyword64(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 612:  Keyword ::= string
     *</b>
     */
    static public class Keyword65 extends AstToken implements IKeyword
    {
        public Keyword65(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 613:  Keyword ::= struct
     *</b>
     */
    static public class Keyword66 extends AstToken implements IKeyword
    {
        public Keyword66(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 614:  Keyword ::= switch
     *</b>
     */
    static public class Keyword67 extends AstToken implements IKeyword
    {
        public Keyword67(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 615:  Keyword ::= this
     *</b>
     */
    static public class Keyword68 extends AstToken implements IKeyword
    {
        public Keyword68(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 616:  Keyword ::= throw
     *</b>
     */
    static public class Keyword69 extends AstToken implements IKeyword
    {
        public Keyword69(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 617:  Keyword ::= true
     *</b>
     */
    static public class Keyword70 extends AstToken implements IKeyword
    {
        public Keyword70(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 618:  Keyword ::= try
     *</b>
     */
    static public class Keyword71 extends AstToken implements IKeyword
    {
        public Keyword71(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 619:  Keyword ::= typeof
     *</b>
     */
    static public class Keyword72 extends AstToken implements IKeyword
    {
        public Keyword72(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 620:  Keyword ::= uint
     *</b>
     */
    static public class Keyword73 extends AstToken implements IKeyword
    {
        public Keyword73(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 621:  Keyword ::= ulong
     *</b>
     */
    static public class Keyword74 extends AstToken implements IKeyword
    {
        public Keyword74(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 622:  Keyword ::= unchecked
     *</b>
     */
    static public class Keyword75 extends AstToken implements IKeyword
    {
        public Keyword75(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 623:  Keyword ::= unsafe
     *</b>
     */
    static public class Keyword76 extends AstToken implements IKeyword
    {
        public Keyword76(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 624:  Keyword ::= ushort
     *</b>
     */
    static public class Keyword77 extends AstToken implements IKeyword
    {
        public Keyword77(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 625:  Keyword ::= using
     *</b>
     */
    static public class Keyword78 extends AstToken implements IKeyword
    {
        public Keyword78(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 626:  Keyword ::= virtual
     *</b>
     */
    static public class Keyword79 extends AstToken implements IKeyword
    {
        public Keyword79(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 627:  Keyword ::= void
     *</b>
     */
    static public class Keyword80 extends AstToken implements IKeyword
    {
        public Keyword80(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 628:  Keyword ::= volatile
     *</b>
     */
    static public class Keyword81 extends AstToken implements IKeyword
    {
        public Keyword81(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 629:  Keyword ::= where
     *</b>
     */
    static public class Keyword82 extends AstToken implements IKeyword
    {
        public Keyword82(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 630:  Keyword ::= while
     *</b>
     */
    static public class Keyword83 extends AstToken implements IKeyword
    {
        public Keyword83(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 631:  Keyword ::= yield
     *</b>
     */
    static public class Keyword84 extends AstToken implements IKeyword
    {
        public Keyword84(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 638:  AttributeArguments ::= ( PositionalArgumentListOpt )
     *</b>
     */
    static public class AttributeArguments0 extends Ast implements IAttributeArguments
    {
        private IPositionalArgumentListOpt _PositionalArgumentListOpt;

        /**
         * The value returned by <b>getPositionalArgumentListOpt</b> may be <b>null</b>
         */
        public IPositionalArgumentListOpt getPositionalArgumentListOpt() { return _PositionalArgumentListOpt; }

        public AttributeArguments0(IToken leftIToken, IToken rightIToken,
                                   IPositionalArgumentListOpt _PositionalArgumentListOpt)
        {
            super(leftIToken, rightIToken);

            this._PositionalArgumentListOpt = _PositionalArgumentListOpt;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AttributeArguments0)) return false;
            AttributeArguments0 other = (AttributeArguments0    ) o;
            if (_PositionalArgumentListOpt == null && other.getPositionalArgumentListOpt() != null) return false;
            else if (! _PositionalArgumentListOpt.equals(other.getPositionalArgumentListOpt())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getPositionalArgumentListOpt() == null ? 0 : getPositionalArgumentListOpt().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 639:  AttributeArguments ::= ( PositionalArgumentList , NamedArgumentList )
     *</b>
     */
    static public class AttributeArguments1 extends Ast implements IAttributeArguments
    {
        private IPositionalArgumentList _PositionalArgumentList;
        private INamedArgumentList _NamedArgumentList;

        public IPositionalArgumentList getPositionalArgumentList() { return _PositionalArgumentList; }
        public INamedArgumentList getNamedArgumentList() { return _NamedArgumentList; }

        public AttributeArguments1(IToken leftIToken, IToken rightIToken,
                                   IPositionalArgumentList _PositionalArgumentList,
                                   INamedArgumentList _NamedArgumentList)
        {
            super(leftIToken, rightIToken);

            this._PositionalArgumentList = _PositionalArgumentList;
            this._NamedArgumentList = _NamedArgumentList;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AttributeArguments1)) return false;
            AttributeArguments1 other = (AttributeArguments1    ) o;
            if (! _PositionalArgumentList.equals(other.getPositionalArgumentList())) return false;
            if (! _NamedArgumentList.equals(other.getNamedArgumentList())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getPositionalArgumentList().hashCode());
            hash = hash * 31 + (getNamedArgumentList().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 640:  AttributeArguments ::= ( NamedArgumentList )
     *</b>
     */
    static public class AttributeArguments2 extends Ast implements IAttributeArguments
    {
        private INamedArgumentList _NamedArgumentList;

        public INamedArgumentList getNamedArgumentList() { return _NamedArgumentList; }

        public AttributeArguments2(IToken leftIToken, IToken rightIToken,
                                   INamedArgumentList _NamedArgumentList)
        {
            super(leftIToken, rightIToken);

            this._NamedArgumentList = _NamedArgumentList;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof AttributeArguments2)) return false;
            AttributeArguments2 other = (AttributeArguments2    ) o;
            if (! _NamedArgumentList.equals(other.getNamedArgumentList())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getNamedArgumentList().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 653:  TypeParameters ::= AttributesOpt TypeParameter
     *</b>
     */
    static public class TypeParameters0 extends Ast implements ITypeParameters
    {
        private IAttributesOpt _AttributesOpt;
        private TypeParameter _TypeParameter;

        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        public TypeParameter getTypeParameter() { return _TypeParameter; }

        public TypeParameters0(IToken leftIToken, IToken rightIToken,
                               IAttributesOpt _AttributesOpt,
                               TypeParameter _TypeParameter)
        {
            super(leftIToken, rightIToken);

            this._AttributesOpt = _AttributesOpt;
            this._TypeParameter = _TypeParameter;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof TypeParameters0)) return false;
            TypeParameters0 other = (TypeParameters0    ) o;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (! _TypeParameter.equals(other.getTypeParameter())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getTypeParameter().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 654:  TypeParameters ::= TypeParameters , AttributesOpt TypeParameter
     *</b>
     */
    static public class TypeParameters1 extends Ast implements ITypeParameters
    {
        private ITypeParameters _TypeParameters;
        private IAttributesOpt _AttributesOpt;
        private TypeParameter _TypeParameter;

        public ITypeParameters getTypeParameters() { return _TypeParameters; }
        /**
         * The value returned by <b>getAttributesOpt</b> may be <b>null</b>
         */
        public IAttributesOpt getAttributesOpt() { return _AttributesOpt; }
        public TypeParameter getTypeParameter() { return _TypeParameter; }

        public TypeParameters1(IToken leftIToken, IToken rightIToken,
                               ITypeParameters _TypeParameters,
                               IAttributesOpt _AttributesOpt,
                               TypeParameter _TypeParameter)
        {
            super(leftIToken, rightIToken);

            this._TypeParameters = _TypeParameters;
            this._AttributesOpt = _AttributesOpt;
            this._TypeParameter = _TypeParameter;
            initialize();
        }

        public boolean equals(Object o)
        {
            if (o == this) return true;
            //
        // The supers call is not required for now because Ast nodes
        // can only extend the root Ast, AstToken and AstList and none
        // of these nodes contain children.
        //
        // if (! super.equals(o)) return false;
        //
            if (! (o instanceof TypeParameters1)) return false;
            TypeParameters1 other = (TypeParameters1    ) o;
            if (! _TypeParameters.equals(other.getTypeParameters())) return false;
            if (_AttributesOpt == null && other.getAttributesOpt() != null) return false;
            else if (! _AttributesOpt.equals(other.getAttributesOpt())) return false;
            if (! _TypeParameter.equals(other.getTypeParameter())) return false;
            return true;
        }

        public int hashCode()
        {
            int hash = 7;
            hash = hash * 31 + (getTypeParameters().hashCode());
            hash = hash * 31 + (getAttributesOpt() == null ? 0 : getAttributesOpt().hashCode());
            hash = hash * 31 + (getTypeParameter().hashCode());
            return hash;
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 673:  Constraint ::= class
     *</b>
     */
    static public class Constraint0 extends AstToken implements IConstraint
    {
        public Constraint0(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    /**
     *<b>
     *<li>Rule 674:  Constraint ::= struct
     *</b>
     */
    static public class Constraint1 extends AstToken implements IConstraint
    {
        public Constraint1(IToken token) { super(token); initialize(); }

        public int hashCode()
        {
            return toString().hashCode();
        }

        public void accept(Visitor v) { v.visit(this); }
        public void accept(ArgumentVisitor v, Object o) { v.visit(this, o); }
        public Object accept(ResultVisitor v) { return v.visit(this); }
        public Object accept(ResultArgumentVisitor v, Object o) { return v.visit(this, o); }
    }

    public interface Visitor
    {
        void visit(AstToken n);
        void visit(SemiOpt n);
        void visit(ExternOpt n);
        void visit(NewOpt n);
        void visit(PartialOpt n);
        void visit(IdentifierOpt n);
        void visit(CompilationUnit n);
        void visit(Type n);
        void visit(SimpleType n);
        void visit(NumericType n);
        void visit(NullableType n);
        void visit(ArgumentList n);
        void visit(ParenthesizedExpression n);
        void visit(InvocationExpression n);
        void visit(ElementAccess n);
        void visit(ExpressionList n);
        void visit(ThisAccess n);
        void visit(PostIncrementExpression n);
        void visit(PostDecrementExpression n);
        void visit(ObjectCreationExpression n);
        void visit(GenericDimensionSpecifier n);
        void visit(CheckedExpression n);
        void visit(UncheckedExpression n);
        void visit(DefaultValueExpression n);
        void visit(AnonymousMethodExpression n);
        void visit(AnonymousMethodSignature n);
        void visit(AnonymousMethodParameterList n);
        void visit(AnonymousMethodParameter n);
        void visit(PreIncrementExpression n);
        void visit(PreDecrementExpression n);
        void visit(CastExpression n);
        void visit(AndExpression n);
        void visit(ExclusiveOrExpression n);
        void visit(InclusiveOrExpression n);
        void visit(ConditionalAndExpression n);
        void visit(ConditionalOrExpression n);
        void visit(NullCoalescingExpression n);
        void visit(ConditionalExpression n);
        void visit(Assignment n);
        void visit(Block n);
        void visit(StatementList n);
        void visit(EmptyStatement n);
        void visit(LabeledStatement n);
        void visit(LocalVariableDeclaration n);
        void visit(LocalVariableDeclarators n);
        void visit(LocalConstantDeclaration n);
        void visit(ExpressionStatement n);
        void visit(IfStatement n);
        void visit(ElseStatement n);
        void visit(SwitchStatement n);
        void visit(SwitchBlock n);
        void visit(SwitchSections n);
        void visit(SwitchSection n);
        void visit(SwitchLabels n);
        void visit(WhileStatement n);
        void visit(DoStatement n);
        void visit(ForStatement n);
        void visit(StatementExpressionList n);
        void visit(ForeachStatement n);
        void visit(BreakStatement n);
        void visit(ContinueStatement n);
        void visit(ReturnStatement n);
        void visit(ThrowStatement n);
        void visit(CatchClauses n);
        void visit(SpecificCatchClauses n);
        void visit(SpecificCatchClause n);
        void visit(GeneralCatchClause n);
        void visit(FinallyClause n);
        void visit(CheckedStatement n);
        void visit(UncheckedStatement n);
        void visit(LockStatement n);
        void visit(UsingStatement n);
        void visit(NamespaceDeclaration n);
        void visit(NamespaceBody n);
        void visit(ExternAliasDirectives n);
        void visit(ExternAliasDirective n);
        void visit(UsingDirectives n);
        void visit(UsingAliasDirective n);
        void visit(UsingNamespaceDirective n);
        void visit(NamespaceMemberDeclarations n);
        void visit(Modifiers n);
        void visit(ClassDeclaration n);
        void visit(ClassBaseOpt n);
        void visit(ClassBase n);
        void visit(ClassBody n);
        void visit(ClassMemberDeclarations n);
        void visit(ConstantDeclaration n);
        void visit(ConstantDeclarators n);
        void visit(ConstantDeclarator n);
        void visit(FieldDeclaration n);
        void visit(VariableDeclarators n);
        void visit(MethodDeclaration n);
        void visit(MethodHeader n);
        void visit(MethodBody n);
        void visit(FormalParameterList n);
        void visit(FixedParameters n);
        void visit(FixedParameter n);
        void visit(ParameterArray n);
        void visit(PropertyDeclaration n);
        void visit(GetAccessorDeclaration n);
        void visit(SetAccessorDeclaration n);
        void visit(AccessorBody n);
        void visit(AddAccessorDeclaration n);
        void visit(RemoveAccessorDeclaration n);
        void visit(IndexerDeclaration n);
        void visit(OperatorDeclaration n);
        void visit(SymbolOperatorDeclarator n);
        void visit(OperatorBody n);
        void visit(ConstructorDeclaration n);
        void visit(ConstructorDeclarator n);
        void visit(ConstructorBody n);
        void visit(FinalizerDeclaration n);
        void visit(FinalizerBody n);
        void visit(StructDeclaration n);
        void visit(StructInterfacesOpt n);
        void visit(StructInterfaces n);
        void visit(StructBody n);
        void visit(StructMemberDeclarations n);
        void visit(ArrayType n);
        void visit(RankSpecifiers n);
        void visit(RankSpecifier n);
        void visit(VariableInitializerList n);
        void visit(InterfaceDeclaration n);
        void visit(InterfaceBase n);
        void visit(InterfaceBody n);
        void visit(InterfaceMemberDeclarations n);
        void visit(InterfaceMethodDeclaration n);
        void visit(InterfacePropertyDeclaration n);
        void visit(InterfaceEventDeclaration n);
        void visit(InterfaceIndexerDeclaration n);
        void visit(EnumDeclaration n);
        void visit(EnumBase n);
        void visit(EnumMemberDeclarations n);
        void visit(DelegateDeclaration n);
        void visit(AttributeSections n);
        void visit(AttributeTargetSpecifier n);
        void visit(AttributeTarget n);
        void visit(AttributeList n);
        void visit(Attribute n);
        void visit(PositionalArgumentList n);
        void visit(NamedArgumentList n);
        void visit(NamedArgument n);
        void visit(TypeParameterList n);
        void visit(TypeParameter n);
        void visit(TypeArgumentList n);
        void visit(TypeArguments n);
        void visit(TypeParameterConstraintsClauses n);
        void visit(TypeParameterConstraintsClause n);
        void visit(TypeParameterConstraints n);
        void visit(Constraints n);
        void visit(ConstructorConstraint n);
        void visit(BooleanLiteral0 n);
        void visit(BooleanLiteral1 n);
        void visit(Name0 n);
        void visit(Name1 n);
        void visit(Name2 n);
        void visit(NonNamedType0 n);
        void visit(NonNamedType1 n);
        void visit(IntegralType0 n);
        void visit(IntegralType1 n);
        void visit(IntegralType2 n);
        void visit(IntegralType3 n);
        void visit(IntegralType4 n);
        void visit(IntegralType5 n);
        void visit(IntegralType6 n);
        void visit(IntegralType7 n);
        void visit(IntegralType8 n);
        void visit(FloatingPointType0 n);
        void visit(FloatingPointType1 n);
        void visit(ClassType0 n);
        void visit(ClassType1 n);
        void visit(Argument0 n);
        void visit(Argument1 n);
        void visit(MemberAccess0 n);
        void visit(MemberAccess1 n);
        void visit(MemberAccess2 n);
        void visit(PredefinedType0 n);
        void visit(PredefinedType1 n);
        void visit(PredefinedType2 n);
        void visit(PredefinedType3 n);
        void visit(PredefinedType4 n);
        void visit(PredefinedType5 n);
        void visit(PredefinedType6 n);
        void visit(PredefinedType7 n);
        void visit(PredefinedType8 n);
        void visit(PredefinedType9 n);
        void visit(PredefinedType10 n);
        void visit(PredefinedType11 n);
        void visit(PredefinedType12 n);
        void visit(PredefinedType13 n);
        void visit(PredefinedType14 n);
        void visit(BaseAccess0 n);
        void visit(BaseAccess1 n);
        void visit(ArrayCreationExpression0 n);
        void visit(ArrayCreationExpression1 n);
        void visit(TypeofExpression0 n);
        void visit(TypeofExpression1 n);
        void visit(UnboundTypeName0 n);
        void visit(UnboundTypeName1 n);
        void visit(UnboundTypeName2 n);
        void visit(Commas0 n);
        void visit(Commas1 n);
        void visit(UnaryExpression0 n);
        void visit(UnaryExpression1 n);
        void visit(UnaryExpression2 n);
        void visit(UnaryExpression3 n);
        void visit(MultiplicativeExpression0 n);
        void visit(MultiplicativeExpression1 n);
        void visit(MultiplicativeExpression2 n);
        void visit(AdditiveExpression0 n);
        void visit(AdditiveExpression1 n);
        void visit(ShiftExpression0 n);
        void visit(ShiftExpression1 n);
        void visit(RelationalExpression0 n);
        void visit(RelationalExpression1 n);
        void visit(RelationalExpression2 n);
        void visit(RelationalExpression3 n);
        void visit(RelationalExpression4 n);
        void visit(RelationalExpression5 n);
        void visit(EqualityExpression0 n);
        void visit(EqualityExpression1 n);
        void visit(AssignmentOperator0 n);
        void visit(AssignmentOperator1 n);
        void visit(AssignmentOperator2 n);
        void visit(AssignmentOperator3 n);
        void visit(AssignmentOperator4 n);
        void visit(AssignmentOperator5 n);
        void visit(AssignmentOperator6 n);
        void visit(AssignmentOperator7 n);
        void visit(AssignmentOperator8 n);
        void visit(AssignmentOperator9 n);
        void visit(AssignmentOperator10 n);
        void visit(DeclarationStatement0 n);
        void visit(DeclarationStatement1 n);
        void visit(LocalVariableDeclarator0 n);
        void visit(LocalVariableDeclarator1 n);
        void visit(SwitchLabel0 n);
        void visit(SwitchLabel1 n);
        void visit(GotoStatement0 n);
        void visit(GotoStatement1 n);
        void visit(GotoStatement2 n);
        void visit(TryStatement0 n);
        void visit(TryStatement1 n);
        void visit(YieldStatement0 n);
        void visit(YieldStatement1 n);
        void visit(Modifier0 n);
        void visit(Modifier1 n);
        void visit(Modifier2 n);
        void visit(Modifier3 n);
        void visit(Modifier4 n);
        void visit(Modifier5 n);
        void visit(Modifier6 n);
        void visit(Modifier7 n);
        void visit(Modifier8 n);
        void visit(Modifier9 n);
        void visit(Modifier10 n);
        void visit(Modifier11 n);
        void visit(Modifier12 n);
        void visit(VariableDeclarator0 n);
        void visit(VariableDeclarator1 n);
        void visit(ParameterModifier0 n);
        void visit(ParameterModifier1 n);
        void visit(AccessorDeclarations0 n);
        void visit(AccessorDeclarations1 n);
        void visit(AccessorModifier0 n);
        void visit(AccessorModifier1 n);
        void visit(AccessorModifier2 n);
        void visit(AccessorModifier3 n);
        void visit(AccessorModifier4 n);
        void visit(EventDeclaration0 n);
        void visit(EventDeclaration1 n);
        void visit(EventAccessorDeclarations0 n);
        void visit(EventAccessorDeclarations1 n);
        void visit(IndexerDeclarator0 n);
        void visit(IndexerDeclarator1 n);
        void visit(OverloadableOperator0 n);
        void visit(OverloadableOperator1 n);
        void visit(OverloadableOperator2 n);
        void visit(OverloadableOperator3 n);
        void visit(OverloadableOperator4 n);
        void visit(OverloadableOperator5 n);
        void visit(OverloadableOperator6 n);
        void visit(OverloadableOperator7 n);
        void visit(OverloadableOperator8 n);
        void visit(OverloadableOperator9 n);
        void visit(OverloadableOperator10 n);
        void visit(OverloadableOperator11 n);
        void visit(OverloadableOperator12 n);
        void visit(OverloadableOperator13 n);
        void visit(OverloadableOperator14 n);
        void visit(OverloadableOperator15 n);
        void visit(OverloadableOperator16 n);
        void visit(OverloadableOperator17 n);
        void visit(OverloadableOperator18 n);
        void visit(OverloadableOperator19 n);
        void visit(OverloadableOperator20 n);
        void visit(OverloadableOperator21 n);
        void visit(ConversionOperatorDeclarator0 n);
        void visit(ConversionOperatorDeclarator1 n);
        void visit(ConstructorInitializer0 n);
        void visit(ConstructorInitializer1 n);
        void visit(DimSeparators0 n);
        void visit(DimSeparators1 n);
        void visit(ArrayInitializer0 n);
        void visit(ArrayInitializer1 n);
        void visit(InterfaceAccessors0 n);
        void visit(InterfaceAccessors1 n);
        void visit(InterfaceAccessors2 n);
        void visit(InterfaceAccessors3 n);
        void visit(EnumBody0 n);
        void visit(EnumBody1 n);
        void visit(EnumMemberDeclaration0 n);
        void visit(EnumMemberDeclaration1 n);
        void visit(AttributeSection0 n);
        void visit(AttributeSection1 n);
        void visit(Keyword0 n);
        void visit(Keyword1 n);
        void visit(Keyword2 n);
        void visit(Keyword3 n);
        void visit(Keyword4 n);
        void visit(Keyword5 n);
        void visit(Keyword6 n);
        void visit(Keyword7 n);
        void visit(Keyword8 n);
        void visit(Keyword9 n);
        void visit(Keyword10 n);
        void visit(Keyword11 n);
        void visit(Keyword12 n);
        void visit(Keyword13 n);
        void visit(Keyword14 n);
        void visit(Keyword15 n);
        void visit(Keyword16 n);
        void visit(Keyword17 n);
        void visit(Keyword18 n);
        void visit(Keyword19 n);
        void visit(Keyword20 n);
        void visit(Keyword21 n);
        void visit(Keyword22 n);
        void visit(Keyword23 n);
        void visit(Keyword24 n);
        void visit(Keyword25 n);
        void visit(Keyword26 n);
        void visit(Keyword27 n);
        void visit(Keyword28 n);
        void visit(Keyword29 n);
        void visit(Keyword30 n);
        void visit(Keyword31 n);
        void visit(Keyword32 n);
        void visit(Keyword33 n);
        void visit(Keyword34 n);
        void visit(Keyword35 n);
        void visit(Keyword36 n);
        void visit(Keyword37 n);
        void visit(Keyword38 n);
        void visit(Keyword39 n);
        void visit(Keyword40 n);
        void visit(Keyword41 n);
        void visit(Keyword42 n);
        void visit(Keyword43 n);
        void visit(Keyword44 n);
        void visit(Keyword45 n);
        void visit(Keyword46 n);
        void visit(Keyword47 n);
        void visit(Keyword48 n);
        void visit(Keyword49 n);
        void visit(Keyword50 n);
        void visit(Keyword51 n);
        void visit(Keyword52 n);
        void visit(Keyword53 n);
        void visit(Keyword54 n);
        void visit(Keyword55 n);
        void visit(Keyword56 n);
        void visit(Keyword57 n);
        void visit(Keyword58 n);
        void visit(Keyword59 n);
        void visit(Keyword60 n);
        void visit(Keyword61 n);
        void visit(Keyword62 n);
        void visit(Keyword63 n);
        void visit(Keyword64 n);
        void visit(Keyword65 n);
        void visit(Keyword66 n);
        void visit(Keyword67 n);
        void visit(Keyword68 n);
        void visit(Keyword69 n);
        void visit(Keyword70 n);
        void visit(Keyword71 n);
        void visit(Keyword72 n);
        void visit(Keyword73 n);
        void visit(Keyword74 n);
        void visit(Keyword75 n);
        void visit(Keyword76 n);
        void visit(Keyword77 n);
        void visit(Keyword78 n);
        void visit(Keyword79 n);
        void visit(Keyword80 n);
        void visit(Keyword81 n);
        void visit(Keyword82 n);
        void visit(Keyword83 n);
        void visit(Keyword84 n);
        void visit(AttributeArguments0 n);
        void visit(AttributeArguments1 n);
        void visit(AttributeArguments2 n);
        void visit(TypeParameters0 n);
        void visit(TypeParameters1 n);
        void visit(Constraint0 n);
        void visit(Constraint1 n);
    }
    public interface ArgumentVisitor
    {
        void visit(AstToken n, Object o);
        void visit(SemiOpt n, Object o);
        void visit(ExternOpt n, Object o);
        void visit(NewOpt n, Object o);
        void visit(PartialOpt n, Object o);
        void visit(IdentifierOpt n, Object o);
        void visit(CompilationUnit n, Object o);
        void visit(Type n, Object o);
        void visit(SimpleType n, Object o);
        void visit(NumericType n, Object o);
        void visit(NullableType n, Object o);
        void visit(ArgumentList n, Object o);
        void visit(ParenthesizedExpression n, Object o);
        void visit(InvocationExpression n, Object o);
        void visit(ElementAccess n, Object o);
        void visit(ExpressionList n, Object o);
        void visit(ThisAccess n, Object o);
        void visit(PostIncrementExpression n, Object o);
        void visit(PostDecrementExpression n, Object o);
        void visit(ObjectCreationExpression n, Object o);
        void visit(GenericDimensionSpecifier n, Object o);
        void visit(CheckedExpression n, Object o);
        void visit(UncheckedExpression n, Object o);
        void visit(DefaultValueExpression n, Object o);
        void visit(AnonymousMethodExpression n, Object o);
        void visit(AnonymousMethodSignature n, Object o);
        void visit(AnonymousMethodParameterList n, Object o);
        void visit(AnonymousMethodParameter n, Object o);
        void visit(PreIncrementExpression n, Object o);
        void visit(PreDecrementExpression n, Object o);
        void visit(CastExpression n, Object o);
        void visit(AndExpression n, Object o);
        void visit(ExclusiveOrExpression n, Object o);
        void visit(InclusiveOrExpression n, Object o);
        void visit(ConditionalAndExpression n, Object o);
        void visit(ConditionalOrExpression n, Object o);
        void visit(NullCoalescingExpression n, Object o);
        void visit(ConditionalExpression n, Object o);
        void visit(Assignment n, Object o);
        void visit(Block n, Object o);
        void visit(StatementList n, Object o);
        void visit(EmptyStatement n, Object o);
        void visit(LabeledStatement n, Object o);
        void visit(LocalVariableDeclaration n, Object o);
        void visit(LocalVariableDeclarators n, Object o);
        void visit(LocalConstantDeclaration n, Object o);
        void visit(ExpressionStatement n, Object o);
        void visit(IfStatement n, Object o);
        void visit(ElseStatement n, Object o);
        void visit(SwitchStatement n, Object o);
        void visit(SwitchBlock n, Object o);
        void visit(SwitchSections n, Object o);
        void visit(SwitchSection n, Object o);
        void visit(SwitchLabels n, Object o);
        void visit(WhileStatement n, Object o);
        void visit(DoStatement n, Object o);
        void visit(ForStatement n, Object o);
        void visit(StatementExpressionList n, Object o);
        void visit(ForeachStatement n, Object o);
        void visit(BreakStatement n, Object o);
        void visit(ContinueStatement n, Object o);
        void visit(ReturnStatement n, Object o);
        void visit(ThrowStatement n, Object o);
        void visit(CatchClauses n, Object o);
        void visit(SpecificCatchClauses n, Object o);
        void visit(SpecificCatchClause n, Object o);
        void visit(GeneralCatchClause n, Object o);
        void visit(FinallyClause n, Object o);
        void visit(CheckedStatement n, Object o);
        void visit(UncheckedStatement n, Object o);
        void visit(LockStatement n, Object o);
        void visit(UsingStatement n, Object o);
        void visit(NamespaceDeclaration n, Object o);
        void visit(NamespaceBody n, Object o);
        void visit(ExternAliasDirectives n, Object o);
        void visit(ExternAliasDirective n, Object o);
        void visit(UsingDirectives n, Object o);
        void visit(UsingAliasDirective n, Object o);
        void visit(UsingNamespaceDirective n, Object o);
        void visit(NamespaceMemberDeclarations n, Object o);
        void visit(Modifiers n, Object o);
        void visit(ClassDeclaration n, Object o);
        void visit(ClassBaseOpt n, Object o);
        void visit(ClassBase n, Object o);
        void visit(ClassBody n, Object o);
        void visit(ClassMemberDeclarations n, Object o);
        void visit(ConstantDeclaration n, Object o);
        void visit(ConstantDeclarators n, Object o);
        void visit(ConstantDeclarator n, Object o);
        void visit(FieldDeclaration n, Object o);
        void visit(VariableDeclarators n, Object o);
        void visit(MethodDeclaration n, Object o);
        void visit(MethodHeader n, Object o);
        void visit(MethodBody n, Object o);
        void visit(FormalParameterList n, Object o);
        void visit(FixedParameters n, Object o);
        void visit(FixedParameter n, Object o);
        void visit(ParameterArray n, Object o);
        void visit(PropertyDeclaration n, Object o);
        void visit(GetAccessorDeclaration n, Object o);
        void visit(SetAccessorDeclaration n, Object o);
        void visit(AccessorBody n, Object o);
        void visit(AddAccessorDeclaration n, Object o);
        void visit(RemoveAccessorDeclaration n, Object o);
        void visit(IndexerDeclaration n, Object o);
        void visit(OperatorDeclaration n, Object o);
        void visit(SymbolOperatorDeclarator n, Object o);
        void visit(OperatorBody n, Object o);
        void visit(ConstructorDeclaration n, Object o);
        void visit(ConstructorDeclarator n, Object o);
        void visit(ConstructorBody n, Object o);
        void visit(FinalizerDeclaration n, Object o);
        void visit(FinalizerBody n, Object o);
        void visit(StructDeclaration n, Object o);
        void visit(StructInterfacesOpt n, Object o);
        void visit(StructInterfaces n, Object o);
        void visit(StructBody n, Object o);
        void visit(StructMemberDeclarations n, Object o);
        void visit(ArrayType n, Object o);
        void visit(RankSpecifiers n, Object o);
        void visit(RankSpecifier n, Object o);
        void visit(VariableInitializerList n, Object o);
        void visit(InterfaceDeclaration n, Object o);
        void visit(InterfaceBase n, Object o);
        void visit(InterfaceBody n, Object o);
        void visit(InterfaceMemberDeclarations n, Object o);
        void visit(InterfaceMethodDeclaration n, Object o);
        void visit(InterfacePropertyDeclaration n, Object o);
        void visit(InterfaceEventDeclaration n, Object o);
        void visit(InterfaceIndexerDeclaration n, Object o);
        void visit(EnumDeclaration n, Object o);
        void visit(EnumBase n, Object o);
        void visit(EnumMemberDeclarations n, Object o);
        void visit(DelegateDeclaration n, Object o);
        void visit(AttributeSections n, Object o);
        void visit(AttributeTargetSpecifier n, Object o);
        void visit(AttributeTarget n, Object o);
        void visit(AttributeList n, Object o);
        void visit(Attribute n, Object o);
        void visit(PositionalArgumentList n, Object o);
        void visit(NamedArgumentList n, Object o);
        void visit(NamedArgument n, Object o);
        void visit(TypeParameterList n, Object o);
        void visit(TypeParameter n, Object o);
        void visit(TypeArgumentList n, Object o);
        void visit(TypeArguments n, Object o);
        void visit(TypeParameterConstraintsClauses n, Object o);
        void visit(TypeParameterConstraintsClause n, Object o);
        void visit(TypeParameterConstraints n, Object o);
        void visit(Constraints n, Object o);
        void visit(ConstructorConstraint n, Object o);
        void visit(BooleanLiteral0 n, Object o);
        void visit(BooleanLiteral1 n, Object o);
        void visit(Name0 n, Object o);
        void visit(Name1 n, Object o);
        void visit(Name2 n, Object o);
        void visit(NonNamedType0 n, Object o);
        void visit(NonNamedType1 n, Object o);
        void visit(IntegralType0 n, Object o);
        void visit(IntegralType1 n, Object o);
        void visit(IntegralType2 n, Object o);
        void visit(IntegralType3 n, Object o);
        void visit(IntegralType4 n, Object o);
        void visit(IntegralType5 n, Object o);
        void visit(IntegralType6 n, Object o);
        void visit(IntegralType7 n, Object o);
        void visit(IntegralType8 n, Object o);
        void visit(FloatingPointType0 n, Object o);
        void visit(FloatingPointType1 n, Object o);
        void visit(ClassType0 n, Object o);
        void visit(ClassType1 n, Object o);
        void visit(Argument0 n, Object o);
        void visit(Argument1 n, Object o);
        void visit(MemberAccess0 n, Object o);
        void visit(MemberAccess1 n, Object o);
        void visit(MemberAccess2 n, Object o);
        void visit(PredefinedType0 n, Object o);
        void visit(PredefinedType1 n, Object o);
        void visit(PredefinedType2 n, Object o);
        void visit(PredefinedType3 n, Object o);
        void visit(PredefinedType4 n, Object o);
        void visit(PredefinedType5 n, Object o);
        void visit(PredefinedType6 n, Object o);
        void visit(PredefinedType7 n, Object o);
        void visit(PredefinedType8 n, Object o);
        void visit(PredefinedType9 n, Object o);
        void visit(PredefinedType10 n, Object o);
        void visit(PredefinedType11 n, Object o);
        void visit(PredefinedType12 n, Object o);
        void visit(PredefinedType13 n, Object o);
        void visit(PredefinedType14 n, Object o);
        void visit(BaseAccess0 n, Object o);
        void visit(BaseAccess1 n, Object o);
        void visit(ArrayCreationExpression0 n, Object o);
        void visit(ArrayCreationExpression1 n, Object o);
        void visit(TypeofExpression0 n, Object o);
        void visit(TypeofExpression1 n, Object o);
        void visit(UnboundTypeName0 n, Object o);
        void visit(UnboundTypeName1 n, Object o);
        void visit(UnboundTypeName2 n, Object o);
        void visit(Commas0 n, Object o);
        void visit(Commas1 n, Object o);
        void visit(UnaryExpression0 n, Object o);
        void visit(UnaryExpression1 n, Object o);
        void visit(UnaryExpression2 n, Object o);
        void visit(UnaryExpression3 n, Object o);
        void visit(MultiplicativeExpression0 n, Object o);
        void visit(MultiplicativeExpression1 n, Object o);
        void visit(MultiplicativeExpression2 n, Object o);
        void visit(AdditiveExpression0 n, Object o);
        void visit(AdditiveExpression1 n, Object o);
        void visit(ShiftExpression0 n, Object o);
        void visit(ShiftExpression1 n, Object o);
        void visit(RelationalExpression0 n, Object o);
        void visit(RelationalExpression1 n, Object o);
        void visit(RelationalExpression2 n, Object o);
        void visit(RelationalExpression3 n, Object o);
        void visit(RelationalExpression4 n, Object o);
        void visit(RelationalExpression5 n, Object o);
        void visit(EqualityExpression0 n, Object o);
        void visit(EqualityExpression1 n, Object o);
        void visit(AssignmentOperator0 n, Object o);
        void visit(AssignmentOperator1 n, Object o);
        void visit(AssignmentOperator2 n, Object o);
        void visit(AssignmentOperator3 n, Object o);
        void visit(AssignmentOperator4 n, Object o);
        void visit(AssignmentOperator5 n, Object o);
        void visit(AssignmentOperator6 n, Object o);
        void visit(AssignmentOperator7 n, Object o);
        void visit(AssignmentOperator8 n, Object o);
        void visit(AssignmentOperator9 n, Object o);
        void visit(AssignmentOperator10 n, Object o);
        void visit(DeclarationStatement0 n, Object o);
        void visit(DeclarationStatement1 n, Object o);
        void visit(LocalVariableDeclarator0 n, Object o);
        void visit(LocalVariableDeclarator1 n, Object o);
        void visit(SwitchLabel0 n, Object o);
        void visit(SwitchLabel1 n, Object o);
        void visit(GotoStatement0 n, Object o);
        void visit(GotoStatement1 n, Object o);
        void visit(GotoStatement2 n, Object o);
        void visit(TryStatement0 n, Object o);
        void visit(TryStatement1 n, Object o);
        void visit(YieldStatement0 n, Object o);
        void visit(YieldStatement1 n, Object o);
        void visit(Modifier0 n, Object o);
        void visit(Modifier1 n, Object o);
        void visit(Modifier2 n, Object o);
        void visit(Modifier3 n, Object o);
        void visit(Modifier4 n, Object o);
        void visit(Modifier5 n, Object o);
        void visit(Modifier6 n, Object o);
        void visit(Modifier7 n, Object o);
        void visit(Modifier8 n, Object o);
        void visit(Modifier9 n, Object o);
        void visit(Modifier10 n, Object o);
        void visit(Modifier11 n, Object o);
        void visit(Modifier12 n, Object o);
        void visit(VariableDeclarator0 n, Object o);
        void visit(VariableDeclarator1 n, Object o);
        void visit(ParameterModifier0 n, Object o);
        void visit(ParameterModifier1 n, Object o);
        void visit(AccessorDeclarations0 n, Object o);
        void visit(AccessorDeclarations1 n, Object o);
        void visit(AccessorModifier0 n, Object o);
        void visit(AccessorModifier1 n, Object o);
        void visit(AccessorModifier2 n, Object o);
        void visit(AccessorModifier3 n, Object o);
        void visit(AccessorModifier4 n, Object o);
        void visit(EventDeclaration0 n, Object o);
        void visit(EventDeclaration1 n, Object o);
        void visit(EventAccessorDeclarations0 n, Object o);
        void visit(EventAccessorDeclarations1 n, Object o);
        void visit(IndexerDeclarator0 n, Object o);
        void visit(IndexerDeclarator1 n, Object o);
        void visit(OverloadableOperator0 n, Object o);
        void visit(OverloadableOperator1 n, Object o);
        void visit(OverloadableOperator2 n, Object o);
        void visit(OverloadableOperator3 n, Object o);
        void visit(OverloadableOperator4 n, Object o);
        void visit(OverloadableOperator5 n, Object o);
        void visit(OverloadableOperator6 n, Object o);
        void visit(OverloadableOperator7 n, Object o);
        void visit(OverloadableOperator8 n, Object o);
        void visit(OverloadableOperator9 n, Object o);
        void visit(OverloadableOperator10 n, Object o);
        void visit(OverloadableOperator11 n, Object o);
        void visit(OverloadableOperator12 n, Object o);
        void visit(OverloadableOperator13 n, Object o);
        void visit(OverloadableOperator14 n, Object o);
        void visit(OverloadableOperator15 n, Object o);
        void visit(OverloadableOperator16 n, Object o);
        void visit(OverloadableOperator17 n, Object o);
        void visit(OverloadableOperator18 n, Object o);
        void visit(OverloadableOperator19 n, Object o);
        void visit(OverloadableOperator20 n, Object o);
        void visit(OverloadableOperator21 n, Object o);
        void visit(ConversionOperatorDeclarator0 n, Object o);
        void visit(ConversionOperatorDeclarator1 n, Object o);
        void visit(ConstructorInitializer0 n, Object o);
        void visit(ConstructorInitializer1 n, Object o);
        void visit(DimSeparators0 n, Object o);
        void visit(DimSeparators1 n, Object o);
        void visit(ArrayInitializer0 n, Object o);
        void visit(ArrayInitializer1 n, Object o);
        void visit(InterfaceAccessors0 n, Object o);
        void visit(InterfaceAccessors1 n, Object o);
        void visit(InterfaceAccessors2 n, Object o);
        void visit(InterfaceAccessors3 n, Object o);
        void visit(EnumBody0 n, Object o);
        void visit(EnumBody1 n, Object o);
        void visit(EnumMemberDeclaration0 n, Object o);
        void visit(EnumMemberDeclaration1 n, Object o);
        void visit(AttributeSection0 n, Object o);
        void visit(AttributeSection1 n, Object o);
        void visit(Keyword0 n, Object o);
        void visit(Keyword1 n, Object o);
        void visit(Keyword2 n, Object o);
        void visit(Keyword3 n, Object o);
        void visit(Keyword4 n, Object o);
        void visit(Keyword5 n, Object o);
        void visit(Keyword6 n, Object o);
        void visit(Keyword7 n, Object o);
        void visit(Keyword8 n, Object o);
        void visit(Keyword9 n, Object o);
        void visit(Keyword10 n, Object o);
        void visit(Keyword11 n, Object o);
        void visit(Keyword12 n, Object o);
        void visit(Keyword13 n, Object o);
        void visit(Keyword14 n, Object o);
        void visit(Keyword15 n, Object o);
        void visit(Keyword16 n, Object o);
        void visit(Keyword17 n, Object o);
        void visit(Keyword18 n, Object o);
        void visit(Keyword19 n, Object o);
        void visit(Keyword20 n, Object o);
        void visit(Keyword21 n, Object o);
        void visit(Keyword22 n, Object o);
        void visit(Keyword23 n, Object o);
        void visit(Keyword24 n, Object o);
        void visit(Keyword25 n, Object o);
        void visit(Keyword26 n, Object o);
        void visit(Keyword27 n, Object o);
        void visit(Keyword28 n, Object o);
        void visit(Keyword29 n, Object o);
        void visit(Keyword30 n, Object o);
        void visit(Keyword31 n, Object o);
        void visit(Keyword32 n, Object o);
        void visit(Keyword33 n, Object o);
        void visit(Keyword34 n, Object o);
        void visit(Keyword35 n, Object o);
        void visit(Keyword36 n, Object o);
        void visit(Keyword37 n, Object o);
        void visit(Keyword38 n, Object o);
        void visit(Keyword39 n, Object o);
        void visit(Keyword40 n, Object o);
        void visit(Keyword41 n, Object o);
        void visit(Keyword42 n, Object o);
        void visit(Keyword43 n, Object o);
        void visit(Keyword44 n, Object o);
        void visit(Keyword45 n, Object o);
        void visit(Keyword46 n, Object o);
        void visit(Keyword47 n, Object o);
        void visit(Keyword48 n, Object o);
        void visit(Keyword49 n, Object o);
        void visit(Keyword50 n, Object o);
        void visit(Keyword51 n, Object o);
        void visit(Keyword52 n, Object o);
        void visit(Keyword53 n, Object o);
        void visit(Keyword54 n, Object o);
        void visit(Keyword55 n, Object o);
        void visit(Keyword56 n, Object o);
        void visit(Keyword57 n, Object o);
        void visit(Keyword58 n, Object o);
        void visit(Keyword59 n, Object o);
        void visit(Keyword60 n, Object o);
        void visit(Keyword61 n, Object o);
        void visit(Keyword62 n, Object o);
        void visit(Keyword63 n, Object o);
        void visit(Keyword64 n, Object o);
        void visit(Keyword65 n, Object o);
        void visit(Keyword66 n, Object o);
        void visit(Keyword67 n, Object o);
        void visit(Keyword68 n, Object o);
        void visit(Keyword69 n, Object o);
        void visit(Keyword70 n, Object o);
        void visit(Keyword71 n, Object o);
        void visit(Keyword72 n, Object o);
        void visit(Keyword73 n, Object o);
        void visit(Keyword74 n, Object o);
        void visit(Keyword75 n, Object o);
        void visit(Keyword76 n, Object o);
        void visit(Keyword77 n, Object o);
        void visit(Keyword78 n, Object o);
        void visit(Keyword79 n, Object o);
        void visit(Keyword80 n, Object o);
        void visit(Keyword81 n, Object o);
        void visit(Keyword82 n, Object o);
        void visit(Keyword83 n, Object o);
        void visit(Keyword84 n, Object o);
        void visit(AttributeArguments0 n, Object o);
        void visit(AttributeArguments1 n, Object o);
        void visit(AttributeArguments2 n, Object o);
        void visit(TypeParameters0 n, Object o);
        void visit(TypeParameters1 n, Object o);
        void visit(Constraint0 n, Object o);
        void visit(Constraint1 n, Object o);
    }
    public interface ResultVisitor
    {
        Object visit(AstToken n);
        Object visit(SemiOpt n);
        Object visit(ExternOpt n);
        Object visit(NewOpt n);
        Object visit(PartialOpt n);
        Object visit(IdentifierOpt n);
        Object visit(CompilationUnit n);
        Object visit(Type n);
        Object visit(SimpleType n);
        Object visit(NumericType n);
        Object visit(NullableType n);
        Object visit(ArgumentList n);
        Object visit(ParenthesizedExpression n);
        Object visit(InvocationExpression n);
        Object visit(ElementAccess n);
        Object visit(ExpressionList n);
        Object visit(ThisAccess n);
        Object visit(PostIncrementExpression n);
        Object visit(PostDecrementExpression n);
        Object visit(ObjectCreationExpression n);
        Object visit(GenericDimensionSpecifier n);
        Object visit(CheckedExpression n);
        Object visit(UncheckedExpression n);
        Object visit(DefaultValueExpression n);
        Object visit(AnonymousMethodExpression n);
        Object visit(AnonymousMethodSignature n);
        Object visit(AnonymousMethodParameterList n);
        Object visit(AnonymousMethodParameter n);
        Object visit(PreIncrementExpression n);
        Object visit(PreDecrementExpression n);
        Object visit(CastExpression n);
        Object visit(AndExpression n);
        Object visit(ExclusiveOrExpression n);
        Object visit(InclusiveOrExpression n);
        Object visit(ConditionalAndExpression n);
        Object visit(ConditionalOrExpression n);
        Object visit(NullCoalescingExpression n);
        Object visit(ConditionalExpression n);
        Object visit(Assignment n);
        Object visit(Block n);
        Object visit(StatementList n);
        Object visit(EmptyStatement n);
        Object visit(LabeledStatement n);
        Object visit(LocalVariableDeclaration n);
        Object visit(LocalVariableDeclarators n);
        Object visit(LocalConstantDeclaration n);
        Object visit(ExpressionStatement n);
        Object visit(IfStatement n);
        Object visit(ElseStatement n);
        Object visit(SwitchStatement n);
        Object visit(SwitchBlock n);
        Object visit(SwitchSections n);
        Object visit(SwitchSection n);
        Object visit(SwitchLabels n);
        Object visit(WhileStatement n);
        Object visit(DoStatement n);
        Object visit(ForStatement n);
        Object visit(StatementExpressionList n);
        Object visit(ForeachStatement n);
        Object visit(BreakStatement n);
        Object visit(ContinueStatement n);
        Object visit(ReturnStatement n);
        Object visit(ThrowStatement n);
        Object visit(CatchClauses n);
        Object visit(SpecificCatchClauses n);
        Object visit(SpecificCatchClause n);
        Object visit(GeneralCatchClause n);
        Object visit(FinallyClause n);
        Object visit(CheckedStatement n);
        Object visit(UncheckedStatement n);
        Object visit(LockStatement n);
        Object visit(UsingStatement n);
        Object visit(NamespaceDeclaration n);
        Object visit(NamespaceBody n);
        Object visit(ExternAliasDirectives n);
        Object visit(ExternAliasDirective n);
        Object visit(UsingDirectives n);
        Object visit(UsingAliasDirective n);
        Object visit(UsingNamespaceDirective n);
        Object visit(NamespaceMemberDeclarations n);
        Object visit(Modifiers n);
        Object visit(ClassDeclaration n);
        Object visit(ClassBaseOpt n);
        Object visit(ClassBase n);
        Object visit(ClassBody n);
        Object visit(ClassMemberDeclarations n);
        Object visit(ConstantDeclaration n);
        Object visit(ConstantDeclarators n);
        Object visit(ConstantDeclarator n);
        Object visit(FieldDeclaration n);
        Object visit(VariableDeclarators n);
        Object visit(MethodDeclaration n);
        Object visit(MethodHeader n);
        Object visit(MethodBody n);
        Object visit(FormalParameterList n);
        Object visit(FixedParameters n);
        Object visit(FixedParameter n);
        Object visit(ParameterArray n);
        Object visit(PropertyDeclaration n);
        Object visit(GetAccessorDeclaration n);
        Object visit(SetAccessorDeclaration n);
        Object visit(AccessorBody n);
        Object visit(AddAccessorDeclaration n);
        Object visit(RemoveAccessorDeclaration n);
        Object visit(IndexerDeclaration n);
        Object visit(OperatorDeclaration n);
        Object visit(SymbolOperatorDeclarator n);
        Object visit(OperatorBody n);
        Object visit(ConstructorDeclaration n);
        Object visit(ConstructorDeclarator n);
        Object visit(ConstructorBody n);
        Object visit(FinalizerDeclaration n);
        Object visit(FinalizerBody n);
        Object visit(StructDeclaration n);
        Object visit(StructInterfacesOpt n);
        Object visit(StructInterfaces n);
        Object visit(StructBody n);
        Object visit(StructMemberDeclarations n);
        Object visit(ArrayType n);
        Object visit(RankSpecifiers n);
        Object visit(RankSpecifier n);
        Object visit(VariableInitializerList n);
        Object visit(InterfaceDeclaration n);
        Object visit(InterfaceBase n);
        Object visit(InterfaceBody n);
        Object visit(InterfaceMemberDeclarations n);
        Object visit(InterfaceMethodDeclaration n);
        Object visit(InterfacePropertyDeclaration n);
        Object visit(InterfaceEventDeclaration n);
        Object visit(InterfaceIndexerDeclaration n);
        Object visit(EnumDeclaration n);
        Object visit(EnumBase n);
        Object visit(EnumMemberDeclarations n);
        Object visit(DelegateDeclaration n);
        Object visit(AttributeSections n);
        Object visit(AttributeTargetSpecifier n);
        Object visit(AttributeTarget n);
        Object visit(AttributeList n);
        Object visit(Attribute n);
        Object visit(PositionalArgumentList n);
        Object visit(NamedArgumentList n);
        Object visit(NamedArgument n);
        Object visit(TypeParameterList n);
        Object visit(TypeParameter n);
        Object visit(TypeArgumentList n);
        Object visit(TypeArguments n);
        Object visit(TypeParameterConstraintsClauses n);
        Object visit(TypeParameterConstraintsClause n);
        Object visit(TypeParameterConstraints n);
        Object visit(Constraints n);
        Object visit(ConstructorConstraint n);
        Object visit(BooleanLiteral0 n);
        Object visit(BooleanLiteral1 n);
        Object visit(Name0 n);
        Object visit(Name1 n);
        Object visit(Name2 n);
        Object visit(NonNamedType0 n);
        Object visit(NonNamedType1 n);
        Object visit(IntegralType0 n);
        Object visit(IntegralType1 n);
        Object visit(IntegralType2 n);
        Object visit(IntegralType3 n);
        Object visit(IntegralType4 n);
        Object visit(IntegralType5 n);
        Object visit(IntegralType6 n);
        Object visit(IntegralType7 n);
        Object visit(IntegralType8 n);
        Object visit(FloatingPointType0 n);
        Object visit(FloatingPointType1 n);
        Object visit(ClassType0 n);
        Object visit(ClassType1 n);
        Object visit(Argument0 n);
        Object visit(Argument1 n);
        Object visit(MemberAccess0 n);
        Object visit(MemberAccess1 n);
        Object visit(MemberAccess2 n);
        Object visit(PredefinedType0 n);
        Object visit(PredefinedType1 n);
        Object visit(PredefinedType2 n);
        Object visit(PredefinedType3 n);
        Object visit(PredefinedType4 n);
        Object visit(PredefinedType5 n);
        Object visit(PredefinedType6 n);
        Object visit(PredefinedType7 n);
        Object visit(PredefinedType8 n);
        Object visit(PredefinedType9 n);
        Object visit(PredefinedType10 n);
        Object visit(PredefinedType11 n);
        Object visit(PredefinedType12 n);
        Object visit(PredefinedType13 n);
        Object visit(PredefinedType14 n);
        Object visit(BaseAccess0 n);
        Object visit(BaseAccess1 n);
        Object visit(ArrayCreationExpression0 n);
        Object visit(ArrayCreationExpression1 n);
        Object visit(TypeofExpression0 n);
        Object visit(TypeofExpression1 n);
        Object visit(UnboundTypeName0 n);
        Object visit(UnboundTypeName1 n);
        Object visit(UnboundTypeName2 n);
        Object visit(Commas0 n);
        Object visit(Commas1 n);
        Object visit(UnaryExpression0 n);
        Object visit(UnaryExpression1 n);
        Object visit(UnaryExpression2 n);
        Object visit(UnaryExpression3 n);
        Object visit(MultiplicativeExpression0 n);
        Object visit(MultiplicativeExpression1 n);
        Object visit(MultiplicativeExpression2 n);
        Object visit(AdditiveExpression0 n);
        Object visit(AdditiveExpression1 n);
        Object visit(ShiftExpression0 n);
        Object visit(ShiftExpression1 n);
        Object visit(RelationalExpression0 n);
        Object visit(RelationalExpression1 n);
        Object visit(RelationalExpression2 n);
        Object visit(RelationalExpression3 n);
        Object visit(RelationalExpression4 n);
        Object visit(RelationalExpression5 n);
        Object visit(EqualityExpression0 n);
        Object visit(EqualityExpression1 n);
        Object visit(AssignmentOperator0 n);
        Object visit(AssignmentOperator1 n);
        Object visit(AssignmentOperator2 n);
        Object visit(AssignmentOperator3 n);
        Object visit(AssignmentOperator4 n);
        Object visit(AssignmentOperator5 n);
        Object visit(AssignmentOperator6 n);
        Object visit(AssignmentOperator7 n);
        Object visit(AssignmentOperator8 n);
        Object visit(AssignmentOperator9 n);
        Object visit(AssignmentOperator10 n);
        Object visit(DeclarationStatement0 n);
        Object visit(DeclarationStatement1 n);
        Object visit(LocalVariableDeclarator0 n);
        Object visit(LocalVariableDeclarator1 n);
        Object visit(SwitchLabel0 n);
        Object visit(SwitchLabel1 n);
        Object visit(GotoStatement0 n);
        Object visit(GotoStatement1 n);
        Object visit(GotoStatement2 n);
        Object visit(TryStatement0 n);
        Object visit(TryStatement1 n);
        Object visit(YieldStatement0 n);
        Object visit(YieldStatement1 n);
        Object visit(Modifier0 n);
        Object visit(Modifier1 n);
        Object visit(Modifier2 n);
        Object visit(Modifier3 n);
        Object visit(Modifier4 n);
        Object visit(Modifier5 n);
        Object visit(Modifier6 n);
        Object visit(Modifier7 n);
        Object visit(Modifier8 n);
        Object visit(Modifier9 n);
        Object visit(Modifier10 n);
        Object visit(Modifier11 n);
        Object visit(Modifier12 n);
        Object visit(VariableDeclarator0 n);
        Object visit(VariableDeclarator1 n);
        Object visit(ParameterModifier0 n);
        Object visit(ParameterModifier1 n);
        Object visit(AccessorDeclarations0 n);
        Object visit(AccessorDeclarations1 n);
        Object visit(AccessorModifier0 n);
        Object visit(AccessorModifier1 n);
        Object visit(AccessorModifier2 n);
        Object visit(AccessorModifier3 n);
        Object visit(AccessorModifier4 n);
        Object visit(EventDeclaration0 n);
        Object visit(EventDeclaration1 n);
        Object visit(EventAccessorDeclarations0 n);
        Object visit(EventAccessorDeclarations1 n);
        Object visit(IndexerDeclarator0 n);
        Object visit(IndexerDeclarator1 n);
        Object visit(OverloadableOperator0 n);
        Object visit(OverloadableOperator1 n);
        Object visit(OverloadableOperator2 n);
        Object visit(OverloadableOperator3 n);
        Object visit(OverloadableOperator4 n);
        Object visit(OverloadableOperator5 n);
        Object visit(OverloadableOperator6 n);
        Object visit(OverloadableOperator7 n);
        Object visit(OverloadableOperator8 n);
        Object visit(OverloadableOperator9 n);
        Object visit(OverloadableOperator10 n);
        Object visit(OverloadableOperator11 n);
        Object visit(OverloadableOperator12 n);
        Object visit(OverloadableOperator13 n);
        Object visit(OverloadableOperator14 n);
        Object visit(OverloadableOperator15 n);
        Object visit(OverloadableOperator16 n);
        Object visit(OverloadableOperator17 n);
        Object visit(OverloadableOperator18 n);
        Object visit(OverloadableOperator19 n);
        Object visit(OverloadableOperator20 n);
        Object visit(OverloadableOperator21 n);
        Object visit(ConversionOperatorDeclarator0 n);
        Object visit(ConversionOperatorDeclarator1 n);
        Object visit(ConstructorInitializer0 n);
        Object visit(ConstructorInitializer1 n);
        Object visit(DimSeparators0 n);
        Object visit(DimSeparators1 n);
        Object visit(ArrayInitializer0 n);
        Object visit(ArrayInitializer1 n);
        Object visit(InterfaceAccessors0 n);
        Object visit(InterfaceAccessors1 n);
        Object visit(InterfaceAccessors2 n);
        Object visit(InterfaceAccessors3 n);
        Object visit(EnumBody0 n);
        Object visit(EnumBody1 n);
        Object visit(EnumMemberDeclaration0 n);
        Object visit(EnumMemberDeclaration1 n);
        Object visit(AttributeSection0 n);
        Object visit(AttributeSection1 n);
        Object visit(Keyword0 n);
        Object visit(Keyword1 n);
        Object visit(Keyword2 n);
        Object visit(Keyword3 n);
        Object visit(Keyword4 n);
        Object visit(Keyword5 n);
        Object visit(Keyword6 n);
        Object visit(Keyword7 n);
        Object visit(Keyword8 n);
        Object visit(Keyword9 n);
        Object visit(Keyword10 n);
        Object visit(Keyword11 n);
        Object visit(Keyword12 n);
        Object visit(Keyword13 n);
        Object visit(Keyword14 n);
        Object visit(Keyword15 n);
        Object visit(Keyword16 n);
        Object visit(Keyword17 n);
        Object visit(Keyword18 n);
        Object visit(Keyword19 n);
        Object visit(Keyword20 n);
        Object visit(Keyword21 n);
        Object visit(Keyword22 n);
        Object visit(Keyword23 n);
        Object visit(Keyword24 n);
        Object visit(Keyword25 n);
        Object visit(Keyword26 n);
        Object visit(Keyword27 n);
        Object visit(Keyword28 n);
        Object visit(Keyword29 n);
        Object visit(Keyword30 n);
        Object visit(Keyword31 n);
        Object visit(Keyword32 n);
        Object visit(Keyword33 n);
        Object visit(Keyword34 n);
        Object visit(Keyword35 n);
        Object visit(Keyword36 n);
        Object visit(Keyword37 n);
        Object visit(Keyword38 n);
        Object visit(Keyword39 n);
        Object visit(Keyword40 n);
        Object visit(Keyword41 n);
        Object visit(Keyword42 n);
        Object visit(Keyword43 n);
        Object visit(Keyword44 n);
        Object visit(Keyword45 n);
        Object visit(Keyword46 n);
        Object visit(Keyword47 n);
        Object visit(Keyword48 n);
        Object visit(Keyword49 n);
        Object visit(Keyword50 n);
        Object visit(Keyword51 n);
        Object visit(Keyword52 n);
        Object visit(Keyword53 n);
        Object visit(Keyword54 n);
        Object visit(Keyword55 n);
        Object visit(Keyword56 n);
        Object visit(Keyword57 n);
        Object visit(Keyword58 n);
        Object visit(Keyword59 n);
        Object visit(Keyword60 n);
        Object visit(Keyword61 n);
        Object visit(Keyword62 n);
        Object visit(Keyword63 n);
        Object visit(Keyword64 n);
        Object visit(Keyword65 n);
        Object visit(Keyword66 n);
        Object visit(Keyword67 n);
        Object visit(Keyword68 n);
        Object visit(Keyword69 n);
        Object visit(Keyword70 n);
        Object visit(Keyword71 n);
        Object visit(Keyword72 n);
        Object visit(Keyword73 n);
        Object visit(Keyword74 n);
        Object visit(Keyword75 n);
        Object visit(Keyword76 n);
        Object visit(Keyword77 n);
        Object visit(Keyword78 n);
        Object visit(Keyword79 n);
        Object visit(Keyword80 n);
        Object visit(Keyword81 n);
        Object visit(Keyword82 n);
        Object visit(Keyword83 n);
        Object visit(Keyword84 n);
        Object visit(AttributeArguments0 n);
        Object visit(AttributeArguments1 n);
        Object visit(AttributeArguments2 n);
        Object visit(TypeParameters0 n);
        Object visit(TypeParameters1 n);
        Object visit(Constraint0 n);
        Object visit(Constraint1 n);
    }
    public interface ResultArgumentVisitor
    {
        Object visit(AstToken n, Object o);
        Object visit(SemiOpt n, Object o);
        Object visit(ExternOpt n, Object o);
        Object visit(NewOpt n, Object o);
        Object visit(PartialOpt n, Object o);
        Object visit(IdentifierOpt n, Object o);
        Object visit(CompilationUnit n, Object o);
        Object visit(Type n, Object o);
        Object visit(SimpleType n, Object o);
        Object visit(NumericType n, Object o);
        Object visit(NullableType n, Object o);
        Object visit(ArgumentList n, Object o);
        Object visit(ParenthesizedExpression n, Object o);
        Object visit(InvocationExpression n, Object o);
        Object visit(ElementAccess n, Object o);
        Object visit(ExpressionList n, Object o);
        Object visit(ThisAccess n, Object o);
        Object visit(PostIncrementExpression n, Object o);
        Object visit(PostDecrementExpression n, Object o);
        Object visit(ObjectCreationExpression n, Object o);
        Object visit(GenericDimensionSpecifier n, Object o);
        Object visit(CheckedExpression n, Object o);
        Object visit(UncheckedExpression n, Object o);
        Object visit(DefaultValueExpression n, Object o);
        Object visit(AnonymousMethodExpression n, Object o);
        Object visit(AnonymousMethodSignature n, Object o);
        Object visit(AnonymousMethodParameterList n, Object o);
        Object visit(AnonymousMethodParameter n, Object o);
        Object visit(PreIncrementExpression n, Object o);
        Object visit(PreDecrementExpression n, Object o);
        Object visit(CastExpression n, Object o);
        Object visit(AndExpression n, Object o);
        Object visit(ExclusiveOrExpression n, Object o);
        Object visit(InclusiveOrExpression n, Object o);
        Object visit(ConditionalAndExpression n, Object o);
        Object visit(ConditionalOrExpression n, Object o);
        Object visit(NullCoalescingExpression n, Object o);
        Object visit(ConditionalExpression n, Object o);
        Object visit(Assignment n, Object o);
        Object visit(Block n, Object o);
        Object visit(StatementList n, Object o);
        Object visit(EmptyStatement n, Object o);
        Object visit(LabeledStatement n, Object o);
        Object visit(LocalVariableDeclaration n, Object o);
        Object visit(LocalVariableDeclarators n, Object o);
        Object visit(LocalConstantDeclaration n, Object o);
        Object visit(ExpressionStatement n, Object o);
        Object visit(IfStatement n, Object o);
        Object visit(ElseStatement n, Object o);
        Object visit(SwitchStatement n, Object o);
        Object visit(SwitchBlock n, Object o);
        Object visit(SwitchSections n, Object o);
        Object visit(SwitchSection n, Object o);
        Object visit(SwitchLabels n, Object o);
        Object visit(WhileStatement n, Object o);
        Object visit(DoStatement n, Object o);
        Object visit(ForStatement n, Object o);
        Object visit(StatementExpressionList n, Object o);
        Object visit(ForeachStatement n, Object o);
        Object visit(BreakStatement n, Object o);
        Object visit(ContinueStatement n, Object o);
        Object visit(ReturnStatement n, Object o);
        Object visit(ThrowStatement n, Object o);
        Object visit(CatchClauses n, Object o);
        Object visit(SpecificCatchClauses n, Object o);
        Object visit(SpecificCatchClause n, Object o);
        Object visit(GeneralCatchClause n, Object o);
        Object visit(FinallyClause n, Object o);
        Object visit(CheckedStatement n, Object o);
        Object visit(UncheckedStatement n, Object o);
        Object visit(LockStatement n, Object o);
        Object visit(UsingStatement n, Object o);
        Object visit(NamespaceDeclaration n, Object o);
        Object visit(NamespaceBody n, Object o);
        Object visit(ExternAliasDirectives n, Object o);
        Object visit(ExternAliasDirective n, Object o);
        Object visit(UsingDirectives n, Object o);
        Object visit(UsingAliasDirective n, Object o);
        Object visit(UsingNamespaceDirective n, Object o);
        Object visit(NamespaceMemberDeclarations n, Object o);
        Object visit(Modifiers n, Object o);
        Object visit(ClassDeclaration n, Object o);
        Object visit(ClassBaseOpt n, Object o);
        Object visit(ClassBase n, Object o);
        Object visit(ClassBody n, Object o);
        Object visit(ClassMemberDeclarations n, Object o);
        Object visit(ConstantDeclaration n, Object o);
        Object visit(ConstantDeclarators n, Object o);
        Object visit(ConstantDeclarator n, Object o);
        Object visit(FieldDeclaration n, Object o);
        Object visit(VariableDeclarators n, Object o);
        Object visit(MethodDeclaration n, Object o);
        Object visit(MethodHeader n, Object o);
        Object visit(MethodBody n, Object o);
        Object visit(FormalParameterList n, Object o);
        Object visit(FixedParameters n, Object o);
        Object visit(FixedParameter n, Object o);
        Object visit(ParameterArray n, Object o);
        Object visit(PropertyDeclaration n, Object o);
        Object visit(GetAccessorDeclaration n, Object o);
        Object visit(SetAccessorDeclaration n, Object o);
        Object visit(AccessorBody n, Object o);
        Object visit(AddAccessorDeclaration n, Object o);
        Object visit(RemoveAccessorDeclaration n, Object o);
        Object visit(IndexerDeclaration n, Object o);
        Object visit(OperatorDeclaration n, Object o);
        Object visit(SymbolOperatorDeclarator n, Object o);
        Object visit(OperatorBody n, Object o);
        Object visit(ConstructorDeclaration n, Object o);
        Object visit(ConstructorDeclarator n, Object o);
        Object visit(ConstructorBody n, Object o);
        Object visit(FinalizerDeclaration n, Object o);
        Object visit(FinalizerBody n, Object o);
        Object visit(StructDeclaration n, Object o);
        Object visit(StructInterfacesOpt n, Object o);
        Object visit(StructInterfaces n, Object o);
        Object visit(StructBody n, Object o);
        Object visit(StructMemberDeclarations n, Object o);
        Object visit(ArrayType n, Object o);
        Object visit(RankSpecifiers n, Object o);
        Object visit(RankSpecifier n, Object o);
        Object visit(VariableInitializerList n, Object o);
        Object visit(InterfaceDeclaration n, Object o);
        Object visit(InterfaceBase n, Object o);
        Object visit(InterfaceBody n, Object o);
        Object visit(InterfaceMemberDeclarations n, Object o);
        Object visit(InterfaceMethodDeclaration n, Object o);
        Object visit(InterfacePropertyDeclaration n, Object o);
        Object visit(InterfaceEventDeclaration n, Object o);
        Object visit(InterfaceIndexerDeclaration n, Object o);
        Object visit(EnumDeclaration n, Object o);
        Object visit(EnumBase n, Object o);
        Object visit(EnumMemberDeclarations n, Object o);
        Object visit(DelegateDeclaration n, Object o);
        Object visit(AttributeSections n, Object o);
        Object visit(AttributeTargetSpecifier n, Object o);
        Object visit(AttributeTarget n, Object o);
        Object visit(AttributeList n, Object o);
        Object visit(Attribute n, Object o);
        Object visit(PositionalArgumentList n, Object o);
        Object visit(NamedArgumentList n, Object o);
        Object visit(NamedArgument n, Object o);
        Object visit(TypeParameterList n, Object o);
        Object visit(TypeParameter n, Object o);
        Object visit(TypeArgumentList n, Object o);
        Object visit(TypeArguments n, Object o);
        Object visit(TypeParameterConstraintsClauses n, Object o);
        Object visit(TypeParameterConstraintsClause n, Object o);
        Object visit(TypeParameterConstraints n, Object o);
        Object visit(Constraints n, Object o);
        Object visit(ConstructorConstraint n, Object o);
        Object visit(BooleanLiteral0 n, Object o);
        Object visit(BooleanLiteral1 n, Object o);
        Object visit(Name0 n, Object o);
        Object visit(Name1 n, Object o);
        Object visit(Name2 n, Object o);
        Object visit(NonNamedType0 n, Object o);
        Object visit(NonNamedType1 n, Object o);
        Object visit(IntegralType0 n, Object o);
        Object visit(IntegralType1 n, Object o);
        Object visit(IntegralType2 n, Object o);
        Object visit(IntegralType3 n, Object o);
        Object visit(IntegralType4 n, Object o);
        Object visit(IntegralType5 n, Object o);
        Object visit(IntegralType6 n, Object o);
        Object visit(IntegralType7 n, Object o);
        Object visit(IntegralType8 n, Object o);
        Object visit(FloatingPointType0 n, Object o);
        Object visit(FloatingPointType1 n, Object o);
        Object visit(ClassType0 n, Object o);
        Object visit(ClassType1 n, Object o);
        Object visit(Argument0 n, Object o);
        Object visit(Argument1 n, Object o);
        Object visit(MemberAccess0 n, Object o);
        Object visit(MemberAccess1 n, Object o);
        Object visit(MemberAccess2 n, Object o);
        Object visit(PredefinedType0 n, Object o);
        Object visit(PredefinedType1 n, Object o);
        Object visit(PredefinedType2 n, Object o);
        Object visit(PredefinedType3 n, Object o);
        Object visit(PredefinedType4 n, Object o);
        Object visit(PredefinedType5 n, Object o);
        Object visit(PredefinedType6 n, Object o);
        Object visit(PredefinedType7 n, Object o);
        Object visit(PredefinedType8 n, Object o);
        Object visit(PredefinedType9 n, Object o);
        Object visit(PredefinedType10 n, Object o);
        Object visit(PredefinedType11 n, Object o);
        Object visit(PredefinedType12 n, Object o);
        Object visit(PredefinedType13 n, Object o);
        Object visit(PredefinedType14 n, Object o);
        Object visit(BaseAccess0 n, Object o);
        Object visit(BaseAccess1 n, Object o);
        Object visit(ArrayCreationExpression0 n, Object o);
        Object visit(ArrayCreationExpression1 n, Object o);
        Object visit(TypeofExpression0 n, Object o);
        Object visit(TypeofExpression1 n, Object o);
        Object visit(UnboundTypeName0 n, Object o);
        Object visit(UnboundTypeName1 n, Object o);
        Object visit(UnboundTypeName2 n, Object o);
        Object visit(Commas0 n, Object o);
        Object visit(Commas1 n, Object o);
        Object visit(UnaryExpression0 n, Object o);
        Object visit(UnaryExpression1 n, Object o);
        Object visit(UnaryExpression2 n, Object o);
        Object visit(UnaryExpression3 n, Object o);
        Object visit(MultiplicativeExpression0 n, Object o);
        Object visit(MultiplicativeExpression1 n, Object o);
        Object visit(MultiplicativeExpression2 n, Object o);
        Object visit(AdditiveExpression0 n, Object o);
        Object visit(AdditiveExpression1 n, Object o);
        Object visit(ShiftExpression0 n, Object o);
        Object visit(ShiftExpression1 n, Object o);
        Object visit(RelationalExpression0 n, Object o);
        Object visit(RelationalExpression1 n, Object o);
        Object visit(RelationalExpression2 n, Object o);
        Object visit(RelationalExpression3 n, Object o);
        Object visit(RelationalExpression4 n, Object o);
        Object visit(RelationalExpression5 n, Object o);
        Object visit(EqualityExpression0 n, Object o);
        Object visit(EqualityExpression1 n, Object o);
        Object visit(AssignmentOperator0 n, Object o);
        Object visit(AssignmentOperator1 n, Object o);
        Object visit(AssignmentOperator2 n, Object o);
        Object visit(AssignmentOperator3 n, Object o);
        Object visit(AssignmentOperator4 n, Object o);
        Object visit(AssignmentOperator5 n, Object o);
        Object visit(AssignmentOperator6 n, Object o);
        Object visit(AssignmentOperator7 n, Object o);
        Object visit(AssignmentOperator8 n, Object o);
        Object visit(AssignmentOperator9 n, Object o);
        Object visit(AssignmentOperator10 n, Object o);
        Object visit(DeclarationStatement0 n, Object o);
        Object visit(DeclarationStatement1 n, Object o);
        Object visit(LocalVariableDeclarator0 n, Object o);
        Object visit(LocalVariableDeclarator1 n, Object o);
        Object visit(SwitchLabel0 n, Object o);
        Object visit(SwitchLabel1 n, Object o);
        Object visit(GotoStatement0 n, Object o);
        Object visit(GotoStatement1 n, Object o);
        Object visit(GotoStatement2 n, Object o);
        Object visit(TryStatement0 n, Object o);
        Object visit(TryStatement1 n, Object o);
        Object visit(YieldStatement0 n, Object o);
        Object visit(YieldStatement1 n, Object o);
        Object visit(Modifier0 n, Object o);
        Object visit(Modifier1 n, Object o);
        Object visit(Modifier2 n, Object o);
        Object visit(Modifier3 n, Object o);
        Object visit(Modifier4 n, Object o);
        Object visit(Modifier5 n, Object o);
        Object visit(Modifier6 n, Object o);
        Object visit(Modifier7 n, Object o);
        Object visit(Modifier8 n, Object o);
        Object visit(Modifier9 n, Object o);
        Object visit(Modifier10 n, Object o);
        Object visit(Modifier11 n, Object o);
        Object visit(Modifier12 n, Object o);
        Object visit(VariableDeclarator0 n, Object o);
        Object visit(VariableDeclarator1 n, Object o);
        Object visit(ParameterModifier0 n, Object o);
        Object visit(ParameterModifier1 n, Object o);
        Object visit(AccessorDeclarations0 n, Object o);
        Object visit(AccessorDeclarations1 n, Object o);
        Object visit(AccessorModifier0 n, Object o);
        Object visit(AccessorModifier1 n, Object o);
        Object visit(AccessorModifier2 n, Object o);
        Object visit(AccessorModifier3 n, Object o);
        Object visit(AccessorModifier4 n, Object o);
        Object visit(EventDeclaration0 n, Object o);
        Object visit(EventDeclaration1 n, Object o);
        Object visit(EventAccessorDeclarations0 n, Object o);
        Object visit(EventAccessorDeclarations1 n, Object o);
        Object visit(IndexerDeclarator0 n, Object o);
        Object visit(IndexerDeclarator1 n, Object o);
        Object visit(OverloadableOperator0 n, Object o);
        Object visit(OverloadableOperator1 n, Object o);
        Object visit(OverloadableOperator2 n, Object o);
        Object visit(OverloadableOperator3 n, Object o);
        Object visit(OverloadableOperator4 n, Object o);
        Object visit(OverloadableOperator5 n, Object o);
        Object visit(OverloadableOperator6 n, Object o);
        Object visit(OverloadableOperator7 n, Object o);
        Object visit(OverloadableOperator8 n, Object o);
        Object visit(OverloadableOperator9 n, Object o);
        Object visit(OverloadableOperator10 n, Object o);
        Object visit(OverloadableOperator11 n, Object o);
        Object visit(OverloadableOperator12 n, Object o);
        Object visit(OverloadableOperator13 n, Object o);
        Object visit(OverloadableOperator14 n, Object o);
        Object visit(OverloadableOperator15 n, Object o);
        Object visit(OverloadableOperator16 n, Object o);
        Object visit(OverloadableOperator17 n, Object o);
        Object visit(OverloadableOperator18 n, Object o);
        Object visit(OverloadableOperator19 n, Object o);
        Object visit(OverloadableOperator20 n, Object o);
        Object visit(OverloadableOperator21 n, Object o);
        Object visit(ConversionOperatorDeclarator0 n, Object o);
        Object visit(ConversionOperatorDeclarator1 n, Object o);
        Object visit(ConstructorInitializer0 n, Object o);
        Object visit(ConstructorInitializer1 n, Object o);
        Object visit(DimSeparators0 n, Object o);
        Object visit(DimSeparators1 n, Object o);
        Object visit(ArrayInitializer0 n, Object o);
        Object visit(ArrayInitializer1 n, Object o);
        Object visit(InterfaceAccessors0 n, Object o);
        Object visit(InterfaceAccessors1 n, Object o);
        Object visit(InterfaceAccessors2 n, Object o);
        Object visit(InterfaceAccessors3 n, Object o);
        Object visit(EnumBody0 n, Object o);
        Object visit(EnumBody1 n, Object o);
        Object visit(EnumMemberDeclaration0 n, Object o);
        Object visit(EnumMemberDeclaration1 n, Object o);
        Object visit(AttributeSection0 n, Object o);
        Object visit(AttributeSection1 n, Object o);
        Object visit(Keyword0 n, Object o);
        Object visit(Keyword1 n, Object o);
        Object visit(Keyword2 n, Object o);
        Object visit(Keyword3 n, Object o);
        Object visit(Keyword4 n, Object o);
        Object visit(Keyword5 n, Object o);
        Object visit(Keyword6 n, Object o);
        Object visit(Keyword7 n, Object o);
        Object visit(Keyword8 n, Object o);
        Object visit(Keyword9 n, Object o);
        Object visit(Keyword10 n, Object o);
        Object visit(Keyword11 n, Object o);
        Object visit(Keyword12 n, Object o);
        Object visit(Keyword13 n, Object o);
        Object visit(Keyword14 n, Object o);
        Object visit(Keyword15 n, Object o);
        Object visit(Keyword16 n, Object o);
        Object visit(Keyword17 n, Object o);
        Object visit(Keyword18 n, Object o);
        Object visit(Keyword19 n, Object o);
        Object visit(Keyword20 n, Object o);
        Object visit(Keyword21 n, Object o);
        Object visit(Keyword22 n, Object o);
        Object visit(Keyword23 n, Object o);
        Object visit(Keyword24 n, Object o);
        Object visit(Keyword25 n, Object o);
        Object visit(Keyword26 n, Object o);
        Object visit(Keyword27 n, Object o);
        Object visit(Keyword28 n, Object o);
        Object visit(Keyword29 n, Object o);
        Object visit(Keyword30 n, Object o);
        Object visit(Keyword31 n, Object o);
        Object visit(Keyword32 n, Object o);
        Object visit(Keyword33 n, Object o);
        Object visit(Keyword34 n, Object o);
        Object visit(Keyword35 n, Object o);
        Object visit(Keyword36 n, Object o);
        Object visit(Keyword37 n, Object o);
        Object visit(Keyword38 n, Object o);
        Object visit(Keyword39 n, Object o);
        Object visit(Keyword40 n, Object o);
        Object visit(Keyword41 n, Object o);
        Object visit(Keyword42 n, Object o);
        Object visit(Keyword43 n, Object o);
        Object visit(Keyword44 n, Object o);
        Object visit(Keyword45 n, Object o);
        Object visit(Keyword46 n, Object o);
        Object visit(Keyword47 n, Object o);
        Object visit(Keyword48 n, Object o);
        Object visit(Keyword49 n, Object o);
        Object visit(Keyword50 n, Object o);
        Object visit(Keyword51 n, Object o);
        Object visit(Keyword52 n, Object o);
        Object visit(Keyword53 n, Object o);
        Object visit(Keyword54 n, Object o);
        Object visit(Keyword55 n, Object o);
        Object visit(Keyword56 n, Object o);
        Object visit(Keyword57 n, Object o);
        Object visit(Keyword58 n, Object o);
        Object visit(Keyword59 n, Object o);
        Object visit(Keyword60 n, Object o);
        Object visit(Keyword61 n, Object o);
        Object visit(Keyword62 n, Object o);
        Object visit(Keyword63 n, Object o);
        Object visit(Keyword64 n, Object o);
        Object visit(Keyword65 n, Object o);
        Object visit(Keyword66 n, Object o);
        Object visit(Keyword67 n, Object o);
        Object visit(Keyword68 n, Object o);
        Object visit(Keyword69 n, Object o);
        Object visit(Keyword70 n, Object o);
        Object visit(Keyword71 n, Object o);
        Object visit(Keyword72 n, Object o);
        Object visit(Keyword73 n, Object o);
        Object visit(Keyword74 n, Object o);
        Object visit(Keyword75 n, Object o);
        Object visit(Keyword76 n, Object o);
        Object visit(Keyword77 n, Object o);
        Object visit(Keyword78 n, Object o);
        Object visit(Keyword79 n, Object o);
        Object visit(Keyword80 n, Object o);
        Object visit(Keyword81 n, Object o);
        Object visit(Keyword82 n, Object o);
        Object visit(Keyword83 n, Object o);
        Object visit(Keyword84 n, Object o);
        Object visit(AttributeArguments0 n, Object o);
        Object visit(AttributeArguments1 n, Object o);
        Object visit(AttributeArguments2 n, Object o);
        Object visit(TypeParameters0 n, Object o);
        Object visit(TypeParameters1 n, Object o);
        Object visit(Constraint0 n, Object o);
        Object visit(Constraint1 n, Object o);
    }
    static public abstract class AbstractVisitor implements Visitor, ArgumentVisitor
    {
        public abstract void unimplementedVisitor(String s);

        public void visit(AstToken n) { unimplementedVisitor("visit(AstToken)"); }
        public void visit(AstToken n, Object o) { unimplementedVisitor("visit(AstToken, Object)"); }

        public void visit(SemiOpt n) { unimplementedVisitor("visit(SemiOpt)"); }
        public void visit(SemiOpt n, Object o) { unimplementedVisitor("visit(SemiOpt, Object)"); }

        public void visit(ExternOpt n) { unimplementedVisitor("visit(ExternOpt)"); }
        public void visit(ExternOpt n, Object o) { unimplementedVisitor("visit(ExternOpt, Object)"); }

        public void visit(NewOpt n) { unimplementedVisitor("visit(NewOpt)"); }
        public void visit(NewOpt n, Object o) { unimplementedVisitor("visit(NewOpt, Object)"); }

        public void visit(PartialOpt n) { unimplementedVisitor("visit(PartialOpt)"); }
        public void visit(PartialOpt n, Object o) { unimplementedVisitor("visit(PartialOpt, Object)"); }

        public void visit(IdentifierOpt n) { unimplementedVisitor("visit(IdentifierOpt)"); }
        public void visit(IdentifierOpt n, Object o) { unimplementedVisitor("visit(IdentifierOpt, Object)"); }

        public void visit(CompilationUnit n) { unimplementedVisitor("visit(CompilationUnit)"); }
        public void visit(CompilationUnit n, Object o) { unimplementedVisitor("visit(CompilationUnit, Object)"); }

        public void visit(Type n) { unimplementedVisitor("visit(Type)"); }
        public void visit(Type n, Object o) { unimplementedVisitor("visit(Type, Object)"); }

        public void visit(SimpleType n) { unimplementedVisitor("visit(SimpleType)"); }
        public void visit(SimpleType n, Object o) { unimplementedVisitor("visit(SimpleType, Object)"); }

        public void visit(NumericType n) { unimplementedVisitor("visit(NumericType)"); }
        public void visit(NumericType n, Object o) { unimplementedVisitor("visit(NumericType, Object)"); }

        public void visit(NullableType n) { unimplementedVisitor("visit(NullableType)"); }
        public void visit(NullableType n, Object o) { unimplementedVisitor("visit(NullableType, Object)"); }

        public void visit(ArgumentList n) { unimplementedVisitor("visit(ArgumentList)"); }
        public void visit(ArgumentList n, Object o) { unimplementedVisitor("visit(ArgumentList, Object)"); }

        public void visit(ParenthesizedExpression n) { unimplementedVisitor("visit(ParenthesizedExpression)"); }
        public void visit(ParenthesizedExpression n, Object o) { unimplementedVisitor("visit(ParenthesizedExpression, Object)"); }

        public void visit(InvocationExpression n) { unimplementedVisitor("visit(InvocationExpression)"); }
        public void visit(InvocationExpression n, Object o) { unimplementedVisitor("visit(InvocationExpression, Object)"); }

        public void visit(ElementAccess n) { unimplementedVisitor("visit(ElementAccess)"); }
        public void visit(ElementAccess n, Object o) { unimplementedVisitor("visit(ElementAccess, Object)"); }

        public void visit(ExpressionList n) { unimplementedVisitor("visit(ExpressionList)"); }
        public void visit(ExpressionList n, Object o) { unimplementedVisitor("visit(ExpressionList, Object)"); }

        public void visit(ThisAccess n) { unimplementedVisitor("visit(ThisAccess)"); }
        public void visit(ThisAccess n, Object o) { unimplementedVisitor("visit(ThisAccess, Object)"); }

        public void visit(PostIncrementExpression n) { unimplementedVisitor("visit(PostIncrementExpression)"); }
        public void visit(PostIncrementExpression n, Object o) { unimplementedVisitor("visit(PostIncrementExpression, Object)"); }

        public void visit(PostDecrementExpression n) { unimplementedVisitor("visit(PostDecrementExpression)"); }
        public void visit(PostDecrementExpression n, Object o) { unimplementedVisitor("visit(PostDecrementExpression, Object)"); }

        public void visit(ObjectCreationExpression n) { unimplementedVisitor("visit(ObjectCreationExpression)"); }
        public void visit(ObjectCreationExpression n, Object o) { unimplementedVisitor("visit(ObjectCreationExpression, Object)"); }

        public void visit(GenericDimensionSpecifier n) { unimplementedVisitor("visit(GenericDimensionSpecifier)"); }
        public void visit(GenericDimensionSpecifier n, Object o) { unimplementedVisitor("visit(GenericDimensionSpecifier, Object)"); }

        public void visit(CheckedExpression n) { unimplementedVisitor("visit(CheckedExpression)"); }
        public void visit(CheckedExpression n, Object o) { unimplementedVisitor("visit(CheckedExpression, Object)"); }

        public void visit(UncheckedExpression n) { unimplementedVisitor("visit(UncheckedExpression)"); }
        public void visit(UncheckedExpression n, Object o) { unimplementedVisitor("visit(UncheckedExpression, Object)"); }

        public void visit(DefaultValueExpression n) { unimplementedVisitor("visit(DefaultValueExpression)"); }
        public void visit(DefaultValueExpression n, Object o) { unimplementedVisitor("visit(DefaultValueExpression, Object)"); }

        public void visit(AnonymousMethodExpression n) { unimplementedVisitor("visit(AnonymousMethodExpression)"); }
        public void visit(AnonymousMethodExpression n, Object o) { unimplementedVisitor("visit(AnonymousMethodExpression, Object)"); }

        public void visit(AnonymousMethodSignature n) { unimplementedVisitor("visit(AnonymousMethodSignature)"); }
        public void visit(AnonymousMethodSignature n, Object o) { unimplementedVisitor("visit(AnonymousMethodSignature, Object)"); }

        public void visit(AnonymousMethodParameterList n) { unimplementedVisitor("visit(AnonymousMethodParameterList)"); }
        public void visit(AnonymousMethodParameterList n, Object o) { unimplementedVisitor("visit(AnonymousMethodParameterList, Object)"); }

        public void visit(AnonymousMethodParameter n) { unimplementedVisitor("visit(AnonymousMethodParameter)"); }
        public void visit(AnonymousMethodParameter n, Object o) { unimplementedVisitor("visit(AnonymousMethodParameter, Object)"); }

        public void visit(PreIncrementExpression n) { unimplementedVisitor("visit(PreIncrementExpression)"); }
        public void visit(PreIncrementExpression n, Object o) { unimplementedVisitor("visit(PreIncrementExpression, Object)"); }

        public void visit(PreDecrementExpression n) { unimplementedVisitor("visit(PreDecrementExpression)"); }
        public void visit(PreDecrementExpression n, Object o) { unimplementedVisitor("visit(PreDecrementExpression, Object)"); }

        public void visit(CastExpression n) { unimplementedVisitor("visit(CastExpression)"); }
        public void visit(CastExpression n, Object o) { unimplementedVisitor("visit(CastExpression, Object)"); }

        public void visit(AndExpression n) { unimplementedVisitor("visit(AndExpression)"); }
        public void visit(AndExpression n, Object o) { unimplementedVisitor("visit(AndExpression, Object)"); }

        public void visit(ExclusiveOrExpression n) { unimplementedVisitor("visit(ExclusiveOrExpression)"); }
        public void visit(ExclusiveOrExpression n, Object o) { unimplementedVisitor("visit(ExclusiveOrExpression, Object)"); }

        public void visit(InclusiveOrExpression n) { unimplementedVisitor("visit(InclusiveOrExpression)"); }
        public void visit(InclusiveOrExpression n, Object o) { unimplementedVisitor("visit(InclusiveOrExpression, Object)"); }

        public void visit(ConditionalAndExpression n) { unimplementedVisitor("visit(ConditionalAndExpression)"); }
        public void visit(ConditionalAndExpression n, Object o) { unimplementedVisitor("visit(ConditionalAndExpression, Object)"); }

        public void visit(ConditionalOrExpression n) { unimplementedVisitor("visit(ConditionalOrExpression)"); }
        public void visit(ConditionalOrExpression n, Object o) { unimplementedVisitor("visit(ConditionalOrExpression, Object)"); }

        public void visit(NullCoalescingExpression n) { unimplementedVisitor("visit(NullCoalescingExpression)"); }
        public void visit(NullCoalescingExpression n, Object o) { unimplementedVisitor("visit(NullCoalescingExpression, Object)"); }

        public void visit(ConditionalExpression n) { unimplementedVisitor("visit(ConditionalExpression)"); }
        public void visit(ConditionalExpression n, Object o) { unimplementedVisitor("visit(ConditionalExpression, Object)"); }

        public void visit(Assignment n) { unimplementedVisitor("visit(Assignment)"); }
        public void visit(Assignment n, Object o) { unimplementedVisitor("visit(Assignment, Object)"); }

        public void visit(Block n) { unimplementedVisitor("visit(Block)"); }
        public void visit(Block n, Object o) { unimplementedVisitor("visit(Block, Object)"); }

        public void visit(StatementList n) { unimplementedVisitor("visit(StatementList)"); }
        public void visit(StatementList n, Object o) { unimplementedVisitor("visit(StatementList, Object)"); }

        public void visit(EmptyStatement n) { unimplementedVisitor("visit(EmptyStatement)"); }
        public void visit(EmptyStatement n, Object o) { unimplementedVisitor("visit(EmptyStatement, Object)"); }

        public void visit(LabeledStatement n) { unimplementedVisitor("visit(LabeledStatement)"); }
        public void visit(LabeledStatement n, Object o) { unimplementedVisitor("visit(LabeledStatement, Object)"); }

        public void visit(LocalVariableDeclaration n) { unimplementedVisitor("visit(LocalVariableDeclaration)"); }
        public void visit(LocalVariableDeclaration n, Object o) { unimplementedVisitor("visit(LocalVariableDeclaration, Object)"); }

        public void visit(LocalVariableDeclarators n) { unimplementedVisitor("visit(LocalVariableDeclarators)"); }
        public void visit(LocalVariableDeclarators n, Object o) { unimplementedVisitor("visit(LocalVariableDeclarators, Object)"); }

        public void visit(LocalConstantDeclaration n) { unimplementedVisitor("visit(LocalConstantDeclaration)"); }
        public void visit(LocalConstantDeclaration n, Object o) { unimplementedVisitor("visit(LocalConstantDeclaration, Object)"); }

        public void visit(ExpressionStatement n) { unimplementedVisitor("visit(ExpressionStatement)"); }
        public void visit(ExpressionStatement n, Object o) { unimplementedVisitor("visit(ExpressionStatement, Object)"); }

        public void visit(IfStatement n) { unimplementedVisitor("visit(IfStatement)"); }
        public void visit(IfStatement n, Object o) { unimplementedVisitor("visit(IfStatement, Object)"); }

        public void visit(ElseStatement n) { unimplementedVisitor("visit(ElseStatement)"); }
        public void visit(ElseStatement n, Object o) { unimplementedVisitor("visit(ElseStatement, Object)"); }

        public void visit(SwitchStatement n) { unimplementedVisitor("visit(SwitchStatement)"); }
        public void visit(SwitchStatement n, Object o) { unimplementedVisitor("visit(SwitchStatement, Object)"); }

        public void visit(SwitchBlock n) { unimplementedVisitor("visit(SwitchBlock)"); }
        public void visit(SwitchBlock n, Object o) { unimplementedVisitor("visit(SwitchBlock, Object)"); }

        public void visit(SwitchSections n) { unimplementedVisitor("visit(SwitchSections)"); }
        public void visit(SwitchSections n, Object o) { unimplementedVisitor("visit(SwitchSections, Object)"); }

        public void visit(SwitchSection n) { unimplementedVisitor("visit(SwitchSection)"); }
        public void visit(SwitchSection n, Object o) { unimplementedVisitor("visit(SwitchSection, Object)"); }

        public void visit(SwitchLabels n) { unimplementedVisitor("visit(SwitchLabels)"); }
        public void visit(SwitchLabels n, Object o) { unimplementedVisitor("visit(SwitchLabels, Object)"); }

        public void visit(WhileStatement n) { unimplementedVisitor("visit(WhileStatement)"); }
        public void visit(WhileStatement n, Object o) { unimplementedVisitor("visit(WhileStatement, Object)"); }

        public void visit(DoStatement n) { unimplementedVisitor("visit(DoStatement)"); }
        public void visit(DoStatement n, Object o) { unimplementedVisitor("visit(DoStatement, Object)"); }

        public void visit(ForStatement n) { unimplementedVisitor("visit(ForStatement)"); }
        public void visit(ForStatement n, Object o) { unimplementedVisitor("visit(ForStatement, Object)"); }

        public void visit(StatementExpressionList n) { unimplementedVisitor("visit(StatementExpressionList)"); }
        public void visit(StatementExpressionList n, Object o) { unimplementedVisitor("visit(StatementExpressionList, Object)"); }

        public void visit(ForeachStatement n) { unimplementedVisitor("visit(ForeachStatement)"); }
        public void visit(ForeachStatement n, Object o) { unimplementedVisitor("visit(ForeachStatement, Object)"); }

        public void visit(BreakStatement n) { unimplementedVisitor("visit(BreakStatement)"); }
        public void visit(BreakStatement n, Object o) { unimplementedVisitor("visit(BreakStatement, Object)"); }

        public void visit(ContinueStatement n) { unimplementedVisitor("visit(ContinueStatement)"); }
        public void visit(ContinueStatement n, Object o) { unimplementedVisitor("visit(ContinueStatement, Object)"); }

        public void visit(ReturnStatement n) { unimplementedVisitor("visit(ReturnStatement)"); }
        public void visit(ReturnStatement n, Object o) { unimplementedVisitor("visit(ReturnStatement, Object)"); }

        public void visit(ThrowStatement n) { unimplementedVisitor("visit(ThrowStatement)"); }
        public void visit(ThrowStatement n, Object o) { unimplementedVisitor("visit(ThrowStatement, Object)"); }

        public void visit(CatchClauses n) { unimplementedVisitor("visit(CatchClauses)"); }
        public void visit(CatchClauses n, Object o) { unimplementedVisitor("visit(CatchClauses, Object)"); }

        public void visit(SpecificCatchClauses n) { unimplementedVisitor("visit(SpecificCatchClauses)"); }
        public void visit(SpecificCatchClauses n, Object o) { unimplementedVisitor("visit(SpecificCatchClauses, Object)"); }

        public void visit(SpecificCatchClause n) { unimplementedVisitor("visit(SpecificCatchClause)"); }
        public void visit(SpecificCatchClause n, Object o) { unimplementedVisitor("visit(SpecificCatchClause, Object)"); }

        public void visit(GeneralCatchClause n) { unimplementedVisitor("visit(GeneralCatchClause)"); }
        public void visit(GeneralCatchClause n, Object o) { unimplementedVisitor("visit(GeneralCatchClause, Object)"); }

        public void visit(FinallyClause n) { unimplementedVisitor("visit(FinallyClause)"); }
        public void visit(FinallyClause n, Object o) { unimplementedVisitor("visit(FinallyClause, Object)"); }

        public void visit(CheckedStatement n) { unimplementedVisitor("visit(CheckedStatement)"); }
        public void visit(CheckedStatement n, Object o) { unimplementedVisitor("visit(CheckedStatement, Object)"); }

        public void visit(UncheckedStatement n) { unimplementedVisitor("visit(UncheckedStatement)"); }
        public void visit(UncheckedStatement n, Object o) { unimplementedVisitor("visit(UncheckedStatement, Object)"); }

        public void visit(LockStatement n) { unimplementedVisitor("visit(LockStatement)"); }
        public void visit(LockStatement n, Object o) { unimplementedVisitor("visit(LockStatement, Object)"); }

        public void visit(UsingStatement n) { unimplementedVisitor("visit(UsingStatement)"); }
        public void visit(UsingStatement n, Object o) { unimplementedVisitor("visit(UsingStatement, Object)"); }

        public void visit(NamespaceDeclaration n) { unimplementedVisitor("visit(NamespaceDeclaration)"); }
        public void visit(NamespaceDeclaration n, Object o) { unimplementedVisitor("visit(NamespaceDeclaration, Object)"); }

        public void visit(NamespaceBody n) { unimplementedVisitor("visit(NamespaceBody)"); }
        public void visit(NamespaceBody n, Object o) { unimplementedVisitor("visit(NamespaceBody, Object)"); }

        public void visit(ExternAliasDirectives n) { unimplementedVisitor("visit(ExternAliasDirectives)"); }
        public void visit(ExternAliasDirectives n, Object o) { unimplementedVisitor("visit(ExternAliasDirectives, Object)"); }

        public void visit(ExternAliasDirective n) { unimplementedVisitor("visit(ExternAliasDirective)"); }
        public void visit(ExternAliasDirective n, Object o) { unimplementedVisitor("visit(ExternAliasDirective, Object)"); }

        public void visit(UsingDirectives n) { unimplementedVisitor("visit(UsingDirectives)"); }
        public void visit(UsingDirectives n, Object o) { unimplementedVisitor("visit(UsingDirectives, Object)"); }

        public void visit(UsingAliasDirective n) { unimplementedVisitor("visit(UsingAliasDirective)"); }
        public void visit(UsingAliasDirective n, Object o) { unimplementedVisitor("visit(UsingAliasDirective, Object)"); }

        public void visit(UsingNamespaceDirective n) { unimplementedVisitor("visit(UsingNamespaceDirective)"); }
        public void visit(UsingNamespaceDirective n, Object o) { unimplementedVisitor("visit(UsingNamespaceDirective, Object)"); }

        public void visit(NamespaceMemberDeclarations n) { unimplementedVisitor("visit(NamespaceMemberDeclarations)"); }
        public void visit(NamespaceMemberDeclarations n, Object o) { unimplementedVisitor("visit(NamespaceMemberDeclarations, Object)"); }

        public void visit(Modifiers n) { unimplementedVisitor("visit(Modifiers)"); }
        public void visit(Modifiers n, Object o) { unimplementedVisitor("visit(Modifiers, Object)"); }

        public void visit(ClassDeclaration n) { unimplementedVisitor("visit(ClassDeclaration)"); }
        public void visit(ClassDeclaration n, Object o) { unimplementedVisitor("visit(ClassDeclaration, Object)"); }

        public void visit(ClassBaseOpt n) { unimplementedVisitor("visit(ClassBaseOpt)"); }
        public void visit(ClassBaseOpt n, Object o) { unimplementedVisitor("visit(ClassBaseOpt, Object)"); }

        public void visit(ClassBase n) { unimplementedVisitor("visit(ClassBase)"); }
        public void visit(ClassBase n, Object o) { unimplementedVisitor("visit(ClassBase, Object)"); }

        public void visit(ClassBody n) { unimplementedVisitor("visit(ClassBody)"); }
        public void visit(ClassBody n, Object o) { unimplementedVisitor("visit(ClassBody, Object)"); }

        public void visit(ClassMemberDeclarations n) { unimplementedVisitor("visit(ClassMemberDeclarations)"); }
        public void visit(ClassMemberDeclarations n, Object o) { unimplementedVisitor("visit(ClassMemberDeclarations, Object)"); }

        public void visit(ConstantDeclaration n) { unimplementedVisitor("visit(ConstantDeclaration)"); }
        public void visit(ConstantDeclaration n, Object o) { unimplementedVisitor("visit(ConstantDeclaration, Object)"); }

        public void visit(ConstantDeclarators n) { unimplementedVisitor("visit(ConstantDeclarators)"); }
        public void visit(ConstantDeclarators n, Object o) { unimplementedVisitor("visit(ConstantDeclarators, Object)"); }

        public void visit(ConstantDeclarator n) { unimplementedVisitor("visit(ConstantDeclarator)"); }
        public void visit(ConstantDeclarator n, Object o) { unimplementedVisitor("visit(ConstantDeclarator, Object)"); }

        public void visit(FieldDeclaration n) { unimplementedVisitor("visit(FieldDeclaration)"); }
        public void visit(FieldDeclaration n, Object o) { unimplementedVisitor("visit(FieldDeclaration, Object)"); }

        public void visit(VariableDeclarators n) { unimplementedVisitor("visit(VariableDeclarators)"); }
        public void visit(VariableDeclarators n, Object o) { unimplementedVisitor("visit(VariableDeclarators, Object)"); }

        public void visit(MethodDeclaration n) { unimplementedVisitor("visit(MethodDeclaration)"); }
        public void visit(MethodDeclaration n, Object o) { unimplementedVisitor("visit(MethodDeclaration, Object)"); }

        public void visit(MethodHeader n) { unimplementedVisitor("visit(MethodHeader)"); }
        public void visit(MethodHeader n, Object o) { unimplementedVisitor("visit(MethodHeader, Object)"); }

        public void visit(MethodBody n) { unimplementedVisitor("visit(MethodBody)"); }
        public void visit(MethodBody n, Object o) { unimplementedVisitor("visit(MethodBody, Object)"); }

        public void visit(FormalParameterList n) { unimplementedVisitor("visit(FormalParameterList)"); }
        public void visit(FormalParameterList n, Object o) { unimplementedVisitor("visit(FormalParameterList, Object)"); }

        public void visit(FixedParameters n) { unimplementedVisitor("visit(FixedParameters)"); }
        public void visit(FixedParameters n, Object o) { unimplementedVisitor("visit(FixedParameters, Object)"); }

        public void visit(FixedParameter n) { unimplementedVisitor("visit(FixedParameter)"); }
        public void visit(FixedParameter n, Object o) { unimplementedVisitor("visit(FixedParameter, Object)"); }

        public void visit(ParameterArray n) { unimplementedVisitor("visit(ParameterArray)"); }
        public void visit(ParameterArray n, Object o) { unimplementedVisitor("visit(ParameterArray, Object)"); }

        public void visit(PropertyDeclaration n) { unimplementedVisitor("visit(PropertyDeclaration)"); }
        public void visit(PropertyDeclaration n, Object o) { unimplementedVisitor("visit(PropertyDeclaration, Object)"); }

        public void visit(GetAccessorDeclaration n) { unimplementedVisitor("visit(GetAccessorDeclaration)"); }
        public void visit(GetAccessorDeclaration n, Object o) { unimplementedVisitor("visit(GetAccessorDeclaration, Object)"); }

        public void visit(SetAccessorDeclaration n) { unimplementedVisitor("visit(SetAccessorDeclaration)"); }
        public void visit(SetAccessorDeclaration n, Object o) { unimplementedVisitor("visit(SetAccessorDeclaration, Object)"); }

        public void visit(AccessorBody n) { unimplementedVisitor("visit(AccessorBody)"); }
        public void visit(AccessorBody n, Object o) { unimplementedVisitor("visit(AccessorBody, Object)"); }

        public void visit(AddAccessorDeclaration n) { unimplementedVisitor("visit(AddAccessorDeclaration)"); }
        public void visit(AddAccessorDeclaration n, Object o) { unimplementedVisitor("visit(AddAccessorDeclaration, Object)"); }

        public void visit(RemoveAccessorDeclaration n) { unimplementedVisitor("visit(RemoveAccessorDeclaration)"); }
        public void visit(RemoveAccessorDeclaration n, Object o) { unimplementedVisitor("visit(RemoveAccessorDeclaration, Object)"); }

        public void visit(IndexerDeclaration n) { unimplementedVisitor("visit(IndexerDeclaration)"); }
        public void visit(IndexerDeclaration n, Object o) { unimplementedVisitor("visit(IndexerDeclaration, Object)"); }

        public void visit(OperatorDeclaration n) { unimplementedVisitor("visit(OperatorDeclaration)"); }
        public void visit(OperatorDeclaration n, Object o) { unimplementedVisitor("visit(OperatorDeclaration, Object)"); }

        public void visit(SymbolOperatorDeclarator n) { unimplementedVisitor("visit(SymbolOperatorDeclarator)"); }
        public void visit(SymbolOperatorDeclarator n, Object o) { unimplementedVisitor("visit(SymbolOperatorDeclarator, Object)"); }

        public void visit(OperatorBody n) { unimplementedVisitor("visit(OperatorBody)"); }
        public void visit(OperatorBody n, Object o) { unimplementedVisitor("visit(OperatorBody, Object)"); }

        public void visit(ConstructorDeclaration n) { unimplementedVisitor("visit(ConstructorDeclaration)"); }
        public void visit(ConstructorDeclaration n, Object o) { unimplementedVisitor("visit(ConstructorDeclaration, Object)"); }

        public void visit(ConstructorDeclarator n) { unimplementedVisitor("visit(ConstructorDeclarator)"); }
        public void visit(ConstructorDeclarator n, Object o) { unimplementedVisitor("visit(ConstructorDeclarator, Object)"); }

        public void visit(ConstructorBody n) { unimplementedVisitor("visit(ConstructorBody)"); }
        public void visit(ConstructorBody n, Object o) { unimplementedVisitor("visit(ConstructorBody, Object)"); }

        public void visit(FinalizerDeclaration n) { unimplementedVisitor("visit(FinalizerDeclaration)"); }
        public void visit(FinalizerDeclaration n, Object o) { unimplementedVisitor("visit(FinalizerDeclaration, Object)"); }

        public void visit(FinalizerBody n) { unimplementedVisitor("visit(FinalizerBody)"); }
        public void visit(FinalizerBody n, Object o) { unimplementedVisitor("visit(FinalizerBody, Object)"); }

        public void visit(StructDeclaration n) { unimplementedVisitor("visit(StructDeclaration)"); }
        public void visit(StructDeclaration n, Object o) { unimplementedVisitor("visit(StructDeclaration, Object)"); }

        public void visit(StructInterfacesOpt n) { unimplementedVisitor("visit(StructInterfacesOpt)"); }
        public void visit(StructInterfacesOpt n, Object o) { unimplementedVisitor("visit(StructInterfacesOpt, Object)"); }

        public void visit(StructInterfaces n) { unimplementedVisitor("visit(StructInterfaces)"); }
        public void visit(StructInterfaces n, Object o) { unimplementedVisitor("visit(StructInterfaces, Object)"); }

        public void visit(StructBody n) { unimplementedVisitor("visit(StructBody)"); }
        public void visit(StructBody n, Object o) { unimplementedVisitor("visit(StructBody, Object)"); }

        public void visit(StructMemberDeclarations n) { unimplementedVisitor("visit(StructMemberDeclarations)"); }
        public void visit(StructMemberDeclarations n, Object o) { unimplementedVisitor("visit(StructMemberDeclarations, Object)"); }

        public void visit(ArrayType n) { unimplementedVisitor("visit(ArrayType)"); }
        public void visit(ArrayType n, Object o) { unimplementedVisitor("visit(ArrayType, Object)"); }

        public void visit(RankSpecifiers n) { unimplementedVisitor("visit(RankSpecifiers)"); }
        public void visit(RankSpecifiers n, Object o) { unimplementedVisitor("visit(RankSpecifiers, Object)"); }

        public void visit(RankSpecifier n) { unimplementedVisitor("visit(RankSpecifier)"); }
        public void visit(RankSpecifier n, Object o) { unimplementedVisitor("visit(RankSpecifier, Object)"); }

        public void visit(VariableInitializerList n) { unimplementedVisitor("visit(VariableInitializerList)"); }
        public void visit(VariableInitializerList n, Object o) { unimplementedVisitor("visit(VariableInitializerList, Object)"); }

        public void visit(InterfaceDeclaration n) { unimplementedVisitor("visit(InterfaceDeclaration)"); }
        public void visit(InterfaceDeclaration n, Object o) { unimplementedVisitor("visit(InterfaceDeclaration, Object)"); }

        public void visit(InterfaceBase n) { unimplementedVisitor("visit(InterfaceBase)"); }
        public void visit(InterfaceBase n, Object o) { unimplementedVisitor("visit(InterfaceBase, Object)"); }

        public void visit(InterfaceBody n) { unimplementedVisitor("visit(InterfaceBody)"); }
        public void visit(InterfaceBody n, Object o) { unimplementedVisitor("visit(InterfaceBody, Object)"); }

        public void visit(InterfaceMemberDeclarations n) { unimplementedVisitor("visit(InterfaceMemberDeclarations)"); }
        public void visit(InterfaceMemberDeclarations n, Object o) { unimplementedVisitor("visit(InterfaceMemberDeclarations, Object)"); }

        public void visit(InterfaceMethodDeclaration n) { unimplementedVisitor("visit(InterfaceMethodDeclaration)"); }
        public void visit(InterfaceMethodDeclaration n, Object o) { unimplementedVisitor("visit(InterfaceMethodDeclaration, Object)"); }

        public void visit(InterfacePropertyDeclaration n) { unimplementedVisitor("visit(InterfacePropertyDeclaration)"); }
        public void visit(InterfacePropertyDeclaration n, Object o) { unimplementedVisitor("visit(InterfacePropertyDeclaration, Object)"); }

        public void visit(InterfaceEventDeclaration n) { unimplementedVisitor("visit(InterfaceEventDeclaration)"); }
        public void visit(InterfaceEventDeclaration n, Object o) { unimplementedVisitor("visit(InterfaceEventDeclaration, Object)"); }

        public void visit(InterfaceIndexerDeclaration n) { unimplementedVisitor("visit(InterfaceIndexerDeclaration)"); }
        public void visit(InterfaceIndexerDeclaration n, Object o) { unimplementedVisitor("visit(InterfaceIndexerDeclaration, Object)"); }

        public void visit(EnumDeclaration n) { unimplementedVisitor("visit(EnumDeclaration)"); }
        public void visit(EnumDeclaration n, Object o) { unimplementedVisitor("visit(EnumDeclaration, Object)"); }

        public void visit(EnumBase n) { unimplementedVisitor("visit(EnumBase)"); }
        public void visit(EnumBase n, Object o) { unimplementedVisitor("visit(EnumBase, Object)"); }

        public void visit(EnumMemberDeclarations n) { unimplementedVisitor("visit(EnumMemberDeclarations)"); }
        public void visit(EnumMemberDeclarations n, Object o) { unimplementedVisitor("visit(EnumMemberDeclarations, Object)"); }

        public void visit(DelegateDeclaration n) { unimplementedVisitor("visit(DelegateDeclaration)"); }
        public void visit(DelegateDeclaration n, Object o) { unimplementedVisitor("visit(DelegateDeclaration, Object)"); }

        public void visit(AttributeSections n) { unimplementedVisitor("visit(AttributeSections)"); }
        public void visit(AttributeSections n, Object o) { unimplementedVisitor("visit(AttributeSections, Object)"); }

        public void visit(AttributeTargetSpecifier n) { unimplementedVisitor("visit(AttributeTargetSpecifier)"); }
        public void visit(AttributeTargetSpecifier n, Object o) { unimplementedVisitor("visit(AttributeTargetSpecifier, Object)"); }

        public void visit(AttributeTarget n) { unimplementedVisitor("visit(AttributeTarget)"); }
        public void visit(AttributeTarget n, Object o) { unimplementedVisitor("visit(AttributeTarget, Object)"); }

        public void visit(AttributeList n) { unimplementedVisitor("visit(AttributeList)"); }
        public void visit(AttributeList n, Object o) { unimplementedVisitor("visit(AttributeList, Object)"); }

        public void visit(Attribute n) { unimplementedVisitor("visit(Attribute)"); }
        public void visit(Attribute n, Object o) { unimplementedVisitor("visit(Attribute, Object)"); }

        public void visit(PositionalArgumentList n) { unimplementedVisitor("visit(PositionalArgumentList)"); }
        public void visit(PositionalArgumentList n, Object o) { unimplementedVisitor("visit(PositionalArgumentList, Object)"); }

        public void visit(NamedArgumentList n) { unimplementedVisitor("visit(NamedArgumentList)"); }
        public void visit(NamedArgumentList n, Object o) { unimplementedVisitor("visit(NamedArgumentList, Object)"); }

        public void visit(NamedArgument n) { unimplementedVisitor("visit(NamedArgument)"); }
        public void visit(NamedArgument n, Object o) { unimplementedVisitor("visit(NamedArgument, Object)"); }

        public void visit(TypeParameterList n) { unimplementedVisitor("visit(TypeParameterList)"); }
        public void visit(TypeParameterList n, Object o) { unimplementedVisitor("visit(TypeParameterList, Object)"); }

        public void visit(TypeParameter n) { unimplementedVisitor("visit(TypeParameter)"); }
        public void visit(TypeParameter n, Object o) { unimplementedVisitor("visit(TypeParameter, Object)"); }

        public void visit(TypeArgumentList n) { unimplementedVisitor("visit(TypeArgumentList)"); }
        public void visit(TypeArgumentList n, Object o) { unimplementedVisitor("visit(TypeArgumentList, Object)"); }

        public void visit(TypeArguments n) { unimplementedVisitor("visit(TypeArguments)"); }
        public void visit(TypeArguments n, Object o) { unimplementedVisitor("visit(TypeArguments, Object)"); }

        public void visit(TypeParameterConstraintsClauses n) { unimplementedVisitor("visit(TypeParameterConstraintsClauses)"); }
        public void visit(TypeParameterConstraintsClauses n, Object o) { unimplementedVisitor("visit(TypeParameterConstraintsClauses, Object)"); }

        public void visit(TypeParameterConstraintsClause n) { unimplementedVisitor("visit(TypeParameterConstraintsClause)"); }
        public void visit(TypeParameterConstraintsClause n, Object o) { unimplementedVisitor("visit(TypeParameterConstraintsClause, Object)"); }

        public void visit(TypeParameterConstraints n) { unimplementedVisitor("visit(TypeParameterConstraints)"); }
        public void visit(TypeParameterConstraints n, Object o) { unimplementedVisitor("visit(TypeParameterConstraints, Object)"); }

        public void visit(Constraints n) { unimplementedVisitor("visit(Constraints)"); }
        public void visit(Constraints n, Object o) { unimplementedVisitor("visit(Constraints, Object)"); }

        public void visit(ConstructorConstraint n) { unimplementedVisitor("visit(ConstructorConstraint)"); }
        public void visit(ConstructorConstraint n, Object o) { unimplementedVisitor("visit(ConstructorConstraint, Object)"); }

        public void visit(BooleanLiteral0 n) { unimplementedVisitor("visit(BooleanLiteral0)"); }
        public void visit(BooleanLiteral0 n, Object o) { unimplementedVisitor("visit(BooleanLiteral0, Object)"); }

        public void visit(BooleanLiteral1 n) { unimplementedVisitor("visit(BooleanLiteral1)"); }
        public void visit(BooleanLiteral1 n, Object o) { unimplementedVisitor("visit(BooleanLiteral1, Object)"); }

        public void visit(Name0 n) { unimplementedVisitor("visit(Name0)"); }
        public void visit(Name0 n, Object o) { unimplementedVisitor("visit(Name0, Object)"); }

        public void visit(Name1 n) { unimplementedVisitor("visit(Name1)"); }
        public void visit(Name1 n, Object o) { unimplementedVisitor("visit(Name1, Object)"); }

        public void visit(Name2 n) { unimplementedVisitor("visit(Name2)"); }
        public void visit(Name2 n, Object o) { unimplementedVisitor("visit(Name2, Object)"); }

        public void visit(NonNamedType0 n) { unimplementedVisitor("visit(NonNamedType0)"); }
        public void visit(NonNamedType0 n, Object o) { unimplementedVisitor("visit(NonNamedType0, Object)"); }

        public void visit(NonNamedType1 n) { unimplementedVisitor("visit(NonNamedType1)"); }
        public void visit(NonNamedType1 n, Object o) { unimplementedVisitor("visit(NonNamedType1, Object)"); }

        public void visit(IntegralType0 n) { unimplementedVisitor("visit(IntegralType0)"); }
        public void visit(IntegralType0 n, Object o) { unimplementedVisitor("visit(IntegralType0, Object)"); }

        public void visit(IntegralType1 n) { unimplementedVisitor("visit(IntegralType1)"); }
        public void visit(IntegralType1 n, Object o) { unimplementedVisitor("visit(IntegralType1, Object)"); }

        public void visit(IntegralType2 n) { unimplementedVisitor("visit(IntegralType2)"); }
        public void visit(IntegralType2 n, Object o) { unimplementedVisitor("visit(IntegralType2, Object)"); }

        public void visit(IntegralType3 n) { unimplementedVisitor("visit(IntegralType3)"); }
        public void visit(IntegralType3 n, Object o) { unimplementedVisitor("visit(IntegralType3, Object)"); }

        public void visit(IntegralType4 n) { unimplementedVisitor("visit(IntegralType4)"); }
        public void visit(IntegralType4 n, Object o) { unimplementedVisitor("visit(IntegralType4, Object)"); }

        public void visit(IntegralType5 n) { unimplementedVisitor("visit(IntegralType5)"); }
        public void visit(IntegralType5 n, Object o) { unimplementedVisitor("visit(IntegralType5, Object)"); }

        public void visit(IntegralType6 n) { unimplementedVisitor("visit(IntegralType6)"); }
        public void visit(IntegralType6 n, Object o) { unimplementedVisitor("visit(IntegralType6, Object)"); }

        public void visit(IntegralType7 n) { unimplementedVisitor("visit(IntegralType7)"); }
        public void visit(IntegralType7 n, Object o) { unimplementedVisitor("visit(IntegralType7, Object)"); }

        public void visit(IntegralType8 n) { unimplementedVisitor("visit(IntegralType8)"); }
        public void visit(IntegralType8 n, Object o) { unimplementedVisitor("visit(IntegralType8, Object)"); }

        public void visit(FloatingPointType0 n) { unimplementedVisitor("visit(FloatingPointType0)"); }
        public void visit(FloatingPointType0 n, Object o) { unimplementedVisitor("visit(FloatingPointType0, Object)"); }

        public void visit(FloatingPointType1 n) { unimplementedVisitor("visit(FloatingPointType1)"); }
        public void visit(FloatingPointType1 n, Object o) { unimplementedVisitor("visit(FloatingPointType1, Object)"); }

        public void visit(ClassType0 n) { unimplementedVisitor("visit(ClassType0)"); }
        public void visit(ClassType0 n, Object o) { unimplementedVisitor("visit(ClassType0, Object)"); }

        public void visit(ClassType1 n) { unimplementedVisitor("visit(ClassType1)"); }
        public void visit(ClassType1 n, Object o) { unimplementedVisitor("visit(ClassType1, Object)"); }

        public void visit(Argument0 n) { unimplementedVisitor("visit(Argument0)"); }
        public void visit(Argument0 n, Object o) { unimplementedVisitor("visit(Argument0, Object)"); }

        public void visit(Argument1 n) { unimplementedVisitor("visit(Argument1)"); }
        public void visit(Argument1 n, Object o) { unimplementedVisitor("visit(Argument1, Object)"); }

        public void visit(MemberAccess0 n) { unimplementedVisitor("visit(MemberAccess0)"); }
        public void visit(MemberAccess0 n, Object o) { unimplementedVisitor("visit(MemberAccess0, Object)"); }

        public void visit(MemberAccess1 n) { unimplementedVisitor("visit(MemberAccess1)"); }
        public void visit(MemberAccess1 n, Object o) { unimplementedVisitor("visit(MemberAccess1, Object)"); }

        public void visit(MemberAccess2 n) { unimplementedVisitor("visit(MemberAccess2)"); }
        public void visit(MemberAccess2 n, Object o) { unimplementedVisitor("visit(MemberAccess2, Object)"); }

        public void visit(PredefinedType0 n) { unimplementedVisitor("visit(PredefinedType0)"); }
        public void visit(PredefinedType0 n, Object o) { unimplementedVisitor("visit(PredefinedType0, Object)"); }

        public void visit(PredefinedType1 n) { unimplementedVisitor("visit(PredefinedType1)"); }
        public void visit(PredefinedType1 n, Object o) { unimplementedVisitor("visit(PredefinedType1, Object)"); }

        public void visit(PredefinedType2 n) { unimplementedVisitor("visit(PredefinedType2)"); }
        public void visit(PredefinedType2 n, Object o) { unimplementedVisitor("visit(PredefinedType2, Object)"); }

        public void visit(PredefinedType3 n) { unimplementedVisitor("visit(PredefinedType3)"); }
        public void visit(PredefinedType3 n, Object o) { unimplementedVisitor("visit(PredefinedType3, Object)"); }

        public void visit(PredefinedType4 n) { unimplementedVisitor("visit(PredefinedType4)"); }
        public void visit(PredefinedType4 n, Object o) { unimplementedVisitor("visit(PredefinedType4, Object)"); }

        public void visit(PredefinedType5 n) { unimplementedVisitor("visit(PredefinedType5)"); }
        public void visit(PredefinedType5 n, Object o) { unimplementedVisitor("visit(PredefinedType5, Object)"); }

        public void visit(PredefinedType6 n) { unimplementedVisitor("visit(PredefinedType6)"); }
        public void visit(PredefinedType6 n, Object o) { unimplementedVisitor("visit(PredefinedType6, Object)"); }

        public void visit(PredefinedType7 n) { unimplementedVisitor("visit(PredefinedType7)"); }
        public void visit(PredefinedType7 n, Object o) { unimplementedVisitor("visit(PredefinedType7, Object)"); }

        public void visit(PredefinedType8 n) { unimplementedVisitor("visit(PredefinedType8)"); }
        public void visit(PredefinedType8 n, Object o) { unimplementedVisitor("visit(PredefinedType8, Object)"); }

        public void visit(PredefinedType9 n) { unimplementedVisitor("visit(PredefinedType9)"); }
        public void visit(PredefinedType9 n, Object o) { unimplementedVisitor("visit(PredefinedType9, Object)"); }

        public void visit(PredefinedType10 n) { unimplementedVisitor("visit(PredefinedType10)"); }
        public void visit(PredefinedType10 n, Object o) { unimplementedVisitor("visit(PredefinedType10, Object)"); }

        public void visit(PredefinedType11 n) { unimplementedVisitor("visit(PredefinedType11)"); }
        public void visit(PredefinedType11 n, Object o) { unimplementedVisitor("visit(PredefinedType11, Object)"); }

        public void visit(PredefinedType12 n) { unimplementedVisitor("visit(PredefinedType12)"); }
        public void visit(PredefinedType12 n, Object o) { unimplementedVisitor("visit(PredefinedType12, Object)"); }

        public void visit(PredefinedType13 n) { unimplementedVisitor("visit(PredefinedType13)"); }
        public void visit(PredefinedType13 n, Object o) { unimplementedVisitor("visit(PredefinedType13, Object)"); }

        public void visit(PredefinedType14 n) { unimplementedVisitor("visit(PredefinedType14)"); }
        public void visit(PredefinedType14 n, Object o) { unimplementedVisitor("visit(PredefinedType14, Object)"); }

        public void visit(BaseAccess0 n) { unimplementedVisitor("visit(BaseAccess0)"); }
        public void visit(BaseAccess0 n, Object o) { unimplementedVisitor("visit(BaseAccess0, Object)"); }

        public void visit(BaseAccess1 n) { unimplementedVisitor("visit(BaseAccess1)"); }
        public void visit(BaseAccess1 n, Object o) { unimplementedVisitor("visit(BaseAccess1, Object)"); }

        public void visit(ArrayCreationExpression0 n) { unimplementedVisitor("visit(ArrayCreationExpression0)"); }
        public void visit(ArrayCreationExpression0 n, Object o) { unimplementedVisitor("visit(ArrayCreationExpression0, Object)"); }

        public void visit(ArrayCreationExpression1 n) { unimplementedVisitor("visit(ArrayCreationExpression1)"); }
        public void visit(ArrayCreationExpression1 n, Object o) { unimplementedVisitor("visit(ArrayCreationExpression1, Object)"); }

        public void visit(TypeofExpression0 n) { unimplementedVisitor("visit(TypeofExpression0)"); }
        public void visit(TypeofExpression0 n, Object o) { unimplementedVisitor("visit(TypeofExpression0, Object)"); }

        public void visit(TypeofExpression1 n) { unimplementedVisitor("visit(TypeofExpression1)"); }
        public void visit(TypeofExpression1 n, Object o) { unimplementedVisitor("visit(TypeofExpression1, Object)"); }

        public void visit(UnboundTypeName0 n) { unimplementedVisitor("visit(UnboundTypeName0)"); }
        public void visit(UnboundTypeName0 n, Object o) { unimplementedVisitor("visit(UnboundTypeName0, Object)"); }

        public void visit(UnboundTypeName1 n) { unimplementedVisitor("visit(UnboundTypeName1)"); }
        public void visit(UnboundTypeName1 n, Object o) { unimplementedVisitor("visit(UnboundTypeName1, Object)"); }

        public void visit(UnboundTypeName2 n) { unimplementedVisitor("visit(UnboundTypeName2)"); }
        public void visit(UnboundTypeName2 n, Object o) { unimplementedVisitor("visit(UnboundTypeName2, Object)"); }

        public void visit(Commas0 n) { unimplementedVisitor("visit(Commas0)"); }
        public void visit(Commas0 n, Object o) { unimplementedVisitor("visit(Commas0, Object)"); }

        public void visit(Commas1 n) { unimplementedVisitor("visit(Commas1)"); }
        public void visit(Commas1 n, Object o) { unimplementedVisitor("visit(Commas1, Object)"); }

        public void visit(UnaryExpression0 n) { unimplementedVisitor("visit(UnaryExpression0)"); }
        public void visit(UnaryExpression0 n, Object o) { unimplementedVisitor("visit(UnaryExpression0, Object)"); }

        public void visit(UnaryExpression1 n) { unimplementedVisitor("visit(UnaryExpression1)"); }
        public void visit(UnaryExpression1 n, Object o) { unimplementedVisitor("visit(UnaryExpression1, Object)"); }

        public void visit(UnaryExpression2 n) { unimplementedVisitor("visit(UnaryExpression2)"); }
        public void visit(UnaryExpression2 n, Object o) { unimplementedVisitor("visit(UnaryExpression2, Object)"); }

        public void visit(UnaryExpression3 n) { unimplementedVisitor("visit(UnaryExpression3)"); }
        public void visit(UnaryExpression3 n, Object o) { unimplementedVisitor("visit(UnaryExpression3, Object)"); }

        public void visit(MultiplicativeExpression0 n) { unimplementedVisitor("visit(MultiplicativeExpression0)"); }
        public void visit(MultiplicativeExpression0 n, Object o) { unimplementedVisitor("visit(MultiplicativeExpression0, Object)"); }

        public void visit(MultiplicativeExpression1 n) { unimplementedVisitor("visit(MultiplicativeExpression1)"); }
        public void visit(MultiplicativeExpression1 n, Object o) { unimplementedVisitor("visit(MultiplicativeExpression1, Object)"); }

        public void visit(MultiplicativeExpression2 n) { unimplementedVisitor("visit(MultiplicativeExpression2)"); }
        public void visit(MultiplicativeExpression2 n, Object o) { unimplementedVisitor("visit(MultiplicativeExpression2, Object)"); }

        public void visit(AdditiveExpression0 n) { unimplementedVisitor("visit(AdditiveExpression0)"); }
        public void visit(AdditiveExpression0 n, Object o) { unimplementedVisitor("visit(AdditiveExpression0, Object)"); }

        public void visit(AdditiveExpression1 n) { unimplementedVisitor("visit(AdditiveExpression1)"); }
        public void visit(AdditiveExpression1 n, Object o) { unimplementedVisitor("visit(AdditiveExpression1, Object)"); }

        public void visit(ShiftExpression0 n) { unimplementedVisitor("visit(ShiftExpression0)"); }
        public void visit(ShiftExpression0 n, Object o) { unimplementedVisitor("visit(ShiftExpression0, Object)"); }

        public void visit(ShiftExpression1 n) { unimplementedVisitor("visit(ShiftExpression1)"); }
        public void visit(ShiftExpression1 n, Object o) { unimplementedVisitor("visit(ShiftExpression1, Object)"); }

        public void visit(RelationalExpression0 n) { unimplementedVisitor("visit(RelationalExpression0)"); }
        public void visit(RelationalExpression0 n, Object o) { unimplementedVisitor("visit(RelationalExpression0, Object)"); }

        public void visit(RelationalExpression1 n) { unimplementedVisitor("visit(RelationalExpression1)"); }
        public void visit(RelationalExpression1 n, Object o) { unimplementedVisitor("visit(RelationalExpression1, Object)"); }

        public void visit(RelationalExpression2 n) { unimplementedVisitor("visit(RelationalExpression2)"); }
        public void visit(RelationalExpression2 n, Object o) { unimplementedVisitor("visit(RelationalExpression2, Object)"); }

        public void visit(RelationalExpression3 n) { unimplementedVisitor("visit(RelationalExpression3)"); }
        public void visit(RelationalExpression3 n, Object o) { unimplementedVisitor("visit(RelationalExpression3, Object)"); }

        public void visit(RelationalExpression4 n) { unimplementedVisitor("visit(RelationalExpression4)"); }
        public void visit(RelationalExpression4 n, Object o) { unimplementedVisitor("visit(RelationalExpression4, Object)"); }

        public void visit(RelationalExpression5 n) { unimplementedVisitor("visit(RelationalExpression5)"); }
        public void visit(RelationalExpression5 n, Object o) { unimplementedVisitor("visit(RelationalExpression5, Object)"); }

        public void visit(EqualityExpression0 n) { unimplementedVisitor("visit(EqualityExpression0)"); }
        public void visit(EqualityExpression0 n, Object o) { unimplementedVisitor("visit(EqualityExpression0, Object)"); }

        public void visit(EqualityExpression1 n) { unimplementedVisitor("visit(EqualityExpression1)"); }
        public void visit(EqualityExpression1 n, Object o) { unimplementedVisitor("visit(EqualityExpression1, Object)"); }

        public void visit(AssignmentOperator0 n) { unimplementedVisitor("visit(AssignmentOperator0)"); }
        public void visit(AssignmentOperator0 n, Object o) { unimplementedVisitor("visit(AssignmentOperator0, Object)"); }

        public void visit(AssignmentOperator1 n) { unimplementedVisitor("visit(AssignmentOperator1)"); }
        public void visit(AssignmentOperator1 n, Object o) { unimplementedVisitor("visit(AssignmentOperator1, Object)"); }

        public void visit(AssignmentOperator2 n) { unimplementedVisitor("visit(AssignmentOperator2)"); }
        public void visit(AssignmentOperator2 n, Object o) { unimplementedVisitor("visit(AssignmentOperator2, Object)"); }

        public void visit(AssignmentOperator3 n) { unimplementedVisitor("visit(AssignmentOperator3)"); }
        public void visit(AssignmentOperator3 n, Object o) { unimplementedVisitor("visit(AssignmentOperator3, Object)"); }

        public void visit(AssignmentOperator4 n) { unimplementedVisitor("visit(AssignmentOperator4)"); }
        public void visit(AssignmentOperator4 n, Object o) { unimplementedVisitor("visit(AssignmentOperator4, Object)"); }

        public void visit(AssignmentOperator5 n) { unimplementedVisitor("visit(AssignmentOperator5)"); }
        public void visit(AssignmentOperator5 n, Object o) { unimplementedVisitor("visit(AssignmentOperator5, Object)"); }

        public void visit(AssignmentOperator6 n) { unimplementedVisitor("visit(AssignmentOperator6)"); }
        public void visit(AssignmentOperator6 n, Object o) { unimplementedVisitor("visit(AssignmentOperator6, Object)"); }

        public void visit(AssignmentOperator7 n) { unimplementedVisitor("visit(AssignmentOperator7)"); }
        public void visit(AssignmentOperator7 n, Object o) { unimplementedVisitor("visit(AssignmentOperator7, Object)"); }

        public void visit(AssignmentOperator8 n) { unimplementedVisitor("visit(AssignmentOperator8)"); }
        public void visit(AssignmentOperator8 n, Object o) { unimplementedVisitor("visit(AssignmentOperator8, Object)"); }

        public void visit(AssignmentOperator9 n) { unimplementedVisitor("visit(AssignmentOperator9)"); }
        public void visit(AssignmentOperator9 n, Object o) { unimplementedVisitor("visit(AssignmentOperator9, Object)"); }

        public void visit(AssignmentOperator10 n) { unimplementedVisitor("visit(AssignmentOperator10)"); }
        public void visit(AssignmentOperator10 n, Object o) { unimplementedVisitor("visit(AssignmentOperator10, Object)"); }

        public void visit(DeclarationStatement0 n) { unimplementedVisitor("visit(DeclarationStatement0)"); }
        public void visit(DeclarationStatement0 n, Object o) { unimplementedVisitor("visit(DeclarationStatement0, Object)"); }

        public void visit(DeclarationStatement1 n) { unimplementedVisitor("visit(DeclarationStatement1)"); }
        public void visit(DeclarationStatement1 n, Object o) { unimplementedVisitor("visit(DeclarationStatement1, Object)"); }

        public void visit(LocalVariableDeclarator0 n) { unimplementedVisitor("visit(LocalVariableDeclarator0)"); }
        public void visit(LocalVariableDeclarator0 n, Object o) { unimplementedVisitor("visit(LocalVariableDeclarator0, Object)"); }

        public void visit(LocalVariableDeclarator1 n) { unimplementedVisitor("visit(LocalVariableDeclarator1)"); }
        public void visit(LocalVariableDeclarator1 n, Object o) { unimplementedVisitor("visit(LocalVariableDeclarator1, Object)"); }

        public void visit(SwitchLabel0 n) { unimplementedVisitor("visit(SwitchLabel0)"); }
        public void visit(SwitchLabel0 n, Object o) { unimplementedVisitor("visit(SwitchLabel0, Object)"); }

        public void visit(SwitchLabel1 n) { unimplementedVisitor("visit(SwitchLabel1)"); }
        public void visit(SwitchLabel1 n, Object o) { unimplementedVisitor("visit(SwitchLabel1, Object)"); }

        public void visit(GotoStatement0 n) { unimplementedVisitor("visit(GotoStatement0)"); }
        public void visit(GotoStatement0 n, Object o) { unimplementedVisitor("visit(GotoStatement0, Object)"); }

        public void visit(GotoStatement1 n) { unimplementedVisitor("visit(GotoStatement1)"); }
        public void visit(GotoStatement1 n, Object o) { unimplementedVisitor("visit(GotoStatement1, Object)"); }

        public void visit(GotoStatement2 n) { unimplementedVisitor("visit(GotoStatement2)"); }
        public void visit(GotoStatement2 n, Object o) { unimplementedVisitor("visit(GotoStatement2, Object)"); }

        public void visit(TryStatement0 n) { unimplementedVisitor("visit(TryStatement0)"); }
        public void visit(TryStatement0 n, Object o) { unimplementedVisitor("visit(TryStatement0, Object)"); }

        public void visit(TryStatement1 n) { unimplementedVisitor("visit(TryStatement1)"); }
        public void visit(TryStatement1 n, Object o) { unimplementedVisitor("visit(TryStatement1, Object)"); }

        public void visit(YieldStatement0 n) { unimplementedVisitor("visit(YieldStatement0)"); }
        public void visit(YieldStatement0 n, Object o) { unimplementedVisitor("visit(YieldStatement0, Object)"); }

        public void visit(YieldStatement1 n) { unimplementedVisitor("visit(YieldStatement1)"); }
        public void visit(YieldStatement1 n, Object o) { unimplementedVisitor("visit(YieldStatement1, Object)"); }

        public void visit(Modifier0 n) { unimplementedVisitor("visit(Modifier0)"); }
        public void visit(Modifier0 n, Object o) { unimplementedVisitor("visit(Modifier0, Object)"); }

        public void visit(Modifier1 n) { unimplementedVisitor("visit(Modifier1)"); }
        public void visit(Modifier1 n, Object o) { unimplementedVisitor("visit(Modifier1, Object)"); }

        public void visit(Modifier2 n) { unimplementedVisitor("visit(Modifier2)"); }
        public void visit(Modifier2 n, Object o) { unimplementedVisitor("visit(Modifier2, Object)"); }

        public void visit(Modifier3 n) { unimplementedVisitor("visit(Modifier3)"); }
        public void visit(Modifier3 n, Object o) { unimplementedVisitor("visit(Modifier3, Object)"); }

        public void visit(Modifier4 n) { unimplementedVisitor("visit(Modifier4)"); }
        public void visit(Modifier4 n, Object o) { unimplementedVisitor("visit(Modifier4, Object)"); }

        public void visit(Modifier5 n) { unimplementedVisitor("visit(Modifier5)"); }
        public void visit(Modifier5 n, Object o) { unimplementedVisitor("visit(Modifier5, Object)"); }

        public void visit(Modifier6 n) { unimplementedVisitor("visit(Modifier6)"); }
        public void visit(Modifier6 n, Object o) { unimplementedVisitor("visit(Modifier6, Object)"); }

        public void visit(Modifier7 n) { unimplementedVisitor("visit(Modifier7)"); }
        public void visit(Modifier7 n, Object o) { unimplementedVisitor("visit(Modifier7, Object)"); }

        public void visit(Modifier8 n) { unimplementedVisitor("visit(Modifier8)"); }
        public void visit(Modifier8 n, Object o) { unimplementedVisitor("visit(Modifier8, Object)"); }

        public void visit(Modifier9 n) { unimplementedVisitor("visit(Modifier9)"); }
        public void visit(Modifier9 n, Object o) { unimplementedVisitor("visit(Modifier9, Object)"); }

        public void visit(Modifier10 n) { unimplementedVisitor("visit(Modifier10)"); }
        public void visit(Modifier10 n, Object o) { unimplementedVisitor("visit(Modifier10, Object)"); }

        public void visit(Modifier11 n) { unimplementedVisitor("visit(Modifier11)"); }
        public void visit(Modifier11 n, Object o) { unimplementedVisitor("visit(Modifier11, Object)"); }

        public void visit(Modifier12 n) { unimplementedVisitor("visit(Modifier12)"); }
        public void visit(Modifier12 n, Object o) { unimplementedVisitor("visit(Modifier12, Object)"); }

        public void visit(VariableDeclarator0 n) { unimplementedVisitor("visit(VariableDeclarator0)"); }
        public void visit(VariableDeclarator0 n, Object o) { unimplementedVisitor("visit(VariableDeclarator0, Object)"); }

        public void visit(VariableDeclarator1 n) { unimplementedVisitor("visit(VariableDeclarator1)"); }
        public void visit(VariableDeclarator1 n, Object o) { unimplementedVisitor("visit(VariableDeclarator1, Object)"); }

        public void visit(ParameterModifier0 n) { unimplementedVisitor("visit(ParameterModifier0)"); }
        public void visit(ParameterModifier0 n, Object o) { unimplementedVisitor("visit(ParameterModifier0, Object)"); }

        public void visit(ParameterModifier1 n) { unimplementedVisitor("visit(ParameterModifier1)"); }
        public void visit(ParameterModifier1 n, Object o) { unimplementedVisitor("visit(ParameterModifier1, Object)"); }

        public void visit(AccessorDeclarations0 n) { unimplementedVisitor("visit(AccessorDeclarations0)"); }
        public void visit(AccessorDeclarations0 n, Object o) { unimplementedVisitor("visit(AccessorDeclarations0, Object)"); }

        public void visit(AccessorDeclarations1 n) { unimplementedVisitor("visit(AccessorDeclarations1)"); }
        public void visit(AccessorDeclarations1 n, Object o) { unimplementedVisitor("visit(AccessorDeclarations1, Object)"); }

        public void visit(AccessorModifier0 n) { unimplementedVisitor("visit(AccessorModifier0)"); }
        public void visit(AccessorModifier0 n, Object o) { unimplementedVisitor("visit(AccessorModifier0, Object)"); }

        public void visit(AccessorModifier1 n) { unimplementedVisitor("visit(AccessorModifier1)"); }
        public void visit(AccessorModifier1 n, Object o) { unimplementedVisitor("visit(AccessorModifier1, Object)"); }

        public void visit(AccessorModifier2 n) { unimplementedVisitor("visit(AccessorModifier2)"); }
        public void visit(AccessorModifier2 n, Object o) { unimplementedVisitor("visit(AccessorModifier2, Object)"); }

        public void visit(AccessorModifier3 n) { unimplementedVisitor("visit(AccessorModifier3)"); }
        public void visit(AccessorModifier3 n, Object o) { unimplementedVisitor("visit(AccessorModifier3, Object)"); }

        public void visit(AccessorModifier4 n) { unimplementedVisitor("visit(AccessorModifier4)"); }
        public void visit(AccessorModifier4 n, Object o) { unimplementedVisitor("visit(AccessorModifier4, Object)"); }

        public void visit(EventDeclaration0 n) { unimplementedVisitor("visit(EventDeclaration0)"); }
        public void visit(EventDeclaration0 n, Object o) { unimplementedVisitor("visit(EventDeclaration0, Object)"); }

        public void visit(EventDeclaration1 n) { unimplementedVisitor("visit(EventDeclaration1)"); }
        public void visit(EventDeclaration1 n, Object o) { unimplementedVisitor("visit(EventDeclaration1, Object)"); }

        public void visit(EventAccessorDeclarations0 n) { unimplementedVisitor("visit(EventAccessorDeclarations0)"); }
        public void visit(EventAccessorDeclarations0 n, Object o) { unimplementedVisitor("visit(EventAccessorDeclarations0, Object)"); }

        public void visit(EventAccessorDeclarations1 n) { unimplementedVisitor("visit(EventAccessorDeclarations1)"); }
        public void visit(EventAccessorDeclarations1 n, Object o) { unimplementedVisitor("visit(EventAccessorDeclarations1, Object)"); }

        public void visit(IndexerDeclarator0 n) { unimplementedVisitor("visit(IndexerDeclarator0)"); }
        public void visit(IndexerDeclarator0 n, Object o) { unimplementedVisitor("visit(IndexerDeclarator0, Object)"); }

        public void visit(IndexerDeclarator1 n) { unimplementedVisitor("visit(IndexerDeclarator1)"); }
        public void visit(IndexerDeclarator1 n, Object o) { unimplementedVisitor("visit(IndexerDeclarator1, Object)"); }

        public void visit(OverloadableOperator0 n) { unimplementedVisitor("visit(OverloadableOperator0)"); }
        public void visit(OverloadableOperator0 n, Object o) { unimplementedVisitor("visit(OverloadableOperator0, Object)"); }

        public void visit(OverloadableOperator1 n) { unimplementedVisitor("visit(OverloadableOperator1)"); }
        public void visit(OverloadableOperator1 n, Object o) { unimplementedVisitor("visit(OverloadableOperator1, Object)"); }

        public void visit(OverloadableOperator2 n) { unimplementedVisitor("visit(OverloadableOperator2)"); }
        public void visit(OverloadableOperator2 n, Object o) { unimplementedVisitor("visit(OverloadableOperator2, Object)"); }

        public void visit(OverloadableOperator3 n) { unimplementedVisitor("visit(OverloadableOperator3)"); }
        public void visit(OverloadableOperator3 n, Object o) { unimplementedVisitor("visit(OverloadableOperator3, Object)"); }

        public void visit(OverloadableOperator4 n) { unimplementedVisitor("visit(OverloadableOperator4)"); }
        public void visit(OverloadableOperator4 n, Object o) { unimplementedVisitor("visit(OverloadableOperator4, Object)"); }

        public void visit(OverloadableOperator5 n) { unimplementedVisitor("visit(OverloadableOperator5)"); }
        public void visit(OverloadableOperator5 n, Object o) { unimplementedVisitor("visit(OverloadableOperator5, Object)"); }

        public void visit(OverloadableOperator6 n) { unimplementedVisitor("visit(OverloadableOperator6)"); }
        public void visit(OverloadableOperator6 n, Object o) { unimplementedVisitor("visit(OverloadableOperator6, Object)"); }

        public void visit(OverloadableOperator7 n) { unimplementedVisitor("visit(OverloadableOperator7)"); }
        public void visit(OverloadableOperator7 n, Object o) { unimplementedVisitor("visit(OverloadableOperator7, Object)"); }

        public void visit(OverloadableOperator8 n) { unimplementedVisitor("visit(OverloadableOperator8)"); }
        public void visit(OverloadableOperator8 n, Object o) { unimplementedVisitor("visit(OverloadableOperator8, Object)"); }

        public void visit(OverloadableOperator9 n) { unimplementedVisitor("visit(OverloadableOperator9)"); }
        public void visit(OverloadableOperator9 n, Object o) { unimplementedVisitor("visit(OverloadableOperator9, Object)"); }

        public void visit(OverloadableOperator10 n) { unimplementedVisitor("visit(OverloadableOperator10)"); }
        public void visit(OverloadableOperator10 n, Object o) { unimplementedVisitor("visit(OverloadableOperator10, Object)"); }

        public void visit(OverloadableOperator11 n) { unimplementedVisitor("visit(OverloadableOperator11)"); }
        public void visit(OverloadableOperator11 n, Object o) { unimplementedVisitor("visit(OverloadableOperator11, Object)"); }

        public void visit(OverloadableOperator12 n) { unimplementedVisitor("visit(OverloadableOperator12)"); }
        public void visit(OverloadableOperator12 n, Object o) { unimplementedVisitor("visit(OverloadableOperator12, Object)"); }

        public void visit(OverloadableOperator13 n) { unimplementedVisitor("visit(OverloadableOperator13)"); }
        public void visit(OverloadableOperator13 n, Object o) { unimplementedVisitor("visit(OverloadableOperator13, Object)"); }

        public void visit(OverloadableOperator14 n) { unimplementedVisitor("visit(OverloadableOperator14)"); }
        public void visit(OverloadableOperator14 n, Object o) { unimplementedVisitor("visit(OverloadableOperator14, Object)"); }

        public void visit(OverloadableOperator15 n) { unimplementedVisitor("visit(OverloadableOperator15)"); }
        public void visit(OverloadableOperator15 n, Object o) { unimplementedVisitor("visit(OverloadableOperator15, Object)"); }

        public void visit(OverloadableOperator16 n) { unimplementedVisitor("visit(OverloadableOperator16)"); }
        public void visit(OverloadableOperator16 n, Object o) { unimplementedVisitor("visit(OverloadableOperator16, Object)"); }

        public void visit(OverloadableOperator17 n) { unimplementedVisitor("visit(OverloadableOperator17)"); }
        public void visit(OverloadableOperator17 n, Object o) { unimplementedVisitor("visit(OverloadableOperator17, Object)"); }

        public void visit(OverloadableOperator18 n) { unimplementedVisitor("visit(OverloadableOperator18)"); }
        public void visit(OverloadableOperator18 n, Object o) { unimplementedVisitor("visit(OverloadableOperator18, Object)"); }

        public void visit(OverloadableOperator19 n) { unimplementedVisitor("visit(OverloadableOperator19)"); }
        public void visit(OverloadableOperator19 n, Object o) { unimplementedVisitor("visit(OverloadableOperator19, Object)"); }

        public void visit(OverloadableOperator20 n) { unimplementedVisitor("visit(OverloadableOperator20)"); }
        public void visit(OverloadableOperator20 n, Object o) { unimplementedVisitor("visit(OverloadableOperator20, Object)"); }

        public void visit(OverloadableOperator21 n) { unimplementedVisitor("visit(OverloadableOperator21)"); }
        public void visit(OverloadableOperator21 n, Object o) { unimplementedVisitor("visit(OverloadableOperator21, Object)"); }

        public void visit(ConversionOperatorDeclarator0 n) { unimplementedVisitor("visit(ConversionOperatorDeclarator0)"); }
        public void visit(ConversionOperatorDeclarator0 n, Object o) { unimplementedVisitor("visit(ConversionOperatorDeclarator0, Object)"); }

        public void visit(ConversionOperatorDeclarator1 n) { unimplementedVisitor("visit(ConversionOperatorDeclarator1)"); }
        public void visit(ConversionOperatorDeclarator1 n, Object o) { unimplementedVisitor("visit(ConversionOperatorDeclarator1, Object)"); }

        public void visit(ConstructorInitializer0 n) { unimplementedVisitor("visit(ConstructorInitializer0)"); }
        public void visit(ConstructorInitializer0 n, Object o) { unimplementedVisitor("visit(ConstructorInitializer0, Object)"); }

        public void visit(ConstructorInitializer1 n) { unimplementedVisitor("visit(ConstructorInitializer1)"); }
        public void visit(ConstructorInitializer1 n, Object o) { unimplementedVisitor("visit(ConstructorInitializer1, Object)"); }

        public void visit(DimSeparators0 n) { unimplementedVisitor("visit(DimSeparators0)"); }
        public void visit(DimSeparators0 n, Object o) { unimplementedVisitor("visit(DimSeparators0, Object)"); }

        public void visit(DimSeparators1 n) { unimplementedVisitor("visit(DimSeparators1)"); }
        public void visit(DimSeparators1 n, Object o) { unimplementedVisitor("visit(DimSeparators1, Object)"); }

        public void visit(ArrayInitializer0 n) { unimplementedVisitor("visit(ArrayInitializer0)"); }
        public void visit(ArrayInitializer0 n, Object o) { unimplementedVisitor("visit(ArrayInitializer0, Object)"); }

        public void visit(ArrayInitializer1 n) { unimplementedVisitor("visit(ArrayInitializer1)"); }
        public void visit(ArrayInitializer1 n, Object o) { unimplementedVisitor("visit(ArrayInitializer1, Object)"); }

        public void visit(InterfaceAccessors0 n) { unimplementedVisitor("visit(InterfaceAccessors0)"); }
        public void visit(InterfaceAccessors0 n, Object o) { unimplementedVisitor("visit(InterfaceAccessors0, Object)"); }

        public void visit(InterfaceAccessors1 n) { unimplementedVisitor("visit(InterfaceAccessors1)"); }
        public void visit(InterfaceAccessors1 n, Object o) { unimplementedVisitor("visit(InterfaceAccessors1, Object)"); }

        public void visit(InterfaceAccessors2 n) { unimplementedVisitor("visit(InterfaceAccessors2)"); }
        public void visit(InterfaceAccessors2 n, Object o) { unimplementedVisitor("visit(InterfaceAccessors2, Object)"); }

        public void visit(InterfaceAccessors3 n) { unimplementedVisitor("visit(InterfaceAccessors3)"); }
        public void visit(InterfaceAccessors3 n, Object o) { unimplementedVisitor("visit(InterfaceAccessors3, Object)"); }

        public void visit(EnumBody0 n) { unimplementedVisitor("visit(EnumBody0)"); }
        public void visit(EnumBody0 n, Object o) { unimplementedVisitor("visit(EnumBody0, Object)"); }

        public void visit(EnumBody1 n) { unimplementedVisitor("visit(EnumBody1)"); }
        public void visit(EnumBody1 n, Object o) { unimplementedVisitor("visit(EnumBody1, Object)"); }

        public void visit(EnumMemberDeclaration0 n) { unimplementedVisitor("visit(EnumMemberDeclaration0)"); }
        public void visit(EnumMemberDeclaration0 n, Object o) { unimplementedVisitor("visit(EnumMemberDeclaration0, Object)"); }

        public void visit(EnumMemberDeclaration1 n) { unimplementedVisitor("visit(EnumMemberDeclaration1)"); }
        public void visit(EnumMemberDeclaration1 n, Object o) { unimplementedVisitor("visit(EnumMemberDeclaration1, Object)"); }

        public void visit(AttributeSection0 n) { unimplementedVisitor("visit(AttributeSection0)"); }
        public void visit(AttributeSection0 n, Object o) { unimplementedVisitor("visit(AttributeSection0, Object)"); }

        public void visit(AttributeSection1 n) { unimplementedVisitor("visit(AttributeSection1)"); }
        public void visit(AttributeSection1 n, Object o) { unimplementedVisitor("visit(AttributeSection1, Object)"); }

        public void visit(Keyword0 n) { unimplementedVisitor("visit(Keyword0)"); }
        public void visit(Keyword0 n, Object o) { unimplementedVisitor("visit(Keyword0, Object)"); }

        public void visit(Keyword1 n) { unimplementedVisitor("visit(Keyword1)"); }
        public void visit(Keyword1 n, Object o) { unimplementedVisitor("visit(Keyword1, Object)"); }

        public void visit(Keyword2 n) { unimplementedVisitor("visit(Keyword2)"); }
        public void visit(Keyword2 n, Object o) { unimplementedVisitor("visit(Keyword2, Object)"); }

        public void visit(Keyword3 n) { unimplementedVisitor("visit(Keyword3)"); }
        public void visit(Keyword3 n, Object o) { unimplementedVisitor("visit(Keyword3, Object)"); }

        public void visit(Keyword4 n) { unimplementedVisitor("visit(Keyword4)"); }
        public void visit(Keyword4 n, Object o) { unimplementedVisitor("visit(Keyword4, Object)"); }

        public void visit(Keyword5 n) { unimplementedVisitor("visit(Keyword5)"); }
        public void visit(Keyword5 n, Object o) { unimplementedVisitor("visit(Keyword5, Object)"); }

        public void visit(Keyword6 n) { unimplementedVisitor("visit(Keyword6)"); }
        public void visit(Keyword6 n, Object o) { unimplementedVisitor("visit(Keyword6, Object)"); }

        public void visit(Keyword7 n) { unimplementedVisitor("visit(Keyword7)"); }
        public void visit(Keyword7 n, Object o) { unimplementedVisitor("visit(Keyword7, Object)"); }

        public void visit(Keyword8 n) { unimplementedVisitor("visit(Keyword8)"); }
        public void visit(Keyword8 n, Object o) { unimplementedVisitor("visit(Keyword8, Object)"); }

        public void visit(Keyword9 n) { unimplementedVisitor("visit(Keyword9)"); }
        public void visit(Keyword9 n, Object o) { unimplementedVisitor("visit(Keyword9, Object)"); }

        public void visit(Keyword10 n) { unimplementedVisitor("visit(Keyword10)"); }
        public void visit(Keyword10 n, Object o) { unimplementedVisitor("visit(Keyword10, Object)"); }

        public void visit(Keyword11 n) { unimplementedVisitor("visit(Keyword11)"); }
        public void visit(Keyword11 n, Object o) { unimplementedVisitor("visit(Keyword11, Object)"); }

        public void visit(Keyword12 n) { unimplementedVisitor("visit(Keyword12)"); }
        public void visit(Keyword12 n, Object o) { unimplementedVisitor("visit(Keyword12, Object)"); }

        public void visit(Keyword13 n) { unimplementedVisitor("visit(Keyword13)"); }
        public void visit(Keyword13 n, Object o) { unimplementedVisitor("visit(Keyword13, Object)"); }

        public void visit(Keyword14 n) { unimplementedVisitor("visit(Keyword14)"); }
        public void visit(Keyword14 n, Object o) { unimplementedVisitor("visit(Keyword14, Object)"); }

        public void visit(Keyword15 n) { unimplementedVisitor("visit(Keyword15)"); }
        public void visit(Keyword15 n, Object o) { unimplementedVisitor("visit(Keyword15, Object)"); }

        public void visit(Keyword16 n) { unimplementedVisitor("visit(Keyword16)"); }
        public void visit(Keyword16 n, Object o) { unimplementedVisitor("visit(Keyword16, Object)"); }

        public void visit(Keyword17 n) { unimplementedVisitor("visit(Keyword17)"); }
        public void visit(Keyword17 n, Object o) { unimplementedVisitor("visit(Keyword17, Object)"); }

        public void visit(Keyword18 n) { unimplementedVisitor("visit(Keyword18)"); }
        public void visit(Keyword18 n, Object o) { unimplementedVisitor("visit(Keyword18, Object)"); }

        public void visit(Keyword19 n) { unimplementedVisitor("visit(Keyword19)"); }
        public void visit(Keyword19 n, Object o) { unimplementedVisitor("visit(Keyword19, Object)"); }

        public void visit(Keyword20 n) { unimplementedVisitor("visit(Keyword20)"); }
        public void visit(Keyword20 n, Object o) { unimplementedVisitor("visit(Keyword20, Object)"); }

        public void visit(Keyword21 n) { unimplementedVisitor("visit(Keyword21)"); }
        public void visit(Keyword21 n, Object o) { unimplementedVisitor("visit(Keyword21, Object)"); }

        public void visit(Keyword22 n) { unimplementedVisitor("visit(Keyword22)"); }
        public void visit(Keyword22 n, Object o) { unimplementedVisitor("visit(Keyword22, Object)"); }

        public void visit(Keyword23 n) { unimplementedVisitor("visit(Keyword23)"); }
        public void visit(Keyword23 n, Object o) { unimplementedVisitor("visit(Keyword23, Object)"); }

        public void visit(Keyword24 n) { unimplementedVisitor("visit(Keyword24)"); }
        public void visit(Keyword24 n, Object o) { unimplementedVisitor("visit(Keyword24, Object)"); }

        public void visit(Keyword25 n) { unimplementedVisitor("visit(Keyword25)"); }
        public void visit(Keyword25 n, Object o) { unimplementedVisitor("visit(Keyword25, Object)"); }

        public void visit(Keyword26 n) { unimplementedVisitor("visit(Keyword26)"); }
        public void visit(Keyword26 n, Object o) { unimplementedVisitor("visit(Keyword26, Object)"); }

        public void visit(Keyword27 n) { unimplementedVisitor("visit(Keyword27)"); }
        public void visit(Keyword27 n, Object o) { unimplementedVisitor("visit(Keyword27, Object)"); }

        public void visit(Keyword28 n) { unimplementedVisitor("visit(Keyword28)"); }
        public void visit(Keyword28 n, Object o) { unimplementedVisitor("visit(Keyword28, Object)"); }

        public void visit(Keyword29 n) { unimplementedVisitor("visit(Keyword29)"); }
        public void visit(Keyword29 n, Object o) { unimplementedVisitor("visit(Keyword29, Object)"); }

        public void visit(Keyword30 n) { unimplementedVisitor("visit(Keyword30)"); }
        public void visit(Keyword30 n, Object o) { unimplementedVisitor("visit(Keyword30, Object)"); }

        public void visit(Keyword31 n) { unimplementedVisitor("visit(Keyword31)"); }
        public void visit(Keyword31 n, Object o) { unimplementedVisitor("visit(Keyword31, Object)"); }

        public void visit(Keyword32 n) { unimplementedVisitor("visit(Keyword32)"); }
        public void visit(Keyword32 n, Object o) { unimplementedVisitor("visit(Keyword32, Object)"); }

        public void visit(Keyword33 n) { unimplementedVisitor("visit(Keyword33)"); }
        public void visit(Keyword33 n, Object o) { unimplementedVisitor("visit(Keyword33, Object)"); }

        public void visit(Keyword34 n) { unimplementedVisitor("visit(Keyword34)"); }
        public void visit(Keyword34 n, Object o) { unimplementedVisitor("visit(Keyword34, Object)"); }

        public void visit(Keyword35 n) { unimplementedVisitor("visit(Keyword35)"); }
        public void visit(Keyword35 n, Object o) { unimplementedVisitor("visit(Keyword35, Object)"); }

        public void visit(Keyword36 n) { unimplementedVisitor("visit(Keyword36)"); }
        public void visit(Keyword36 n, Object o) { unimplementedVisitor("visit(Keyword36, Object)"); }

        public void visit(Keyword37 n) { unimplementedVisitor("visit(Keyword37)"); }
        public void visit(Keyword37 n, Object o) { unimplementedVisitor("visit(Keyword37, Object)"); }

        public void visit(Keyword38 n) { unimplementedVisitor("visit(Keyword38)"); }
        public void visit(Keyword38 n, Object o) { unimplementedVisitor("visit(Keyword38, Object)"); }

        public void visit(Keyword39 n) { unimplementedVisitor("visit(Keyword39)"); }
        public void visit(Keyword39 n, Object o) { unimplementedVisitor("visit(Keyword39, Object)"); }

        public void visit(Keyword40 n) { unimplementedVisitor("visit(Keyword40)"); }
        public void visit(Keyword40 n, Object o) { unimplementedVisitor("visit(Keyword40, Object)"); }

        public void visit(Keyword41 n) { unimplementedVisitor("visit(Keyword41)"); }
        public void visit(Keyword41 n, Object o) { unimplementedVisitor("visit(Keyword41, Object)"); }

        public void visit(Keyword42 n) { unimplementedVisitor("visit(Keyword42)"); }
        public void visit(Keyword42 n, Object o) { unimplementedVisitor("visit(Keyword42, Object)"); }

        public void visit(Keyword43 n) { unimplementedVisitor("visit(Keyword43)"); }
        public void visit(Keyword43 n, Object o) { unimplementedVisitor("visit(Keyword43, Object)"); }

        public void visit(Keyword44 n) { unimplementedVisitor("visit(Keyword44)"); }
        public void visit(Keyword44 n, Object o) { unimplementedVisitor("visit(Keyword44, Object)"); }

        public void visit(Keyword45 n) { unimplementedVisitor("visit(Keyword45)"); }
        public void visit(Keyword45 n, Object o) { unimplementedVisitor("visit(Keyword45, Object)"); }

        public void visit(Keyword46 n) { unimplementedVisitor("visit(Keyword46)"); }
        public void visit(Keyword46 n, Object o) { unimplementedVisitor("visit(Keyword46, Object)"); }

        public void visit(Keyword47 n) { unimplementedVisitor("visit(Keyword47)"); }
        public void visit(Keyword47 n, Object o) { unimplementedVisitor("visit(Keyword47, Object)"); }

        public void visit(Keyword48 n) { unimplementedVisitor("visit(Keyword48)"); }
        public void visit(Keyword48 n, Object o) { unimplementedVisitor("visit(Keyword48, Object)"); }

        public void visit(Keyword49 n) { unimplementedVisitor("visit(Keyword49)"); }
        public void visit(Keyword49 n, Object o) { unimplementedVisitor("visit(Keyword49, Object)"); }

        public void visit(Keyword50 n) { unimplementedVisitor("visit(Keyword50)"); }
        public void visit(Keyword50 n, Object o) { unimplementedVisitor("visit(Keyword50, Object)"); }

        public void visit(Keyword51 n) { unimplementedVisitor("visit(Keyword51)"); }
        public void visit(Keyword51 n, Object o) { unimplementedVisitor("visit(Keyword51, Object)"); }

        public void visit(Keyword52 n) { unimplementedVisitor("visit(Keyword52)"); }
        public void visit(Keyword52 n, Object o) { unimplementedVisitor("visit(Keyword52, Object)"); }

        public void visit(Keyword53 n) { unimplementedVisitor("visit(Keyword53)"); }
        public void visit(Keyword53 n, Object o) { unimplementedVisitor("visit(Keyword53, Object)"); }

        public void visit(Keyword54 n) { unimplementedVisitor("visit(Keyword54)"); }
        public void visit(Keyword54 n, Object o) { unimplementedVisitor("visit(Keyword54, Object)"); }

        public void visit(Keyword55 n) { unimplementedVisitor("visit(Keyword55)"); }
        public void visit(Keyword55 n, Object o) { unimplementedVisitor("visit(Keyword55, Object)"); }

        public void visit(Keyword56 n) { unimplementedVisitor("visit(Keyword56)"); }
        public void visit(Keyword56 n, Object o) { unimplementedVisitor("visit(Keyword56, Object)"); }

        public void visit(Keyword57 n) { unimplementedVisitor("visit(Keyword57)"); }
        public void visit(Keyword57 n, Object o) { unimplementedVisitor("visit(Keyword57, Object)"); }

        public void visit(Keyword58 n) { unimplementedVisitor("visit(Keyword58)"); }
        public void visit(Keyword58 n, Object o) { unimplementedVisitor("visit(Keyword58, Object)"); }

        public void visit(Keyword59 n) { unimplementedVisitor("visit(Keyword59)"); }
        public void visit(Keyword59 n, Object o) { unimplementedVisitor("visit(Keyword59, Object)"); }

        public void visit(Keyword60 n) { unimplementedVisitor("visit(Keyword60)"); }
        public void visit(Keyword60 n, Object o) { unimplementedVisitor("visit(Keyword60, Object)"); }

        public void visit(Keyword61 n) { unimplementedVisitor("visit(Keyword61)"); }
        public void visit(Keyword61 n, Object o) { unimplementedVisitor("visit(Keyword61, Object)"); }

        public void visit(Keyword62 n) { unimplementedVisitor("visit(Keyword62)"); }
        public void visit(Keyword62 n, Object o) { unimplementedVisitor("visit(Keyword62, Object)"); }

        public void visit(Keyword63 n) { unimplementedVisitor("visit(Keyword63)"); }
        public void visit(Keyword63 n, Object o) { unimplementedVisitor("visit(Keyword63, Object)"); }

        public void visit(Keyword64 n) { unimplementedVisitor("visit(Keyword64)"); }
        public void visit(Keyword64 n, Object o) { unimplementedVisitor("visit(Keyword64, Object)"); }

        public void visit(Keyword65 n) { unimplementedVisitor("visit(Keyword65)"); }
        public void visit(Keyword65 n, Object o) { unimplementedVisitor("visit(Keyword65, Object)"); }

        public void visit(Keyword66 n) { unimplementedVisitor("visit(Keyword66)"); }
        public void visit(Keyword66 n, Object o) { unimplementedVisitor("visit(Keyword66, Object)"); }

        public void visit(Keyword67 n) { unimplementedVisitor("visit(Keyword67)"); }
        public void visit(Keyword67 n, Object o) { unimplementedVisitor("visit(Keyword67, Object)"); }

        public void visit(Keyword68 n) { unimplementedVisitor("visit(Keyword68)"); }
        public void visit(Keyword68 n, Object o) { unimplementedVisitor("visit(Keyword68, Object)"); }

        public void visit(Keyword69 n) { unimplementedVisitor("visit(Keyword69)"); }
        public void visit(Keyword69 n, Object o) { unimplementedVisitor("visit(Keyword69, Object)"); }

        public void visit(Keyword70 n) { unimplementedVisitor("visit(Keyword70)"); }
        public void visit(Keyword70 n, Object o) { unimplementedVisitor("visit(Keyword70, Object)"); }

        public void visit(Keyword71 n) { unimplementedVisitor("visit(Keyword71)"); }
        public void visit(Keyword71 n, Object o) { unimplementedVisitor("visit(Keyword71, Object)"); }

        public void visit(Keyword72 n) { unimplementedVisitor("visit(Keyword72)"); }
        public void visit(Keyword72 n, Object o) { unimplementedVisitor("visit(Keyword72, Object)"); }

        public void visit(Keyword73 n) { unimplementedVisitor("visit(Keyword73)"); }
        public void visit(Keyword73 n, Object o) { unimplementedVisitor("visit(Keyword73, Object)"); }

        public void visit(Keyword74 n) { unimplementedVisitor("visit(Keyword74)"); }
        public void visit(Keyword74 n, Object o) { unimplementedVisitor("visit(Keyword74, Object)"); }

        public void visit(Keyword75 n) { unimplementedVisitor("visit(Keyword75)"); }
        public void visit(Keyword75 n, Object o) { unimplementedVisitor("visit(Keyword75, Object)"); }

        public void visit(Keyword76 n) { unimplementedVisitor("visit(Keyword76)"); }
        public void visit(Keyword76 n, Object o) { unimplementedVisitor("visit(Keyword76, Object)"); }

        public void visit(Keyword77 n) { unimplementedVisitor("visit(Keyword77)"); }
        public void visit(Keyword77 n, Object o) { unimplementedVisitor("visit(Keyword77, Object)"); }

        public void visit(Keyword78 n) { unimplementedVisitor("visit(Keyword78)"); }
        public void visit(Keyword78 n, Object o) { unimplementedVisitor("visit(Keyword78, Object)"); }

        public void visit(Keyword79 n) { unimplementedVisitor("visit(Keyword79)"); }
        public void visit(Keyword79 n, Object o) { unimplementedVisitor("visit(Keyword79, Object)"); }

        public void visit(Keyword80 n) { unimplementedVisitor("visit(Keyword80)"); }
        public void visit(Keyword80 n, Object o) { unimplementedVisitor("visit(Keyword80, Object)"); }

        public void visit(Keyword81 n) { unimplementedVisitor("visit(Keyword81)"); }
        public void visit(Keyword81 n, Object o) { unimplementedVisitor("visit(Keyword81, Object)"); }

        public void visit(Keyword82 n) { unimplementedVisitor("visit(Keyword82)"); }
        public void visit(Keyword82 n, Object o) { unimplementedVisitor("visit(Keyword82, Object)"); }

        public void visit(Keyword83 n) { unimplementedVisitor("visit(Keyword83)"); }
        public void visit(Keyword83 n, Object o) { unimplementedVisitor("visit(Keyword83, Object)"); }

        public void visit(Keyword84 n) { unimplementedVisitor("visit(Keyword84)"); }
        public void visit(Keyword84 n, Object o) { unimplementedVisitor("visit(Keyword84, Object)"); }

        public void visit(AttributeArguments0 n) { unimplementedVisitor("visit(AttributeArguments0)"); }
        public void visit(AttributeArguments0 n, Object o) { unimplementedVisitor("visit(AttributeArguments0, Object)"); }

        public void visit(AttributeArguments1 n) { unimplementedVisitor("visit(AttributeArguments1)"); }
        public void visit(AttributeArguments1 n, Object o) { unimplementedVisitor("visit(AttributeArguments1, Object)"); }

        public void visit(AttributeArguments2 n) { unimplementedVisitor("visit(AttributeArguments2)"); }
        public void visit(AttributeArguments2 n, Object o) { unimplementedVisitor("visit(AttributeArguments2, Object)"); }

        public void visit(TypeParameters0 n) { unimplementedVisitor("visit(TypeParameters0)"); }
        public void visit(TypeParameters0 n, Object o) { unimplementedVisitor("visit(TypeParameters0, Object)"); }

        public void visit(TypeParameters1 n) { unimplementedVisitor("visit(TypeParameters1)"); }
        public void visit(TypeParameters1 n, Object o) { unimplementedVisitor("visit(TypeParameters1, Object)"); }

        public void visit(Constraint0 n) { unimplementedVisitor("visit(Constraint0)"); }
        public void visit(Constraint0 n, Object o) { unimplementedVisitor("visit(Constraint0, Object)"); }

        public void visit(Constraint1 n) { unimplementedVisitor("visit(Constraint1)"); }
        public void visit(Constraint1 n, Object o) { unimplementedVisitor("visit(Constraint1, Object)"); }
    }
    static public abstract class AbstractResultVisitor implements ResultVisitor, ResultArgumentVisitor
    {
        public abstract Object unimplementedVisitor(String s);

        public Object visit(AstToken n) { return unimplementedVisitor("visit(AstToken)"); }
        public Object visit(AstToken n, Object o) { return  unimplementedVisitor("visit(AstToken, Object)"); }

        public Object visit(SemiOpt n) { return unimplementedVisitor("visit(SemiOpt)"); }
        public Object visit(SemiOpt n, Object o) { return  unimplementedVisitor("visit(SemiOpt, Object)"); }

        public Object visit(ExternOpt n) { return unimplementedVisitor("visit(ExternOpt)"); }
        public Object visit(ExternOpt n, Object o) { return  unimplementedVisitor("visit(ExternOpt, Object)"); }

        public Object visit(NewOpt n) { return unimplementedVisitor("visit(NewOpt)"); }
        public Object visit(NewOpt n, Object o) { return  unimplementedVisitor("visit(NewOpt, Object)"); }

        public Object visit(PartialOpt n) { return unimplementedVisitor("visit(PartialOpt)"); }
        public Object visit(PartialOpt n, Object o) { return  unimplementedVisitor("visit(PartialOpt, Object)"); }

        public Object visit(IdentifierOpt n) { return unimplementedVisitor("visit(IdentifierOpt)"); }
        public Object visit(IdentifierOpt n, Object o) { return  unimplementedVisitor("visit(IdentifierOpt, Object)"); }

        public Object visit(CompilationUnit n) { return unimplementedVisitor("visit(CompilationUnit)"); }
        public Object visit(CompilationUnit n, Object o) { return  unimplementedVisitor("visit(CompilationUnit, Object)"); }

        public Object visit(Type n) { return unimplementedVisitor("visit(Type)"); }
        public Object visit(Type n, Object o) { return  unimplementedVisitor("visit(Type, Object)"); }

        public Object visit(SimpleType n) { return unimplementedVisitor("visit(SimpleType)"); }
        public Object visit(SimpleType n, Object o) { return  unimplementedVisitor("visit(SimpleType, Object)"); }

        public Object visit(NumericType n) { return unimplementedVisitor("visit(NumericType)"); }
        public Object visit(NumericType n, Object o) { return  unimplementedVisitor("visit(NumericType, Object)"); }

        public Object visit(NullableType n) { return unimplementedVisitor("visit(NullableType)"); }
        public Object visit(NullableType n, Object o) { return  unimplementedVisitor("visit(NullableType, Object)"); }

        public Object visit(ArgumentList n) { return unimplementedVisitor("visit(ArgumentList)"); }
        public Object visit(ArgumentList n, Object o) { return  unimplementedVisitor("visit(ArgumentList, Object)"); }

        public Object visit(ParenthesizedExpression n) { return unimplementedVisitor("visit(ParenthesizedExpression)"); }
        public Object visit(ParenthesizedExpression n, Object o) { return  unimplementedVisitor("visit(ParenthesizedExpression, Object)"); }

        public Object visit(InvocationExpression n) { return unimplementedVisitor("visit(InvocationExpression)"); }
        public Object visit(InvocationExpression n, Object o) { return  unimplementedVisitor("visit(InvocationExpression, Object)"); }

        public Object visit(ElementAccess n) { return unimplementedVisitor("visit(ElementAccess)"); }
        public Object visit(ElementAccess n, Object o) { return  unimplementedVisitor("visit(ElementAccess, Object)"); }

        public Object visit(ExpressionList n) { return unimplementedVisitor("visit(ExpressionList)"); }
        public Object visit(ExpressionList n, Object o) { return  unimplementedVisitor("visit(ExpressionList, Object)"); }

        public Object visit(ThisAccess n) { return unimplementedVisitor("visit(ThisAccess)"); }
        public Object visit(ThisAccess n, Object o) { return  unimplementedVisitor("visit(ThisAccess, Object)"); }

        public Object visit(PostIncrementExpression n) { return unimplementedVisitor("visit(PostIncrementExpression)"); }
        public Object visit(PostIncrementExpression n, Object o) { return  unimplementedVisitor("visit(PostIncrementExpression, Object)"); }

        public Object visit(PostDecrementExpression n) { return unimplementedVisitor("visit(PostDecrementExpression)"); }
        public Object visit(PostDecrementExpression n, Object o) { return  unimplementedVisitor("visit(PostDecrementExpression, Object)"); }

        public Object visit(ObjectCreationExpression n) { return unimplementedVisitor("visit(ObjectCreationExpression)"); }
        public Object visit(ObjectCreationExpression n, Object o) { return  unimplementedVisitor("visit(ObjectCreationExpression, Object)"); }

        public Object visit(GenericDimensionSpecifier n) { return unimplementedVisitor("visit(GenericDimensionSpecifier)"); }
        public Object visit(GenericDimensionSpecifier n, Object o) { return  unimplementedVisitor("visit(GenericDimensionSpecifier, Object)"); }

        public Object visit(CheckedExpression n) { return unimplementedVisitor("visit(CheckedExpression)"); }
        public Object visit(CheckedExpression n, Object o) { return  unimplementedVisitor("visit(CheckedExpression, Object)"); }

        public Object visit(UncheckedExpression n) { return unimplementedVisitor("visit(UncheckedExpression)"); }
        public Object visit(UncheckedExpression n, Object o) { return  unimplementedVisitor("visit(UncheckedExpression, Object)"); }

        public Object visit(DefaultValueExpression n) { return unimplementedVisitor("visit(DefaultValueExpression)"); }
        public Object visit(DefaultValueExpression n, Object o) { return  unimplementedVisitor("visit(DefaultValueExpression, Object)"); }

        public Object visit(AnonymousMethodExpression n) { return unimplementedVisitor("visit(AnonymousMethodExpression)"); }
        public Object visit(AnonymousMethodExpression n, Object o) { return  unimplementedVisitor("visit(AnonymousMethodExpression, Object)"); }

        public Object visit(AnonymousMethodSignature n) { return unimplementedVisitor("visit(AnonymousMethodSignature)"); }
        public Object visit(AnonymousMethodSignature n, Object o) { return  unimplementedVisitor("visit(AnonymousMethodSignature, Object)"); }

        public Object visit(AnonymousMethodParameterList n) { return unimplementedVisitor("visit(AnonymousMethodParameterList)"); }
        public Object visit(AnonymousMethodParameterList n, Object o) { return  unimplementedVisitor("visit(AnonymousMethodParameterList, Object)"); }

        public Object visit(AnonymousMethodParameter n) { return unimplementedVisitor("visit(AnonymousMethodParameter)"); }
        public Object visit(AnonymousMethodParameter n, Object o) { return  unimplementedVisitor("visit(AnonymousMethodParameter, Object)"); }

        public Object visit(PreIncrementExpression n) { return unimplementedVisitor("visit(PreIncrementExpression)"); }
        public Object visit(PreIncrementExpression n, Object o) { return  unimplementedVisitor("visit(PreIncrementExpression, Object)"); }

        public Object visit(PreDecrementExpression n) { return unimplementedVisitor("visit(PreDecrementExpression)"); }
        public Object visit(PreDecrementExpression n, Object o) { return  unimplementedVisitor("visit(PreDecrementExpression, Object)"); }

        public Object visit(CastExpression n) { return unimplementedVisitor("visit(CastExpression)"); }
        public Object visit(CastExpression n, Object o) { return  unimplementedVisitor("visit(CastExpression, Object)"); }

        public Object visit(AndExpression n) { return unimplementedVisitor("visit(AndExpression)"); }
        public Object visit(AndExpression n, Object o) { return  unimplementedVisitor("visit(AndExpression, Object)"); }

        public Object visit(ExclusiveOrExpression n) { return unimplementedVisitor("visit(ExclusiveOrExpression)"); }
        public Object visit(ExclusiveOrExpression n, Object o) { return  unimplementedVisitor("visit(ExclusiveOrExpression, Object)"); }

        public Object visit(InclusiveOrExpression n) { return unimplementedVisitor("visit(InclusiveOrExpression)"); }
        public Object visit(InclusiveOrExpression n, Object o) { return  unimplementedVisitor("visit(InclusiveOrExpression, Object)"); }

        public Object visit(ConditionalAndExpression n) { return unimplementedVisitor("visit(ConditionalAndExpression)"); }
        public Object visit(ConditionalAndExpression n, Object o) { return  unimplementedVisitor("visit(ConditionalAndExpression, Object)"); }

        public Object visit(ConditionalOrExpression n) { return unimplementedVisitor("visit(ConditionalOrExpression)"); }
        public Object visit(ConditionalOrExpression n, Object o) { return  unimplementedVisitor("visit(ConditionalOrExpression, Object)"); }

        public Object visit(NullCoalescingExpression n) { return unimplementedVisitor("visit(NullCoalescingExpression)"); }
        public Object visit(NullCoalescingExpression n, Object o) { return  unimplementedVisitor("visit(NullCoalescingExpression, Object)"); }

        public Object visit(ConditionalExpression n) { return unimplementedVisitor("visit(ConditionalExpression)"); }
        public Object visit(ConditionalExpression n, Object o) { return  unimplementedVisitor("visit(ConditionalExpression, Object)"); }

        public Object visit(Assignment n) { return unimplementedVisitor("visit(Assignment)"); }
        public Object visit(Assignment n, Object o) { return  unimplementedVisitor("visit(Assignment, Object)"); }

        public Object visit(Block n) { return unimplementedVisitor("visit(Block)"); }
        public Object visit(Block n, Object o) { return  unimplementedVisitor("visit(Block, Object)"); }

        public Object visit(StatementList n) { return unimplementedVisitor("visit(StatementList)"); }
        public Object visit(StatementList n, Object o) { return  unimplementedVisitor("visit(StatementList, Object)"); }

        public Object visit(EmptyStatement n) { return unimplementedVisitor("visit(EmptyStatement)"); }
        public Object visit(EmptyStatement n, Object o) { return  unimplementedVisitor("visit(EmptyStatement, Object)"); }

        public Object visit(LabeledStatement n) { return unimplementedVisitor("visit(LabeledStatement)"); }
        public Object visit(LabeledStatement n, Object o) { return  unimplementedVisitor("visit(LabeledStatement, Object)"); }

        public Object visit(LocalVariableDeclaration n) { return unimplementedVisitor("visit(LocalVariableDeclaration)"); }
        public Object visit(LocalVariableDeclaration n, Object o) { return  unimplementedVisitor("visit(LocalVariableDeclaration, Object)"); }

        public Object visit(LocalVariableDeclarators n) { return unimplementedVisitor("visit(LocalVariableDeclarators)"); }
        public Object visit(LocalVariableDeclarators n, Object o) { return  unimplementedVisitor("visit(LocalVariableDeclarators, Object)"); }

        public Object visit(LocalConstantDeclaration n) { return unimplementedVisitor("visit(LocalConstantDeclaration)"); }
        public Object visit(LocalConstantDeclaration n, Object o) { return  unimplementedVisitor("visit(LocalConstantDeclaration, Object)"); }

        public Object visit(ExpressionStatement n) { return unimplementedVisitor("visit(ExpressionStatement)"); }
        public Object visit(ExpressionStatement n, Object o) { return  unimplementedVisitor("visit(ExpressionStatement, Object)"); }

        public Object visit(IfStatement n) { return unimplementedVisitor("visit(IfStatement)"); }
        public Object visit(IfStatement n, Object o) { return  unimplementedVisitor("visit(IfStatement, Object)"); }

        public Object visit(ElseStatement n) { return unimplementedVisitor("visit(ElseStatement)"); }
        public Object visit(ElseStatement n, Object o) { return  unimplementedVisitor("visit(ElseStatement, Object)"); }

        public Object visit(SwitchStatement n) { return unimplementedVisitor("visit(SwitchStatement)"); }
        public Object visit(SwitchStatement n, Object o) { return  unimplementedVisitor("visit(SwitchStatement, Object)"); }

        public Object visit(SwitchBlock n) { return unimplementedVisitor("visit(SwitchBlock)"); }
        public Object visit(SwitchBlock n, Object o) { return  unimplementedVisitor("visit(SwitchBlock, Object)"); }

        public Object visit(SwitchSections n) { return unimplementedVisitor("visit(SwitchSections)"); }
        public Object visit(SwitchSections n, Object o) { return  unimplementedVisitor("visit(SwitchSections, Object)"); }

        public Object visit(SwitchSection n) { return unimplementedVisitor("visit(SwitchSection)"); }
        public Object visit(SwitchSection n, Object o) { return  unimplementedVisitor("visit(SwitchSection, Object)"); }

        public Object visit(SwitchLabels n) { return unimplementedVisitor("visit(SwitchLabels)"); }
        public Object visit(SwitchLabels n, Object o) { return  unimplementedVisitor("visit(SwitchLabels, Object)"); }

        public Object visit(WhileStatement n) { return unimplementedVisitor("visit(WhileStatement)"); }
        public Object visit(WhileStatement n, Object o) { return  unimplementedVisitor("visit(WhileStatement, Object)"); }

        public Object visit(DoStatement n) { return unimplementedVisitor("visit(DoStatement)"); }
        public Object visit(DoStatement n, Object o) { return  unimplementedVisitor("visit(DoStatement, Object)"); }

        public Object visit(ForStatement n) { return unimplementedVisitor("visit(ForStatement)"); }
        public Object visit(ForStatement n, Object o) { return  unimplementedVisitor("visit(ForStatement, Object)"); }

        public Object visit(StatementExpressionList n) { return unimplementedVisitor("visit(StatementExpressionList)"); }
        public Object visit(StatementExpressionList n, Object o) { return  unimplementedVisitor("visit(StatementExpressionList, Object)"); }

        public Object visit(ForeachStatement n) { return unimplementedVisitor("visit(ForeachStatement)"); }
        public Object visit(ForeachStatement n, Object o) { return  unimplementedVisitor("visit(ForeachStatement, Object)"); }

        public Object visit(BreakStatement n) { return unimplementedVisitor("visit(BreakStatement)"); }
        public Object visit(BreakStatement n, Object o) { return  unimplementedVisitor("visit(BreakStatement, Object)"); }

        public Object visit(ContinueStatement n) { return unimplementedVisitor("visit(ContinueStatement)"); }
        public Object visit(ContinueStatement n, Object o) { return  unimplementedVisitor("visit(ContinueStatement, Object)"); }

        public Object visit(ReturnStatement n) { return unimplementedVisitor("visit(ReturnStatement)"); }
        public Object visit(ReturnStatement n, Object o) { return  unimplementedVisitor("visit(ReturnStatement, Object)"); }

        public Object visit(ThrowStatement n) { return unimplementedVisitor("visit(ThrowStatement)"); }
        public Object visit(ThrowStatement n, Object o) { return  unimplementedVisitor("visit(ThrowStatement, Object)"); }

        public Object visit(CatchClauses n) { return unimplementedVisitor("visit(CatchClauses)"); }
        public Object visit(CatchClauses n, Object o) { return  unimplementedVisitor("visit(CatchClauses, Object)"); }

        public Object visit(SpecificCatchClauses n) { return unimplementedVisitor("visit(SpecificCatchClauses)"); }
        public Object visit(SpecificCatchClauses n, Object o) { return  unimplementedVisitor("visit(SpecificCatchClauses, Object)"); }

        public Object visit(SpecificCatchClause n) { return unimplementedVisitor("visit(SpecificCatchClause)"); }
        public Object visit(SpecificCatchClause n, Object o) { return  unimplementedVisitor("visit(SpecificCatchClause, Object)"); }

        public Object visit(GeneralCatchClause n) { return unimplementedVisitor("visit(GeneralCatchClause)"); }
        public Object visit(GeneralCatchClause n, Object o) { return  unimplementedVisitor("visit(GeneralCatchClause, Object)"); }

        public Object visit(FinallyClause n) { return unimplementedVisitor("visit(FinallyClause)"); }
        public Object visit(FinallyClause n, Object o) { return  unimplementedVisitor("visit(FinallyClause, Object)"); }

        public Object visit(CheckedStatement n) { return unimplementedVisitor("visit(CheckedStatement)"); }
        public Object visit(CheckedStatement n, Object o) { return  unimplementedVisitor("visit(CheckedStatement, Object)"); }

        public Object visit(UncheckedStatement n) { return unimplementedVisitor("visit(UncheckedStatement)"); }
        public Object visit(UncheckedStatement n, Object o) { return  unimplementedVisitor("visit(UncheckedStatement, Object)"); }

        public Object visit(LockStatement n) { return unimplementedVisitor("visit(LockStatement)"); }
        public Object visit(LockStatement n, Object o) { return  unimplementedVisitor("visit(LockStatement, Object)"); }

        public Object visit(UsingStatement n) { return unimplementedVisitor("visit(UsingStatement)"); }
        public Object visit(UsingStatement n, Object o) { return  unimplementedVisitor("visit(UsingStatement, Object)"); }

        public Object visit(NamespaceDeclaration n) { return unimplementedVisitor("visit(NamespaceDeclaration)"); }
        public Object visit(NamespaceDeclaration n, Object o) { return  unimplementedVisitor("visit(NamespaceDeclaration, Object)"); }

        public Object visit(NamespaceBody n) { return unimplementedVisitor("visit(NamespaceBody)"); }
        public Object visit(NamespaceBody n, Object o) { return  unimplementedVisitor("visit(NamespaceBody, Object)"); }

        public Object visit(ExternAliasDirectives n) { return unimplementedVisitor("visit(ExternAliasDirectives)"); }
        public Object visit(ExternAliasDirectives n, Object o) { return  unimplementedVisitor("visit(ExternAliasDirectives, Object)"); }

        public Object visit(ExternAliasDirective n) { return unimplementedVisitor("visit(ExternAliasDirective)"); }
        public Object visit(ExternAliasDirective n, Object o) { return  unimplementedVisitor("visit(ExternAliasDirective, Object)"); }

        public Object visit(UsingDirectives n) { return unimplementedVisitor("visit(UsingDirectives)"); }
        public Object visit(UsingDirectives n, Object o) { return  unimplementedVisitor("visit(UsingDirectives, Object)"); }

        public Object visit(UsingAliasDirective n) { return unimplementedVisitor("visit(UsingAliasDirective)"); }
        public Object visit(UsingAliasDirective n, Object o) { return  unimplementedVisitor("visit(UsingAliasDirective, Object)"); }

        public Object visit(UsingNamespaceDirective n) { return unimplementedVisitor("visit(UsingNamespaceDirective)"); }
        public Object visit(UsingNamespaceDirective n, Object o) { return  unimplementedVisitor("visit(UsingNamespaceDirective, Object)"); }

        public Object visit(NamespaceMemberDeclarations n) { return unimplementedVisitor("visit(NamespaceMemberDeclarations)"); }
        public Object visit(NamespaceMemberDeclarations n, Object o) { return  unimplementedVisitor("visit(NamespaceMemberDeclarations, Object)"); }

        public Object visit(Modifiers n) { return unimplementedVisitor("visit(Modifiers)"); }
        public Object visit(Modifiers n, Object o) { return  unimplementedVisitor("visit(Modifiers, Object)"); }

        public Object visit(ClassDeclaration n) { return unimplementedVisitor("visit(ClassDeclaration)"); }
        public Object visit(ClassDeclaration n, Object o) { return  unimplementedVisitor("visit(ClassDeclaration, Object)"); }

        public Object visit(ClassBaseOpt n) { return unimplementedVisitor("visit(ClassBaseOpt)"); }
        public Object visit(ClassBaseOpt n, Object o) { return  unimplementedVisitor("visit(ClassBaseOpt, Object)"); }

        public Object visit(ClassBase n) { return unimplementedVisitor("visit(ClassBase)"); }
        public Object visit(ClassBase n, Object o) { return  unimplementedVisitor("visit(ClassBase, Object)"); }

        public Object visit(ClassBody n) { return unimplementedVisitor("visit(ClassBody)"); }
        public Object visit(ClassBody n, Object o) { return  unimplementedVisitor("visit(ClassBody, Object)"); }

        public Object visit(ClassMemberDeclarations n) { return unimplementedVisitor("visit(ClassMemberDeclarations)"); }
        public Object visit(ClassMemberDeclarations n, Object o) { return  unimplementedVisitor("visit(ClassMemberDeclarations, Object)"); }

        public Object visit(ConstantDeclaration n) { return unimplementedVisitor("visit(ConstantDeclaration)"); }
        public Object visit(ConstantDeclaration n, Object o) { return  unimplementedVisitor("visit(ConstantDeclaration, Object)"); }

        public Object visit(ConstantDeclarators n) { return unimplementedVisitor("visit(ConstantDeclarators)"); }
        public Object visit(ConstantDeclarators n, Object o) { return  unimplementedVisitor("visit(ConstantDeclarators, Object)"); }

        public Object visit(ConstantDeclarator n) { return unimplementedVisitor("visit(ConstantDeclarator)"); }
        public Object visit(ConstantDeclarator n, Object o) { return  unimplementedVisitor("visit(ConstantDeclarator, Object)"); }

        public Object visit(FieldDeclaration n) { return unimplementedVisitor("visit(FieldDeclaration)"); }
        public Object visit(FieldDeclaration n, Object o) { return  unimplementedVisitor("visit(FieldDeclaration, Object)"); }

        public Object visit(VariableDeclarators n) { return unimplementedVisitor("visit(VariableDeclarators)"); }
        public Object visit(VariableDeclarators n, Object o) { return  unimplementedVisitor("visit(VariableDeclarators, Object)"); }

        public Object visit(MethodDeclaration n) { return unimplementedVisitor("visit(MethodDeclaration)"); }
        public Object visit(MethodDeclaration n, Object o) { return  unimplementedVisitor("visit(MethodDeclaration, Object)"); }

        public Object visit(MethodHeader n) { return unimplementedVisitor("visit(MethodHeader)"); }
        public Object visit(MethodHeader n, Object o) { return  unimplementedVisitor("visit(MethodHeader, Object)"); }

        public Object visit(MethodBody n) { return unimplementedVisitor("visit(MethodBody)"); }
        public Object visit(MethodBody n, Object o) { return  unimplementedVisitor("visit(MethodBody, Object)"); }

        public Object visit(FormalParameterList n) { return unimplementedVisitor("visit(FormalParameterList)"); }
        public Object visit(FormalParameterList n, Object o) { return  unimplementedVisitor("visit(FormalParameterList, Object)"); }

        public Object visit(FixedParameters n) { return unimplementedVisitor("visit(FixedParameters)"); }
        public Object visit(FixedParameters n, Object o) { return  unimplementedVisitor("visit(FixedParameters, Object)"); }

        public Object visit(FixedParameter n) { return unimplementedVisitor("visit(FixedParameter)"); }
        public Object visit(FixedParameter n, Object o) { return  unimplementedVisitor("visit(FixedParameter, Object)"); }

        public Object visit(ParameterArray n) { return unimplementedVisitor("visit(ParameterArray)"); }
        public Object visit(ParameterArray n, Object o) { return  unimplementedVisitor("visit(ParameterArray, Object)"); }

        public Object visit(PropertyDeclaration n) { return unimplementedVisitor("visit(PropertyDeclaration)"); }
        public Object visit(PropertyDeclaration n, Object o) { return  unimplementedVisitor("visit(PropertyDeclaration, Object)"); }

        public Object visit(GetAccessorDeclaration n) { return unimplementedVisitor("visit(GetAccessorDeclaration)"); }
        public Object visit(GetAccessorDeclaration n, Object o) { return  unimplementedVisitor("visit(GetAccessorDeclaration, Object)"); }

        public Object visit(SetAccessorDeclaration n) { return unimplementedVisitor("visit(SetAccessorDeclaration)"); }
        public Object visit(SetAccessorDeclaration n, Object o) { return  unimplementedVisitor("visit(SetAccessorDeclaration, Object)"); }

        public Object visit(AccessorBody n) { return unimplementedVisitor("visit(AccessorBody)"); }
        public Object visit(AccessorBody n, Object o) { return  unimplementedVisitor("visit(AccessorBody, Object)"); }

        public Object visit(AddAccessorDeclaration n) { return unimplementedVisitor("visit(AddAccessorDeclaration)"); }
        public Object visit(AddAccessorDeclaration n, Object o) { return  unimplementedVisitor("visit(AddAccessorDeclaration, Object)"); }

        public Object visit(RemoveAccessorDeclaration n) { return unimplementedVisitor("visit(RemoveAccessorDeclaration)"); }
        public Object visit(RemoveAccessorDeclaration n, Object o) { return  unimplementedVisitor("visit(RemoveAccessorDeclaration, Object)"); }

        public Object visit(IndexerDeclaration n) { return unimplementedVisitor("visit(IndexerDeclaration)"); }
        public Object visit(IndexerDeclaration n, Object o) { return  unimplementedVisitor("visit(IndexerDeclaration, Object)"); }

        public Object visit(OperatorDeclaration n) { return unimplementedVisitor("visit(OperatorDeclaration)"); }
        public Object visit(OperatorDeclaration n, Object o) { return  unimplementedVisitor("visit(OperatorDeclaration, Object)"); }

        public Object visit(SymbolOperatorDeclarator n) { return unimplementedVisitor("visit(SymbolOperatorDeclarator)"); }
        public Object visit(SymbolOperatorDeclarator n, Object o) { return  unimplementedVisitor("visit(SymbolOperatorDeclarator, Object)"); }

        public Object visit(OperatorBody n) { return unimplementedVisitor("visit(OperatorBody)"); }
        public Object visit(OperatorBody n, Object o) { return  unimplementedVisitor("visit(OperatorBody, Object)"); }

        public Object visit(ConstructorDeclaration n) { return unimplementedVisitor("visit(ConstructorDeclaration)"); }
        public Object visit(ConstructorDeclaration n, Object o) { return  unimplementedVisitor("visit(ConstructorDeclaration, Object)"); }

        public Object visit(ConstructorDeclarator n) { return unimplementedVisitor("visit(ConstructorDeclarator)"); }
        public Object visit(ConstructorDeclarator n, Object o) { return  unimplementedVisitor("visit(ConstructorDeclarator, Object)"); }

        public Object visit(ConstructorBody n) { return unimplementedVisitor("visit(ConstructorBody)"); }
        public Object visit(ConstructorBody n, Object o) { return  unimplementedVisitor("visit(ConstructorBody, Object)"); }

        public Object visit(FinalizerDeclaration n) { return unimplementedVisitor("visit(FinalizerDeclaration)"); }
        public Object visit(FinalizerDeclaration n, Object o) { return  unimplementedVisitor("visit(FinalizerDeclaration, Object)"); }

        public Object visit(FinalizerBody n) { return unimplementedVisitor("visit(FinalizerBody)"); }
        public Object visit(FinalizerBody n, Object o) { return  unimplementedVisitor("visit(FinalizerBody, Object)"); }

        public Object visit(StructDeclaration n) { return unimplementedVisitor("visit(StructDeclaration)"); }
        public Object visit(StructDeclaration n, Object o) { return  unimplementedVisitor("visit(StructDeclaration, Object)"); }

        public Object visit(StructInterfacesOpt n) { return unimplementedVisitor("visit(StructInterfacesOpt)"); }
        public Object visit(StructInterfacesOpt n, Object o) { return  unimplementedVisitor("visit(StructInterfacesOpt, Object)"); }

        public Object visit(StructInterfaces n) { return unimplementedVisitor("visit(StructInterfaces)"); }
        public Object visit(StructInterfaces n, Object o) { return  unimplementedVisitor("visit(StructInterfaces, Object)"); }

        public Object visit(StructBody n) { return unimplementedVisitor("visit(StructBody)"); }
        public Object visit(StructBody n, Object o) { return  unimplementedVisitor("visit(StructBody, Object)"); }

        public Object visit(StructMemberDeclarations n) { return unimplementedVisitor("visit(StructMemberDeclarations)"); }
        public Object visit(StructMemberDeclarations n, Object o) { return  unimplementedVisitor("visit(StructMemberDeclarations, Object)"); }

        public Object visit(ArrayType n) { return unimplementedVisitor("visit(ArrayType)"); }
        public Object visit(ArrayType n, Object o) { return  unimplementedVisitor("visit(ArrayType, Object)"); }

        public Object visit(RankSpecifiers n) { return unimplementedVisitor("visit(RankSpecifiers)"); }
        public Object visit(RankSpecifiers n, Object o) { return  unimplementedVisitor("visit(RankSpecifiers, Object)"); }

        public Object visit(RankSpecifier n) { return unimplementedVisitor("visit(RankSpecifier)"); }
        public Object visit(RankSpecifier n, Object o) { return  unimplementedVisitor("visit(RankSpecifier, Object)"); }

        public Object visit(VariableInitializerList n) { return unimplementedVisitor("visit(VariableInitializerList)"); }
        public Object visit(VariableInitializerList n, Object o) { return  unimplementedVisitor("visit(VariableInitializerList, Object)"); }

        public Object visit(InterfaceDeclaration n) { return unimplementedVisitor("visit(InterfaceDeclaration)"); }
        public Object visit(InterfaceDeclaration n, Object o) { return  unimplementedVisitor("visit(InterfaceDeclaration, Object)"); }

        public Object visit(InterfaceBase n) { return unimplementedVisitor("visit(InterfaceBase)"); }
        public Object visit(InterfaceBase n, Object o) { return  unimplementedVisitor("visit(InterfaceBase, Object)"); }

        public Object visit(InterfaceBody n) { return unimplementedVisitor("visit(InterfaceBody)"); }
        public Object visit(InterfaceBody n, Object o) { return  unimplementedVisitor("visit(InterfaceBody, Object)"); }

        public Object visit(InterfaceMemberDeclarations n) { return unimplementedVisitor("visit(InterfaceMemberDeclarations)"); }
        public Object visit(InterfaceMemberDeclarations n, Object o) { return  unimplementedVisitor("visit(InterfaceMemberDeclarations, Object)"); }

        public Object visit(InterfaceMethodDeclaration n) { return unimplementedVisitor("visit(InterfaceMethodDeclaration)"); }
        public Object visit(InterfaceMethodDeclaration n, Object o) { return  unimplementedVisitor("visit(InterfaceMethodDeclaration, Object)"); }

        public Object visit(InterfacePropertyDeclaration n) { return unimplementedVisitor("visit(InterfacePropertyDeclaration)"); }
        public Object visit(InterfacePropertyDeclaration n, Object o) { return  unimplementedVisitor("visit(InterfacePropertyDeclaration, Object)"); }

        public Object visit(InterfaceEventDeclaration n) { return unimplementedVisitor("visit(InterfaceEventDeclaration)"); }
        public Object visit(InterfaceEventDeclaration n, Object o) { return  unimplementedVisitor("visit(InterfaceEventDeclaration, Object)"); }

        public Object visit(InterfaceIndexerDeclaration n) { return unimplementedVisitor("visit(InterfaceIndexerDeclaration)"); }
        public Object visit(InterfaceIndexerDeclaration n, Object o) { return  unimplementedVisitor("visit(InterfaceIndexerDeclaration, Object)"); }

        public Object visit(EnumDeclaration n) { return unimplementedVisitor("visit(EnumDeclaration)"); }
        public Object visit(EnumDeclaration n, Object o) { return  unimplementedVisitor("visit(EnumDeclaration, Object)"); }

        public Object visit(EnumBase n) { return unimplementedVisitor("visit(EnumBase)"); }
        public Object visit(EnumBase n, Object o) { return  unimplementedVisitor("visit(EnumBase, Object)"); }

        public Object visit(EnumMemberDeclarations n) { return unimplementedVisitor("visit(EnumMemberDeclarations)"); }
        public Object visit(EnumMemberDeclarations n, Object o) { return  unimplementedVisitor("visit(EnumMemberDeclarations, Object)"); }

        public Object visit(DelegateDeclaration n) { return unimplementedVisitor("visit(DelegateDeclaration)"); }
        public Object visit(DelegateDeclaration n, Object o) { return  unimplementedVisitor("visit(DelegateDeclaration, Object)"); }

        public Object visit(AttributeSections n) { return unimplementedVisitor("visit(AttributeSections)"); }
        public Object visit(AttributeSections n, Object o) { return  unimplementedVisitor("visit(AttributeSections, Object)"); }

        public Object visit(AttributeTargetSpecifier n) { return unimplementedVisitor("visit(AttributeTargetSpecifier)"); }
        public Object visit(AttributeTargetSpecifier n, Object o) { return  unimplementedVisitor("visit(AttributeTargetSpecifier, Object)"); }

        public Object visit(AttributeTarget n) { return unimplementedVisitor("visit(AttributeTarget)"); }
        public Object visit(AttributeTarget n, Object o) { return  unimplementedVisitor("visit(AttributeTarget, Object)"); }

        public Object visit(AttributeList n) { return unimplementedVisitor("visit(AttributeList)"); }
        public Object visit(AttributeList n, Object o) { return  unimplementedVisitor("visit(AttributeList, Object)"); }

        public Object visit(Attribute n) { return unimplementedVisitor("visit(Attribute)"); }
        public Object visit(Attribute n, Object o) { return  unimplementedVisitor("visit(Attribute, Object)"); }

        public Object visit(PositionalArgumentList n) { return unimplementedVisitor("visit(PositionalArgumentList)"); }
        public Object visit(PositionalArgumentList n, Object o) { return  unimplementedVisitor("visit(PositionalArgumentList, Object)"); }

        public Object visit(NamedArgumentList n) { return unimplementedVisitor("visit(NamedArgumentList)"); }
        public Object visit(NamedArgumentList n, Object o) { return  unimplementedVisitor("visit(NamedArgumentList, Object)"); }

        public Object visit(NamedArgument n) { return unimplementedVisitor("visit(NamedArgument)"); }
        public Object visit(NamedArgument n, Object o) { return  unimplementedVisitor("visit(NamedArgument, Object)"); }

        public Object visit(TypeParameterList n) { return unimplementedVisitor("visit(TypeParameterList)"); }
        public Object visit(TypeParameterList n, Object o) { return  unimplementedVisitor("visit(TypeParameterList, Object)"); }

        public Object visit(TypeParameter n) { return unimplementedVisitor("visit(TypeParameter)"); }
        public Object visit(TypeParameter n, Object o) { return  unimplementedVisitor("visit(TypeParameter, Object)"); }

        public Object visit(TypeArgumentList n) { return unimplementedVisitor("visit(TypeArgumentList)"); }
        public Object visit(TypeArgumentList n, Object o) { return  unimplementedVisitor("visit(TypeArgumentList, Object)"); }

        public Object visit(TypeArguments n) { return unimplementedVisitor("visit(TypeArguments)"); }
        public Object visit(TypeArguments n, Object o) { return  unimplementedVisitor("visit(TypeArguments, Object)"); }

        public Object visit(TypeParameterConstraintsClauses n) { return unimplementedVisitor("visit(TypeParameterConstraintsClauses)"); }
        public Object visit(TypeParameterConstraintsClauses n, Object o) { return  unimplementedVisitor("visit(TypeParameterConstraintsClauses, Object)"); }

        public Object visit(TypeParameterConstraintsClause n) { return unimplementedVisitor("visit(TypeParameterConstraintsClause)"); }
        public Object visit(TypeParameterConstraintsClause n, Object o) { return  unimplementedVisitor("visit(TypeParameterConstraintsClause, Object)"); }

        public Object visit(TypeParameterConstraints n) { return unimplementedVisitor("visit(TypeParameterConstraints)"); }
        public Object visit(TypeParameterConstraints n, Object o) { return  unimplementedVisitor("visit(TypeParameterConstraints, Object)"); }

        public Object visit(Constraints n) { return unimplementedVisitor("visit(Constraints)"); }
        public Object visit(Constraints n, Object o) { return  unimplementedVisitor("visit(Constraints, Object)"); }

        public Object visit(ConstructorConstraint n) { return unimplementedVisitor("visit(ConstructorConstraint)"); }
        public Object visit(ConstructorConstraint n, Object o) { return  unimplementedVisitor("visit(ConstructorConstraint, Object)"); }

        public Object visit(BooleanLiteral0 n) { return unimplementedVisitor("visit(BooleanLiteral0)"); }
        public Object visit(BooleanLiteral0 n, Object o) { return  unimplementedVisitor("visit(BooleanLiteral0, Object)"); }

        public Object visit(BooleanLiteral1 n) { return unimplementedVisitor("visit(BooleanLiteral1)"); }
        public Object visit(BooleanLiteral1 n, Object o) { return  unimplementedVisitor("visit(BooleanLiteral1, Object)"); }

        public Object visit(Name0 n) { return unimplementedVisitor("visit(Name0)"); }
        public Object visit(Name0 n, Object o) { return  unimplementedVisitor("visit(Name0, Object)"); }

        public Object visit(Name1 n) { return unimplementedVisitor("visit(Name1)"); }
        public Object visit(Name1 n, Object o) { return  unimplementedVisitor("visit(Name1, Object)"); }

        public Object visit(Name2 n) { return unimplementedVisitor("visit(Name2)"); }
        public Object visit(Name2 n, Object o) { return  unimplementedVisitor("visit(Name2, Object)"); }

        public Object visit(NonNamedType0 n) { return unimplementedVisitor("visit(NonNamedType0)"); }
        public Object visit(NonNamedType0 n, Object o) { return  unimplementedVisitor("visit(NonNamedType0, Object)"); }

        public Object visit(NonNamedType1 n) { return unimplementedVisitor("visit(NonNamedType1)"); }
        public Object visit(NonNamedType1 n, Object o) { return  unimplementedVisitor("visit(NonNamedType1, Object)"); }

        public Object visit(IntegralType0 n) { return unimplementedVisitor("visit(IntegralType0)"); }
        public Object visit(IntegralType0 n, Object o) { return  unimplementedVisitor("visit(IntegralType0, Object)"); }

        public Object visit(IntegralType1 n) { return unimplementedVisitor("visit(IntegralType1)"); }
        public Object visit(IntegralType1 n, Object o) { return  unimplementedVisitor("visit(IntegralType1, Object)"); }

        public Object visit(IntegralType2 n) { return unimplementedVisitor("visit(IntegralType2)"); }
        public Object visit(IntegralType2 n, Object o) { return  unimplementedVisitor("visit(IntegralType2, Object)"); }

        public Object visit(IntegralType3 n) { return unimplementedVisitor("visit(IntegralType3)"); }
        public Object visit(IntegralType3 n, Object o) { return  unimplementedVisitor("visit(IntegralType3, Object)"); }

        public Object visit(IntegralType4 n) { return unimplementedVisitor("visit(IntegralType4)"); }
        public Object visit(IntegralType4 n, Object o) { return  unimplementedVisitor("visit(IntegralType4, Object)"); }

        public Object visit(IntegralType5 n) { return unimplementedVisitor("visit(IntegralType5)"); }
        public Object visit(IntegralType5 n, Object o) { return  unimplementedVisitor("visit(IntegralType5, Object)"); }

        public Object visit(IntegralType6 n) { return unimplementedVisitor("visit(IntegralType6)"); }
        public Object visit(IntegralType6 n, Object o) { return  unimplementedVisitor("visit(IntegralType6, Object)"); }

        public Object visit(IntegralType7 n) { return unimplementedVisitor("visit(IntegralType7)"); }
        public Object visit(IntegralType7 n, Object o) { return  unimplementedVisitor("visit(IntegralType7, Object)"); }

        public Object visit(IntegralType8 n) { return unimplementedVisitor("visit(IntegralType8)"); }
        public Object visit(IntegralType8 n, Object o) { return  unimplementedVisitor("visit(IntegralType8, Object)"); }

        public Object visit(FloatingPointType0 n) { return unimplementedVisitor("visit(FloatingPointType0)"); }
        public Object visit(FloatingPointType0 n, Object o) { return  unimplementedVisitor("visit(FloatingPointType0, Object)"); }

        public Object visit(FloatingPointType1 n) { return unimplementedVisitor("visit(FloatingPointType1)"); }
        public Object visit(FloatingPointType1 n, Object o) { return  unimplementedVisitor("visit(FloatingPointType1, Object)"); }

        public Object visit(ClassType0 n) { return unimplementedVisitor("visit(ClassType0)"); }
        public Object visit(ClassType0 n, Object o) { return  unimplementedVisitor("visit(ClassType0, Object)"); }

        public Object visit(ClassType1 n) { return unimplementedVisitor("visit(ClassType1)"); }
        public Object visit(ClassType1 n, Object o) { return  unimplementedVisitor("visit(ClassType1, Object)"); }

        public Object visit(Argument0 n) { return unimplementedVisitor("visit(Argument0)"); }
        public Object visit(Argument0 n, Object o) { return  unimplementedVisitor("visit(Argument0, Object)"); }

        public Object visit(Argument1 n) { return unimplementedVisitor("visit(Argument1)"); }
        public Object visit(Argument1 n, Object o) { return  unimplementedVisitor("visit(Argument1, Object)"); }

        public Object visit(MemberAccess0 n) { return unimplementedVisitor("visit(MemberAccess0)"); }
        public Object visit(MemberAccess0 n, Object o) { return  unimplementedVisitor("visit(MemberAccess0, Object)"); }

        public Object visit(MemberAccess1 n) { return unimplementedVisitor("visit(MemberAccess1)"); }
        public Object visit(MemberAccess1 n, Object o) { return  unimplementedVisitor("visit(MemberAccess1, Object)"); }

        public Object visit(MemberAccess2 n) { return unimplementedVisitor("visit(MemberAccess2)"); }
        public Object visit(MemberAccess2 n, Object o) { return  unimplementedVisitor("visit(MemberAccess2, Object)"); }

        public Object visit(PredefinedType0 n) { return unimplementedVisitor("visit(PredefinedType0)"); }
        public Object visit(PredefinedType0 n, Object o) { return  unimplementedVisitor("visit(PredefinedType0, Object)"); }

        public Object visit(PredefinedType1 n) { return unimplementedVisitor("visit(PredefinedType1)"); }
        public Object visit(PredefinedType1 n, Object o) { return  unimplementedVisitor("visit(PredefinedType1, Object)"); }

        public Object visit(PredefinedType2 n) { return unimplementedVisitor("visit(PredefinedType2)"); }
        public Object visit(PredefinedType2 n, Object o) { return  unimplementedVisitor("visit(PredefinedType2, Object)"); }

        public Object visit(PredefinedType3 n) { return unimplementedVisitor("visit(PredefinedType3)"); }
        public Object visit(PredefinedType3 n, Object o) { return  unimplementedVisitor("visit(PredefinedType3, Object)"); }

        public Object visit(PredefinedType4 n) { return unimplementedVisitor("visit(PredefinedType4)"); }
        public Object visit(PredefinedType4 n, Object o) { return  unimplementedVisitor("visit(PredefinedType4, Object)"); }

        public Object visit(PredefinedType5 n) { return unimplementedVisitor("visit(PredefinedType5)"); }
        public Object visit(PredefinedType5 n, Object o) { return  unimplementedVisitor("visit(PredefinedType5, Object)"); }

        public Object visit(PredefinedType6 n) { return unimplementedVisitor("visit(PredefinedType6)"); }
        public Object visit(PredefinedType6 n, Object o) { return  unimplementedVisitor("visit(PredefinedType6, Object)"); }

        public Object visit(PredefinedType7 n) { return unimplementedVisitor("visit(PredefinedType7)"); }
        public Object visit(PredefinedType7 n, Object o) { return  unimplementedVisitor("visit(PredefinedType7, Object)"); }

        public Object visit(PredefinedType8 n) { return unimplementedVisitor("visit(PredefinedType8)"); }
        public Object visit(PredefinedType8 n, Object o) { return  unimplementedVisitor("visit(PredefinedType8, Object)"); }

        public Object visit(PredefinedType9 n) { return unimplementedVisitor("visit(PredefinedType9)"); }
        public Object visit(PredefinedType9 n, Object o) { return  unimplementedVisitor("visit(PredefinedType9, Object)"); }

        public Object visit(PredefinedType10 n) { return unimplementedVisitor("visit(PredefinedType10)"); }
        public Object visit(PredefinedType10 n, Object o) { return  unimplementedVisitor("visit(PredefinedType10, Object)"); }

        public Object visit(PredefinedType11 n) { return unimplementedVisitor("visit(PredefinedType11)"); }
        public Object visit(PredefinedType11 n, Object o) { return  unimplementedVisitor("visit(PredefinedType11, Object)"); }

        public Object visit(PredefinedType12 n) { return unimplementedVisitor("visit(PredefinedType12)"); }
        public Object visit(PredefinedType12 n, Object o) { return  unimplementedVisitor("visit(PredefinedType12, Object)"); }

        public Object visit(PredefinedType13 n) { return unimplementedVisitor("visit(PredefinedType13)"); }
        public Object visit(PredefinedType13 n, Object o) { return  unimplementedVisitor("visit(PredefinedType13, Object)"); }

        public Object visit(PredefinedType14 n) { return unimplementedVisitor("visit(PredefinedType14)"); }
        public Object visit(PredefinedType14 n, Object o) { return  unimplementedVisitor("visit(PredefinedType14, Object)"); }

        public Object visit(BaseAccess0 n) { return unimplementedVisitor("visit(BaseAccess0)"); }
        public Object visit(BaseAccess0 n, Object o) { return  unimplementedVisitor("visit(BaseAccess0, Object)"); }

        public Object visit(BaseAccess1 n) { return unimplementedVisitor("visit(BaseAccess1)"); }
        public Object visit(BaseAccess1 n, Object o) { return  unimplementedVisitor("visit(BaseAccess1, Object)"); }

        public Object visit(ArrayCreationExpression0 n) { return unimplementedVisitor("visit(ArrayCreationExpression0)"); }
        public Object visit(ArrayCreationExpression0 n, Object o) { return  unimplementedVisitor("visit(ArrayCreationExpression0, Object)"); }

        public Object visit(ArrayCreationExpression1 n) { return unimplementedVisitor("visit(ArrayCreationExpression1)"); }
        public Object visit(ArrayCreationExpression1 n, Object o) { return  unimplementedVisitor("visit(ArrayCreationExpression1, Object)"); }

        public Object visit(TypeofExpression0 n) { return unimplementedVisitor("visit(TypeofExpression0)"); }
        public Object visit(TypeofExpression0 n, Object o) { return  unimplementedVisitor("visit(TypeofExpression0, Object)"); }

        public Object visit(TypeofExpression1 n) { return unimplementedVisitor("visit(TypeofExpression1)"); }
        public Object visit(TypeofExpression1 n, Object o) { return  unimplementedVisitor("visit(TypeofExpression1, Object)"); }

        public Object visit(UnboundTypeName0 n) { return unimplementedVisitor("visit(UnboundTypeName0)"); }
        public Object visit(UnboundTypeName0 n, Object o) { return  unimplementedVisitor("visit(UnboundTypeName0, Object)"); }

        public Object visit(UnboundTypeName1 n) { return unimplementedVisitor("visit(UnboundTypeName1)"); }
        public Object visit(UnboundTypeName1 n, Object o) { return  unimplementedVisitor("visit(UnboundTypeName1, Object)"); }

        public Object visit(UnboundTypeName2 n) { return unimplementedVisitor("visit(UnboundTypeName2)"); }
        public Object visit(UnboundTypeName2 n, Object o) { return  unimplementedVisitor("visit(UnboundTypeName2, Object)"); }

        public Object visit(Commas0 n) { return unimplementedVisitor("visit(Commas0)"); }
        public Object visit(Commas0 n, Object o) { return  unimplementedVisitor("visit(Commas0, Object)"); }

        public Object visit(Commas1 n) { return unimplementedVisitor("visit(Commas1)"); }
        public Object visit(Commas1 n, Object o) { return  unimplementedVisitor("visit(Commas1, Object)"); }

        public Object visit(UnaryExpression0 n) { return unimplementedVisitor("visit(UnaryExpression0)"); }
        public Object visit(UnaryExpression0 n, Object o) { return  unimplementedVisitor("visit(UnaryExpression0, Object)"); }

        public Object visit(UnaryExpression1 n) { return unimplementedVisitor("visit(UnaryExpression1)"); }
        public Object visit(UnaryExpression1 n, Object o) { return  unimplementedVisitor("visit(UnaryExpression1, Object)"); }

        public Object visit(UnaryExpression2 n) { return unimplementedVisitor("visit(UnaryExpression2)"); }
        public Object visit(UnaryExpression2 n, Object o) { return  unimplementedVisitor("visit(UnaryExpression2, Object)"); }

        public Object visit(UnaryExpression3 n) { return unimplementedVisitor("visit(UnaryExpression3)"); }
        public Object visit(UnaryExpression3 n, Object o) { return  unimplementedVisitor("visit(UnaryExpression3, Object)"); }

        public Object visit(MultiplicativeExpression0 n) { return unimplementedVisitor("visit(MultiplicativeExpression0)"); }
        public Object visit(MultiplicativeExpression0 n, Object o) { return  unimplementedVisitor("visit(MultiplicativeExpression0, Object)"); }

        public Object visit(MultiplicativeExpression1 n) { return unimplementedVisitor("visit(MultiplicativeExpression1)"); }
        public Object visit(MultiplicativeExpression1 n, Object o) { return  unimplementedVisitor("visit(MultiplicativeExpression1, Object)"); }

        public Object visit(MultiplicativeExpression2 n) { return unimplementedVisitor("visit(MultiplicativeExpression2)"); }
        public Object visit(MultiplicativeExpression2 n, Object o) { return  unimplementedVisitor("visit(MultiplicativeExpression2, Object)"); }

        public Object visit(AdditiveExpression0 n) { return unimplementedVisitor("visit(AdditiveExpression0)"); }
        public Object visit(AdditiveExpression0 n, Object o) { return  unimplementedVisitor("visit(AdditiveExpression0, Object)"); }

        public Object visit(AdditiveExpression1 n) { return unimplementedVisitor("visit(AdditiveExpression1)"); }
        public Object visit(AdditiveExpression1 n, Object o) { return  unimplementedVisitor("visit(AdditiveExpression1, Object)"); }

        public Object visit(ShiftExpression0 n) { return unimplementedVisitor("visit(ShiftExpression0)"); }
        public Object visit(ShiftExpression0 n, Object o) { return  unimplementedVisitor("visit(ShiftExpression0, Object)"); }

        public Object visit(ShiftExpression1 n) { return unimplementedVisitor("visit(ShiftExpression1)"); }
        public Object visit(ShiftExpression1 n, Object o) { return  unimplementedVisitor("visit(ShiftExpression1, Object)"); }

        public Object visit(RelationalExpression0 n) { return unimplementedVisitor("visit(RelationalExpression0)"); }
        public Object visit(RelationalExpression0 n, Object o) { return  unimplementedVisitor("visit(RelationalExpression0, Object)"); }

        public Object visit(RelationalExpression1 n) { return unimplementedVisitor("visit(RelationalExpression1)"); }
        public Object visit(RelationalExpression1 n, Object o) { return  unimplementedVisitor("visit(RelationalExpression1, Object)"); }

        public Object visit(RelationalExpression2 n) { return unimplementedVisitor("visit(RelationalExpression2)"); }
        public Object visit(RelationalExpression2 n, Object o) { return  unimplementedVisitor("visit(RelationalExpression2, Object)"); }

        public Object visit(RelationalExpression3 n) { return unimplementedVisitor("visit(RelationalExpression3)"); }
        public Object visit(RelationalExpression3 n, Object o) { return  unimplementedVisitor("visit(RelationalExpression3, Object)"); }

        public Object visit(RelationalExpression4 n) { return unimplementedVisitor("visit(RelationalExpression4)"); }
        public Object visit(RelationalExpression4 n, Object o) { return  unimplementedVisitor("visit(RelationalExpression4, Object)"); }

        public Object visit(RelationalExpression5 n) { return unimplementedVisitor("visit(RelationalExpression5)"); }
        public Object visit(RelationalExpression5 n, Object o) { return  unimplementedVisitor("visit(RelationalExpression5, Object)"); }

        public Object visit(EqualityExpression0 n) { return unimplementedVisitor("visit(EqualityExpression0)"); }
        public Object visit(EqualityExpression0 n, Object o) { return  unimplementedVisitor("visit(EqualityExpression0, Object)"); }

        public Object visit(EqualityExpression1 n) { return unimplementedVisitor("visit(EqualityExpression1)"); }
        public Object visit(EqualityExpression1 n, Object o) { return  unimplementedVisitor("visit(EqualityExpression1, Object)"); }

        public Object visit(AssignmentOperator0 n) { return unimplementedVisitor("visit(AssignmentOperator0)"); }
        public Object visit(AssignmentOperator0 n, Object o) { return  unimplementedVisitor("visit(AssignmentOperator0, Object)"); }

        public Object visit(AssignmentOperator1 n) { return unimplementedVisitor("visit(AssignmentOperator1)"); }
        public Object visit(AssignmentOperator1 n, Object o) { return  unimplementedVisitor("visit(AssignmentOperator1, Object)"); }

        public Object visit(AssignmentOperator2 n) { return unimplementedVisitor("visit(AssignmentOperator2)"); }
        public Object visit(AssignmentOperator2 n, Object o) { return  unimplementedVisitor("visit(AssignmentOperator2, Object)"); }

        public Object visit(AssignmentOperator3 n) { return unimplementedVisitor("visit(AssignmentOperator3)"); }
        public Object visit(AssignmentOperator3 n, Object o) { return  unimplementedVisitor("visit(AssignmentOperator3, Object)"); }

        public Object visit(AssignmentOperator4 n) { return unimplementedVisitor("visit(AssignmentOperator4)"); }
        public Object visit(AssignmentOperator4 n, Object o) { return  unimplementedVisitor("visit(AssignmentOperator4, Object)"); }

        public Object visit(AssignmentOperator5 n) { return unimplementedVisitor("visit(AssignmentOperator5)"); }
        public Object visit(AssignmentOperator5 n, Object o) { return  unimplementedVisitor("visit(AssignmentOperator5, Object)"); }

        public Object visit(AssignmentOperator6 n) { return unimplementedVisitor("visit(AssignmentOperator6)"); }
        public Object visit(AssignmentOperator6 n, Object o) { return  unimplementedVisitor("visit(AssignmentOperator6, Object)"); }

        public Object visit(AssignmentOperator7 n) { return unimplementedVisitor("visit(AssignmentOperator7)"); }
        public Object visit(AssignmentOperator7 n, Object o) { return  unimplementedVisitor("visit(AssignmentOperator7, Object)"); }

        public Object visit(AssignmentOperator8 n) { return unimplementedVisitor("visit(AssignmentOperator8)"); }
        public Object visit(AssignmentOperator8 n, Object o) { return  unimplementedVisitor("visit(AssignmentOperator8, Object)"); }

        public Object visit(AssignmentOperator9 n) { return unimplementedVisitor("visit(AssignmentOperator9)"); }
        public Object visit(AssignmentOperator9 n, Object o) { return  unimplementedVisitor("visit(AssignmentOperator9, Object)"); }

        public Object visit(AssignmentOperator10 n) { return unimplementedVisitor("visit(AssignmentOperator10)"); }
        public Object visit(AssignmentOperator10 n, Object o) { return  unimplementedVisitor("visit(AssignmentOperator10, Object)"); }

        public Object visit(DeclarationStatement0 n) { return unimplementedVisitor("visit(DeclarationStatement0)"); }
        public Object visit(DeclarationStatement0 n, Object o) { return  unimplementedVisitor("visit(DeclarationStatement0, Object)"); }

        public Object visit(DeclarationStatement1 n) { return unimplementedVisitor("visit(DeclarationStatement1)"); }
        public Object visit(DeclarationStatement1 n, Object o) { return  unimplementedVisitor("visit(DeclarationStatement1, Object)"); }

        public Object visit(LocalVariableDeclarator0 n) { return unimplementedVisitor("visit(LocalVariableDeclarator0)"); }
        public Object visit(LocalVariableDeclarator0 n, Object o) { return  unimplementedVisitor("visit(LocalVariableDeclarator0, Object)"); }

        public Object visit(LocalVariableDeclarator1 n) { return unimplementedVisitor("visit(LocalVariableDeclarator1)"); }
        public Object visit(LocalVariableDeclarator1 n, Object o) { return  unimplementedVisitor("visit(LocalVariableDeclarator1, Object)"); }

        public Object visit(SwitchLabel0 n) { return unimplementedVisitor("visit(SwitchLabel0)"); }
        public Object visit(SwitchLabel0 n, Object o) { return  unimplementedVisitor("visit(SwitchLabel0, Object)"); }

        public Object visit(SwitchLabel1 n) { return unimplementedVisitor("visit(SwitchLabel1)"); }
        public Object visit(SwitchLabel1 n, Object o) { return  unimplementedVisitor("visit(SwitchLabel1, Object)"); }

        public Object visit(GotoStatement0 n) { return unimplementedVisitor("visit(GotoStatement0)"); }
        public Object visit(GotoStatement0 n, Object o) { return  unimplementedVisitor("visit(GotoStatement0, Object)"); }

        public Object visit(GotoStatement1 n) { return unimplementedVisitor("visit(GotoStatement1)"); }
        public Object visit(GotoStatement1 n, Object o) { return  unimplementedVisitor("visit(GotoStatement1, Object)"); }

        public Object visit(GotoStatement2 n) { return unimplementedVisitor("visit(GotoStatement2)"); }
        public Object visit(GotoStatement2 n, Object o) { return  unimplementedVisitor("visit(GotoStatement2, Object)"); }

        public Object visit(TryStatement0 n) { return unimplementedVisitor("visit(TryStatement0)"); }
        public Object visit(TryStatement0 n, Object o) { return  unimplementedVisitor("visit(TryStatement0, Object)"); }

        public Object visit(TryStatement1 n) { return unimplementedVisitor("visit(TryStatement1)"); }
        public Object visit(TryStatement1 n, Object o) { return  unimplementedVisitor("visit(TryStatement1, Object)"); }

        public Object visit(YieldStatement0 n) { return unimplementedVisitor("visit(YieldStatement0)"); }
        public Object visit(YieldStatement0 n, Object o) { return  unimplementedVisitor("visit(YieldStatement0, Object)"); }

        public Object visit(YieldStatement1 n) { return unimplementedVisitor("visit(YieldStatement1)"); }
        public Object visit(YieldStatement1 n, Object o) { return  unimplementedVisitor("visit(YieldStatement1, Object)"); }

        public Object visit(Modifier0 n) { return unimplementedVisitor("visit(Modifier0)"); }
        public Object visit(Modifier0 n, Object o) { return  unimplementedVisitor("visit(Modifier0, Object)"); }

        public Object visit(Modifier1 n) { return unimplementedVisitor("visit(Modifier1)"); }
        public Object visit(Modifier1 n, Object o) { return  unimplementedVisitor("visit(Modifier1, Object)"); }

        public Object visit(Modifier2 n) { return unimplementedVisitor("visit(Modifier2)"); }
        public Object visit(Modifier2 n, Object o) { return  unimplementedVisitor("visit(Modifier2, Object)"); }

        public Object visit(Modifier3 n) { return unimplementedVisitor("visit(Modifier3)"); }
        public Object visit(Modifier3 n, Object o) { return  unimplementedVisitor("visit(Modifier3, Object)"); }

        public Object visit(Modifier4 n) { return unimplementedVisitor("visit(Modifier4)"); }
        public Object visit(Modifier4 n, Object o) { return  unimplementedVisitor("visit(Modifier4, Object)"); }

        public Object visit(Modifier5 n) { return unimplementedVisitor("visit(Modifier5)"); }
        public Object visit(Modifier5 n, Object o) { return  unimplementedVisitor("visit(Modifier5, Object)"); }

        public Object visit(Modifier6 n) { return unimplementedVisitor("visit(Modifier6)"); }
        public Object visit(Modifier6 n, Object o) { return  unimplementedVisitor("visit(Modifier6, Object)"); }

        public Object visit(Modifier7 n) { return unimplementedVisitor("visit(Modifier7)"); }
        public Object visit(Modifier7 n, Object o) { return  unimplementedVisitor("visit(Modifier7, Object)"); }

        public Object visit(Modifier8 n) { return unimplementedVisitor("visit(Modifier8)"); }
        public Object visit(Modifier8 n, Object o) { return  unimplementedVisitor("visit(Modifier8, Object)"); }

        public Object visit(Modifier9 n) { return unimplementedVisitor("visit(Modifier9)"); }
        public Object visit(Modifier9 n, Object o) { return  unimplementedVisitor("visit(Modifier9, Object)"); }

        public Object visit(Modifier10 n) { return unimplementedVisitor("visit(Modifier10)"); }
        public Object visit(Modifier10 n, Object o) { return  unimplementedVisitor("visit(Modifier10, Object)"); }

        public Object visit(Modifier11 n) { return unimplementedVisitor("visit(Modifier11)"); }
        public Object visit(Modifier11 n, Object o) { return  unimplementedVisitor("visit(Modifier11, Object)"); }

        public Object visit(Modifier12 n) { return unimplementedVisitor("visit(Modifier12)"); }
        public Object visit(Modifier12 n, Object o) { return  unimplementedVisitor("visit(Modifier12, Object)"); }

        public Object visit(VariableDeclarator0 n) { return unimplementedVisitor("visit(VariableDeclarator0)"); }
        public Object visit(VariableDeclarator0 n, Object o) { return  unimplementedVisitor("visit(VariableDeclarator0, Object)"); }

        public Object visit(VariableDeclarator1 n) { return unimplementedVisitor("visit(VariableDeclarator1)"); }
        public Object visit(VariableDeclarator1 n, Object o) { return  unimplementedVisitor("visit(VariableDeclarator1, Object)"); }

        public Object visit(ParameterModifier0 n) { return unimplementedVisitor("visit(ParameterModifier0)"); }
        public Object visit(ParameterModifier0 n, Object o) { return  unimplementedVisitor("visit(ParameterModifier0, Object)"); }

        public Object visit(ParameterModifier1 n) { return unimplementedVisitor("visit(ParameterModifier1)"); }
        public Object visit(ParameterModifier1 n, Object o) { return  unimplementedVisitor("visit(ParameterModifier1, Object)"); }

        public Object visit(AccessorDeclarations0 n) { return unimplementedVisitor("visit(AccessorDeclarations0)"); }
        public Object visit(AccessorDeclarations0 n, Object o) { return  unimplementedVisitor("visit(AccessorDeclarations0, Object)"); }

        public Object visit(AccessorDeclarations1 n) { return unimplementedVisitor("visit(AccessorDeclarations1)"); }
        public Object visit(AccessorDeclarations1 n, Object o) { return  unimplementedVisitor("visit(AccessorDeclarations1, Object)"); }

        public Object visit(AccessorModifier0 n) { return unimplementedVisitor("visit(AccessorModifier0)"); }
        public Object visit(AccessorModifier0 n, Object o) { return  unimplementedVisitor("visit(AccessorModifier0, Object)"); }

        public Object visit(AccessorModifier1 n) { return unimplementedVisitor("visit(AccessorModifier1)"); }
        public Object visit(AccessorModifier1 n, Object o) { return  unimplementedVisitor("visit(AccessorModifier1, Object)"); }

        public Object visit(AccessorModifier2 n) { return unimplementedVisitor("visit(AccessorModifier2)"); }
        public Object visit(AccessorModifier2 n, Object o) { return  unimplementedVisitor("visit(AccessorModifier2, Object)"); }

        public Object visit(AccessorModifier3 n) { return unimplementedVisitor("visit(AccessorModifier3)"); }
        public Object visit(AccessorModifier3 n, Object o) { return  unimplementedVisitor("visit(AccessorModifier3, Object)"); }

        public Object visit(AccessorModifier4 n) { return unimplementedVisitor("visit(AccessorModifier4)"); }
        public Object visit(AccessorModifier4 n, Object o) { return  unimplementedVisitor("visit(AccessorModifier4, Object)"); }

        public Object visit(EventDeclaration0 n) { return unimplementedVisitor("visit(EventDeclaration0)"); }
        public Object visit(EventDeclaration0 n, Object o) { return  unimplementedVisitor("visit(EventDeclaration0, Object)"); }

        public Object visit(EventDeclaration1 n) { return unimplementedVisitor("visit(EventDeclaration1)"); }
        public Object visit(EventDeclaration1 n, Object o) { return  unimplementedVisitor("visit(EventDeclaration1, Object)"); }

        public Object visit(EventAccessorDeclarations0 n) { return unimplementedVisitor("visit(EventAccessorDeclarations0)"); }
        public Object visit(EventAccessorDeclarations0 n, Object o) { return  unimplementedVisitor("visit(EventAccessorDeclarations0, Object)"); }

        public Object visit(EventAccessorDeclarations1 n) { return unimplementedVisitor("visit(EventAccessorDeclarations1)"); }
        public Object visit(EventAccessorDeclarations1 n, Object o) { return  unimplementedVisitor("visit(EventAccessorDeclarations1, Object)"); }

        public Object visit(IndexerDeclarator0 n) { return unimplementedVisitor("visit(IndexerDeclarator0)"); }
        public Object visit(IndexerDeclarator0 n, Object o) { return  unimplementedVisitor("visit(IndexerDeclarator0, Object)"); }

        public Object visit(IndexerDeclarator1 n) { return unimplementedVisitor("visit(IndexerDeclarator1)"); }
        public Object visit(IndexerDeclarator1 n, Object o) { return  unimplementedVisitor("visit(IndexerDeclarator1, Object)"); }

        public Object visit(OverloadableOperator0 n) { return unimplementedVisitor("visit(OverloadableOperator0)"); }
        public Object visit(OverloadableOperator0 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator0, Object)"); }

        public Object visit(OverloadableOperator1 n) { return unimplementedVisitor("visit(OverloadableOperator1)"); }
        public Object visit(OverloadableOperator1 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator1, Object)"); }

        public Object visit(OverloadableOperator2 n) { return unimplementedVisitor("visit(OverloadableOperator2)"); }
        public Object visit(OverloadableOperator2 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator2, Object)"); }

        public Object visit(OverloadableOperator3 n) { return unimplementedVisitor("visit(OverloadableOperator3)"); }
        public Object visit(OverloadableOperator3 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator3, Object)"); }

        public Object visit(OverloadableOperator4 n) { return unimplementedVisitor("visit(OverloadableOperator4)"); }
        public Object visit(OverloadableOperator4 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator4, Object)"); }

        public Object visit(OverloadableOperator5 n) { return unimplementedVisitor("visit(OverloadableOperator5)"); }
        public Object visit(OverloadableOperator5 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator5, Object)"); }

        public Object visit(OverloadableOperator6 n) { return unimplementedVisitor("visit(OverloadableOperator6)"); }
        public Object visit(OverloadableOperator6 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator6, Object)"); }

        public Object visit(OverloadableOperator7 n) { return unimplementedVisitor("visit(OverloadableOperator7)"); }
        public Object visit(OverloadableOperator7 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator7, Object)"); }

        public Object visit(OverloadableOperator8 n) { return unimplementedVisitor("visit(OverloadableOperator8)"); }
        public Object visit(OverloadableOperator8 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator8, Object)"); }

        public Object visit(OverloadableOperator9 n) { return unimplementedVisitor("visit(OverloadableOperator9)"); }
        public Object visit(OverloadableOperator9 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator9, Object)"); }

        public Object visit(OverloadableOperator10 n) { return unimplementedVisitor("visit(OverloadableOperator10)"); }
        public Object visit(OverloadableOperator10 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator10, Object)"); }

        public Object visit(OverloadableOperator11 n) { return unimplementedVisitor("visit(OverloadableOperator11)"); }
        public Object visit(OverloadableOperator11 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator11, Object)"); }

        public Object visit(OverloadableOperator12 n) { return unimplementedVisitor("visit(OverloadableOperator12)"); }
        public Object visit(OverloadableOperator12 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator12, Object)"); }

        public Object visit(OverloadableOperator13 n) { return unimplementedVisitor("visit(OverloadableOperator13)"); }
        public Object visit(OverloadableOperator13 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator13, Object)"); }

        public Object visit(OverloadableOperator14 n) { return unimplementedVisitor("visit(OverloadableOperator14)"); }
        public Object visit(OverloadableOperator14 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator14, Object)"); }

        public Object visit(OverloadableOperator15 n) { return unimplementedVisitor("visit(OverloadableOperator15)"); }
        public Object visit(OverloadableOperator15 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator15, Object)"); }

        public Object visit(OverloadableOperator16 n) { return unimplementedVisitor("visit(OverloadableOperator16)"); }
        public Object visit(OverloadableOperator16 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator16, Object)"); }

        public Object visit(OverloadableOperator17 n) { return unimplementedVisitor("visit(OverloadableOperator17)"); }
        public Object visit(OverloadableOperator17 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator17, Object)"); }

        public Object visit(OverloadableOperator18 n) { return unimplementedVisitor("visit(OverloadableOperator18)"); }
        public Object visit(OverloadableOperator18 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator18, Object)"); }

        public Object visit(OverloadableOperator19 n) { return unimplementedVisitor("visit(OverloadableOperator19)"); }
        public Object visit(OverloadableOperator19 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator19, Object)"); }

        public Object visit(OverloadableOperator20 n) { return unimplementedVisitor("visit(OverloadableOperator20)"); }
        public Object visit(OverloadableOperator20 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator20, Object)"); }

        public Object visit(OverloadableOperator21 n) { return unimplementedVisitor("visit(OverloadableOperator21)"); }
        public Object visit(OverloadableOperator21 n, Object o) { return  unimplementedVisitor("visit(OverloadableOperator21, Object)"); }

        public Object visit(ConversionOperatorDeclarator0 n) { return unimplementedVisitor("visit(ConversionOperatorDeclarator0)"); }
        public Object visit(ConversionOperatorDeclarator0 n, Object o) { return  unimplementedVisitor("visit(ConversionOperatorDeclarator0, Object)"); }

        public Object visit(ConversionOperatorDeclarator1 n) { return unimplementedVisitor("visit(ConversionOperatorDeclarator1)"); }
        public Object visit(ConversionOperatorDeclarator1 n, Object o) { return  unimplementedVisitor("visit(ConversionOperatorDeclarator1, Object)"); }

        public Object visit(ConstructorInitializer0 n) { return unimplementedVisitor("visit(ConstructorInitializer0)"); }
        public Object visit(ConstructorInitializer0 n, Object o) { return  unimplementedVisitor("visit(ConstructorInitializer0, Object)"); }

        public Object visit(ConstructorInitializer1 n) { return unimplementedVisitor("visit(ConstructorInitializer1)"); }
        public Object visit(ConstructorInitializer1 n, Object o) { return  unimplementedVisitor("visit(ConstructorInitializer1, Object)"); }

        public Object visit(DimSeparators0 n) { return unimplementedVisitor("visit(DimSeparators0)"); }
        public Object visit(DimSeparators0 n, Object o) { return  unimplementedVisitor("visit(DimSeparators0, Object)"); }

        public Object visit(DimSeparators1 n) { return unimplementedVisitor("visit(DimSeparators1)"); }
        public Object visit(DimSeparators1 n, Object o) { return  unimplementedVisitor("visit(DimSeparators1, Object)"); }

        public Object visit(ArrayInitializer0 n) { return unimplementedVisitor("visit(ArrayInitializer0)"); }
        public Object visit(ArrayInitializer0 n, Object o) { return  unimplementedVisitor("visit(ArrayInitializer0, Object)"); }

        public Object visit(ArrayInitializer1 n) { return unimplementedVisitor("visit(ArrayInitializer1)"); }
        public Object visit(ArrayInitializer1 n, Object o) { return  unimplementedVisitor("visit(ArrayInitializer1, Object)"); }

        public Object visit(InterfaceAccessors0 n) { return unimplementedVisitor("visit(InterfaceAccessors0)"); }
        public Object visit(InterfaceAccessors0 n, Object o) { return  unimplementedVisitor("visit(InterfaceAccessors0, Object)"); }

        public Object visit(InterfaceAccessors1 n) { return unimplementedVisitor("visit(InterfaceAccessors1)"); }
        public Object visit(InterfaceAccessors1 n, Object o) { return  unimplementedVisitor("visit(InterfaceAccessors1, Object)"); }

        public Object visit(InterfaceAccessors2 n) { return unimplementedVisitor("visit(InterfaceAccessors2)"); }
        public Object visit(InterfaceAccessors2 n, Object o) { return  unimplementedVisitor("visit(InterfaceAccessors2, Object)"); }

        public Object visit(InterfaceAccessors3 n) { return unimplementedVisitor("visit(InterfaceAccessors3)"); }
        public Object visit(InterfaceAccessors3 n, Object o) { return  unimplementedVisitor("visit(InterfaceAccessors3, Object)"); }

        public Object visit(EnumBody0 n) { return unimplementedVisitor("visit(EnumBody0)"); }
        public Object visit(EnumBody0 n, Object o) { return  unimplementedVisitor("visit(EnumBody0, Object)"); }

        public Object visit(EnumBody1 n) { return unimplementedVisitor("visit(EnumBody1)"); }
        public Object visit(EnumBody1 n, Object o) { return  unimplementedVisitor("visit(EnumBody1, Object)"); }

        public Object visit(EnumMemberDeclaration0 n) { return unimplementedVisitor("visit(EnumMemberDeclaration0)"); }
        public Object visit(EnumMemberDeclaration0 n, Object o) { return  unimplementedVisitor("visit(EnumMemberDeclaration0, Object)"); }

        public Object visit(EnumMemberDeclaration1 n) { return unimplementedVisitor("visit(EnumMemberDeclaration1)"); }
        public Object visit(EnumMemberDeclaration1 n, Object o) { return  unimplementedVisitor("visit(EnumMemberDeclaration1, Object)"); }

        public Object visit(AttributeSection0 n) { return unimplementedVisitor("visit(AttributeSection0)"); }
        public Object visit(AttributeSection0 n, Object o) { return  unimplementedVisitor("visit(AttributeSection0, Object)"); }

        public Object visit(AttributeSection1 n) { return unimplementedVisitor("visit(AttributeSection1)"); }
        public Object visit(AttributeSection1 n, Object o) { return  unimplementedVisitor("visit(AttributeSection1, Object)"); }

        public Object visit(Keyword0 n) { return unimplementedVisitor("visit(Keyword0)"); }
        public Object visit(Keyword0 n, Object o) { return  unimplementedVisitor("visit(Keyword0, Object)"); }

        public Object visit(Keyword1 n) { return unimplementedVisitor("visit(Keyword1)"); }
        public Object visit(Keyword1 n, Object o) { return  unimplementedVisitor("visit(Keyword1, Object)"); }

        public Object visit(Keyword2 n) { return unimplementedVisitor("visit(Keyword2)"); }
        public Object visit(Keyword2 n, Object o) { return  unimplementedVisitor("visit(Keyword2, Object)"); }

        public Object visit(Keyword3 n) { return unimplementedVisitor("visit(Keyword3)"); }
        public Object visit(Keyword3 n, Object o) { return  unimplementedVisitor("visit(Keyword3, Object)"); }

        public Object visit(Keyword4 n) { return unimplementedVisitor("visit(Keyword4)"); }
        public Object visit(Keyword4 n, Object o) { return  unimplementedVisitor("visit(Keyword4, Object)"); }

        public Object visit(Keyword5 n) { return unimplementedVisitor("visit(Keyword5)"); }
        public Object visit(Keyword5 n, Object o) { return  unimplementedVisitor("visit(Keyword5, Object)"); }

        public Object visit(Keyword6 n) { return unimplementedVisitor("visit(Keyword6)"); }
        public Object visit(Keyword6 n, Object o) { return  unimplementedVisitor("visit(Keyword6, Object)"); }

        public Object visit(Keyword7 n) { return unimplementedVisitor("visit(Keyword7)"); }
        public Object visit(Keyword7 n, Object o) { return  unimplementedVisitor("visit(Keyword7, Object)"); }

        public Object visit(Keyword8 n) { return unimplementedVisitor("visit(Keyword8)"); }
        public Object visit(Keyword8 n, Object o) { return  unimplementedVisitor("visit(Keyword8, Object)"); }

        public Object visit(Keyword9 n) { return unimplementedVisitor("visit(Keyword9)"); }
        public Object visit(Keyword9 n, Object o) { return  unimplementedVisitor("visit(Keyword9, Object)"); }

        public Object visit(Keyword10 n) { return unimplementedVisitor("visit(Keyword10)"); }
        public Object visit(Keyword10 n, Object o) { return  unimplementedVisitor("visit(Keyword10, Object)"); }

        public Object visit(Keyword11 n) { return unimplementedVisitor("visit(Keyword11)"); }
        public Object visit(Keyword11 n, Object o) { return  unimplementedVisitor("visit(Keyword11, Object)"); }

        public Object visit(Keyword12 n) { return unimplementedVisitor("visit(Keyword12)"); }
        public Object visit(Keyword12 n, Object o) { return  unimplementedVisitor("visit(Keyword12, Object)"); }

        public Object visit(Keyword13 n) { return unimplementedVisitor("visit(Keyword13)"); }
        public Object visit(Keyword13 n, Object o) { return  unimplementedVisitor("visit(Keyword13, Object)"); }

        public Object visit(Keyword14 n) { return unimplementedVisitor("visit(Keyword14)"); }
        public Object visit(Keyword14 n, Object o) { return  unimplementedVisitor("visit(Keyword14, Object)"); }

        public Object visit(Keyword15 n) { return unimplementedVisitor("visit(Keyword15)"); }
        public Object visit(Keyword15 n, Object o) { return  unimplementedVisitor("visit(Keyword15, Object)"); }

        public Object visit(Keyword16 n) { return unimplementedVisitor("visit(Keyword16)"); }
        public Object visit(Keyword16 n, Object o) { return  unimplementedVisitor("visit(Keyword16, Object)"); }

        public Object visit(Keyword17 n) { return unimplementedVisitor("visit(Keyword17)"); }
        public Object visit(Keyword17 n, Object o) { return  unimplementedVisitor("visit(Keyword17, Object)"); }

        public Object visit(Keyword18 n) { return unimplementedVisitor("visit(Keyword18)"); }
        public Object visit(Keyword18 n, Object o) { return  unimplementedVisitor("visit(Keyword18, Object)"); }

        public Object visit(Keyword19 n) { return unimplementedVisitor("visit(Keyword19)"); }
        public Object visit(Keyword19 n, Object o) { return  unimplementedVisitor("visit(Keyword19, Object)"); }

        public Object visit(Keyword20 n) { return unimplementedVisitor("visit(Keyword20)"); }
        public Object visit(Keyword20 n, Object o) { return  unimplementedVisitor("visit(Keyword20, Object)"); }

        public Object visit(Keyword21 n) { return unimplementedVisitor("visit(Keyword21)"); }
        public Object visit(Keyword21 n, Object o) { return  unimplementedVisitor("visit(Keyword21, Object)"); }

        public Object visit(Keyword22 n) { return unimplementedVisitor("visit(Keyword22)"); }
        public Object visit(Keyword22 n, Object o) { return  unimplementedVisitor("visit(Keyword22, Object)"); }

        public Object visit(Keyword23 n) { return unimplementedVisitor("visit(Keyword23)"); }
        public Object visit(Keyword23 n, Object o) { return  unimplementedVisitor("visit(Keyword23, Object)"); }

        public Object visit(Keyword24 n) { return unimplementedVisitor("visit(Keyword24)"); }
        public Object visit(Keyword24 n, Object o) { return  unimplementedVisitor("visit(Keyword24, Object)"); }

        public Object visit(Keyword25 n) { return unimplementedVisitor("visit(Keyword25)"); }
        public Object visit(Keyword25 n, Object o) { return  unimplementedVisitor("visit(Keyword25, Object)"); }

        public Object visit(Keyword26 n) { return unimplementedVisitor("visit(Keyword26)"); }
        public Object visit(Keyword26 n, Object o) { return  unimplementedVisitor("visit(Keyword26, Object)"); }

        public Object visit(Keyword27 n) { return unimplementedVisitor("visit(Keyword27)"); }
        public Object visit(Keyword27 n, Object o) { return  unimplementedVisitor("visit(Keyword27, Object)"); }

        public Object visit(Keyword28 n) { return unimplementedVisitor("visit(Keyword28)"); }
        public Object visit(Keyword28 n, Object o) { return  unimplementedVisitor("visit(Keyword28, Object)"); }

        public Object visit(Keyword29 n) { return unimplementedVisitor("visit(Keyword29)"); }
        public Object visit(Keyword29 n, Object o) { return  unimplementedVisitor("visit(Keyword29, Object)"); }

        public Object visit(Keyword30 n) { return unimplementedVisitor("visit(Keyword30)"); }
        public Object visit(Keyword30 n, Object o) { return  unimplementedVisitor("visit(Keyword30, Object)"); }

        public Object visit(Keyword31 n) { return unimplementedVisitor("visit(Keyword31)"); }
        public Object visit(Keyword31 n, Object o) { return  unimplementedVisitor("visit(Keyword31, Object)"); }

        public Object visit(Keyword32 n) { return unimplementedVisitor("visit(Keyword32)"); }
        public Object visit(Keyword32 n, Object o) { return  unimplementedVisitor("visit(Keyword32, Object)"); }

        public Object visit(Keyword33 n) { return unimplementedVisitor("visit(Keyword33)"); }
        public Object visit(Keyword33 n, Object o) { return  unimplementedVisitor("visit(Keyword33, Object)"); }

        public Object visit(Keyword34 n) { return unimplementedVisitor("visit(Keyword34)"); }
        public Object visit(Keyword34 n, Object o) { return  unimplementedVisitor("visit(Keyword34, Object)"); }

        public Object visit(Keyword35 n) { return unimplementedVisitor("visit(Keyword35)"); }
        public Object visit(Keyword35 n, Object o) { return  unimplementedVisitor("visit(Keyword35, Object)"); }

        public Object visit(Keyword36 n) { return unimplementedVisitor("visit(Keyword36)"); }
        public Object visit(Keyword36 n, Object o) { return  unimplementedVisitor("visit(Keyword36, Object)"); }

        public Object visit(Keyword37 n) { return unimplementedVisitor("visit(Keyword37)"); }
        public Object visit(Keyword37 n, Object o) { return  unimplementedVisitor("visit(Keyword37, Object)"); }

        public Object visit(Keyword38 n) { return unimplementedVisitor("visit(Keyword38)"); }
        public Object visit(Keyword38 n, Object o) { return  unimplementedVisitor("visit(Keyword38, Object)"); }

        public Object visit(Keyword39 n) { return unimplementedVisitor("visit(Keyword39)"); }
        public Object visit(Keyword39 n, Object o) { return  unimplementedVisitor("visit(Keyword39, Object)"); }

        public Object visit(Keyword40 n) { return unimplementedVisitor("visit(Keyword40)"); }
        public Object visit(Keyword40 n, Object o) { return  unimplementedVisitor("visit(Keyword40, Object)"); }

        public Object visit(Keyword41 n) { return unimplementedVisitor("visit(Keyword41)"); }
        public Object visit(Keyword41 n, Object o) { return  unimplementedVisitor("visit(Keyword41, Object)"); }

        public Object visit(Keyword42 n) { return unimplementedVisitor("visit(Keyword42)"); }
        public Object visit(Keyword42 n, Object o) { return  unimplementedVisitor("visit(Keyword42, Object)"); }

        public Object visit(Keyword43 n) { return unimplementedVisitor("visit(Keyword43)"); }
        public Object visit(Keyword43 n, Object o) { return  unimplementedVisitor("visit(Keyword43, Object)"); }

        public Object visit(Keyword44 n) { return unimplementedVisitor("visit(Keyword44)"); }
        public Object visit(Keyword44 n, Object o) { return  unimplementedVisitor("visit(Keyword44, Object)"); }

        public Object visit(Keyword45 n) { return unimplementedVisitor("visit(Keyword45)"); }
        public Object visit(Keyword45 n, Object o) { return  unimplementedVisitor("visit(Keyword45, Object)"); }

        public Object visit(Keyword46 n) { return unimplementedVisitor("visit(Keyword46)"); }
        public Object visit(Keyword46 n, Object o) { return  unimplementedVisitor("visit(Keyword46, Object)"); }

        public Object visit(Keyword47 n) { return unimplementedVisitor("visit(Keyword47)"); }
        public Object visit(Keyword47 n, Object o) { return  unimplementedVisitor("visit(Keyword47, Object)"); }

        public Object visit(Keyword48 n) { return unimplementedVisitor("visit(Keyword48)"); }
        public Object visit(Keyword48 n, Object o) { return  unimplementedVisitor("visit(Keyword48, Object)"); }

        public Object visit(Keyword49 n) { return unimplementedVisitor("visit(Keyword49)"); }
        public Object visit(Keyword49 n, Object o) { return  unimplementedVisitor("visit(Keyword49, Object)"); }

        public Object visit(Keyword50 n) { return unimplementedVisitor("visit(Keyword50)"); }
        public Object visit(Keyword50 n, Object o) { return  unimplementedVisitor("visit(Keyword50, Object)"); }

        public Object visit(Keyword51 n) { return unimplementedVisitor("visit(Keyword51)"); }
        public Object visit(Keyword51 n, Object o) { return  unimplementedVisitor("visit(Keyword51, Object)"); }

        public Object visit(Keyword52 n) { return unimplementedVisitor("visit(Keyword52)"); }
        public Object visit(Keyword52 n, Object o) { return  unimplementedVisitor("visit(Keyword52, Object)"); }

        public Object visit(Keyword53 n) { return unimplementedVisitor("visit(Keyword53)"); }
        public Object visit(Keyword53 n, Object o) { return  unimplementedVisitor("visit(Keyword53, Object)"); }

        public Object visit(Keyword54 n) { return unimplementedVisitor("visit(Keyword54)"); }
        public Object visit(Keyword54 n, Object o) { return  unimplementedVisitor("visit(Keyword54, Object)"); }

        public Object visit(Keyword55 n) { return unimplementedVisitor("visit(Keyword55)"); }
        public Object visit(Keyword55 n, Object o) { return  unimplementedVisitor("visit(Keyword55, Object)"); }

        public Object visit(Keyword56 n) { return unimplementedVisitor("visit(Keyword56)"); }
        public Object visit(Keyword56 n, Object o) { return  unimplementedVisitor("visit(Keyword56, Object)"); }

        public Object visit(Keyword57 n) { return unimplementedVisitor("visit(Keyword57)"); }
        public Object visit(Keyword57 n, Object o) { return  unimplementedVisitor("visit(Keyword57, Object)"); }

        public Object visit(Keyword58 n) { return unimplementedVisitor("visit(Keyword58)"); }
        public Object visit(Keyword58 n, Object o) { return  unimplementedVisitor("visit(Keyword58, Object)"); }

        public Object visit(Keyword59 n) { return unimplementedVisitor("visit(Keyword59)"); }
        public Object visit(Keyword59 n, Object o) { return  unimplementedVisitor("visit(Keyword59, Object)"); }

        public Object visit(Keyword60 n) { return unimplementedVisitor("visit(Keyword60)"); }
        public Object visit(Keyword60 n, Object o) { return  unimplementedVisitor("visit(Keyword60, Object)"); }

        public Object visit(Keyword61 n) { return unimplementedVisitor("visit(Keyword61)"); }
        public Object visit(Keyword61 n, Object o) { return  unimplementedVisitor("visit(Keyword61, Object)"); }

        public Object visit(Keyword62 n) { return unimplementedVisitor("visit(Keyword62)"); }
        public Object visit(Keyword62 n, Object o) { return  unimplementedVisitor("visit(Keyword62, Object)"); }

        public Object visit(Keyword63 n) { return unimplementedVisitor("visit(Keyword63)"); }
        public Object visit(Keyword63 n, Object o) { return  unimplementedVisitor("visit(Keyword63, Object)"); }

        public Object visit(Keyword64 n) { return unimplementedVisitor("visit(Keyword64)"); }
        public Object visit(Keyword64 n, Object o) { return  unimplementedVisitor("visit(Keyword64, Object)"); }

        public Object visit(Keyword65 n) { return unimplementedVisitor("visit(Keyword65)"); }
        public Object visit(Keyword65 n, Object o) { return  unimplementedVisitor("visit(Keyword65, Object)"); }

        public Object visit(Keyword66 n) { return unimplementedVisitor("visit(Keyword66)"); }
        public Object visit(Keyword66 n, Object o) { return  unimplementedVisitor("visit(Keyword66, Object)"); }

        public Object visit(Keyword67 n) { return unimplementedVisitor("visit(Keyword67)"); }
        public Object visit(Keyword67 n, Object o) { return  unimplementedVisitor("visit(Keyword67, Object)"); }

        public Object visit(Keyword68 n) { return unimplementedVisitor("visit(Keyword68)"); }
        public Object visit(Keyword68 n, Object o) { return  unimplementedVisitor("visit(Keyword68, Object)"); }

        public Object visit(Keyword69 n) { return unimplementedVisitor("visit(Keyword69)"); }
        public Object visit(Keyword69 n, Object o) { return  unimplementedVisitor("visit(Keyword69, Object)"); }

        public Object visit(Keyword70 n) { return unimplementedVisitor("visit(Keyword70)"); }
        public Object visit(Keyword70 n, Object o) { return  unimplementedVisitor("visit(Keyword70, Object)"); }

        public Object visit(Keyword71 n) { return unimplementedVisitor("visit(Keyword71)"); }
        public Object visit(Keyword71 n, Object o) { return  unimplementedVisitor("visit(Keyword71, Object)"); }

        public Object visit(Keyword72 n) { return unimplementedVisitor("visit(Keyword72)"); }
        public Object visit(Keyword72 n, Object o) { return  unimplementedVisitor("visit(Keyword72, Object)"); }

        public Object visit(Keyword73 n) { return unimplementedVisitor("visit(Keyword73)"); }
        public Object visit(Keyword73 n, Object o) { return  unimplementedVisitor("visit(Keyword73, Object)"); }

        public Object visit(Keyword74 n) { return unimplementedVisitor("visit(Keyword74)"); }
        public Object visit(Keyword74 n, Object o) { return  unimplementedVisitor("visit(Keyword74, Object)"); }

        public Object visit(Keyword75 n) { return unimplementedVisitor("visit(Keyword75)"); }
        public Object visit(Keyword75 n, Object o) { return  unimplementedVisitor("visit(Keyword75, Object)"); }

        public Object visit(Keyword76 n) { return unimplementedVisitor("visit(Keyword76)"); }
        public Object visit(Keyword76 n, Object o) { return  unimplementedVisitor("visit(Keyword76, Object)"); }

        public Object visit(Keyword77 n) { return unimplementedVisitor("visit(Keyword77)"); }
        public Object visit(Keyword77 n, Object o) { return  unimplementedVisitor("visit(Keyword77, Object)"); }

        public Object visit(Keyword78 n) { return unimplementedVisitor("visit(Keyword78)"); }
        public Object visit(Keyword78 n, Object o) { return  unimplementedVisitor("visit(Keyword78, Object)"); }

        public Object visit(Keyword79 n) { return unimplementedVisitor("visit(Keyword79)"); }
        public Object visit(Keyword79 n, Object o) { return  unimplementedVisitor("visit(Keyword79, Object)"); }

        public Object visit(Keyword80 n) { return unimplementedVisitor("visit(Keyword80)"); }
        public Object visit(Keyword80 n, Object o) { return  unimplementedVisitor("visit(Keyword80, Object)"); }

        public Object visit(Keyword81 n) { return unimplementedVisitor("visit(Keyword81)"); }
        public Object visit(Keyword81 n, Object o) { return  unimplementedVisitor("visit(Keyword81, Object)"); }

        public Object visit(Keyword82 n) { return unimplementedVisitor("visit(Keyword82)"); }
        public Object visit(Keyword82 n, Object o) { return  unimplementedVisitor("visit(Keyword82, Object)"); }

        public Object visit(Keyword83 n) { return unimplementedVisitor("visit(Keyword83)"); }
        public Object visit(Keyword83 n, Object o) { return  unimplementedVisitor("visit(Keyword83, Object)"); }

        public Object visit(Keyword84 n) { return unimplementedVisitor("visit(Keyword84)"); }
        public Object visit(Keyword84 n, Object o) { return  unimplementedVisitor("visit(Keyword84, Object)"); }

        public Object visit(AttributeArguments0 n) { return unimplementedVisitor("visit(AttributeArguments0)"); }
        public Object visit(AttributeArguments0 n, Object o) { return  unimplementedVisitor("visit(AttributeArguments0, Object)"); }

        public Object visit(AttributeArguments1 n) { return unimplementedVisitor("visit(AttributeArguments1)"); }
        public Object visit(AttributeArguments1 n, Object o) { return  unimplementedVisitor("visit(AttributeArguments1, Object)"); }

        public Object visit(AttributeArguments2 n) { return unimplementedVisitor("visit(AttributeArguments2)"); }
        public Object visit(AttributeArguments2 n, Object o) { return  unimplementedVisitor("visit(AttributeArguments2, Object)"); }

        public Object visit(TypeParameters0 n) { return unimplementedVisitor("visit(TypeParameters0)"); }
        public Object visit(TypeParameters0 n, Object o) { return  unimplementedVisitor("visit(TypeParameters0, Object)"); }

        public Object visit(TypeParameters1 n) { return unimplementedVisitor("visit(TypeParameters1)"); }
        public Object visit(TypeParameters1 n, Object o) { return  unimplementedVisitor("visit(TypeParameters1, Object)"); }

        public Object visit(Constraint0 n) { return unimplementedVisitor("visit(Constraint0)"); }
        public Object visit(Constraint0 n, Object o) { return  unimplementedVisitor("visit(Constraint0, Object)"); }

        public Object visit(Constraint1 n) { return unimplementedVisitor("visit(Constraint1)"); }
        public Object visit(Constraint1 n, Object o) { return  unimplementedVisitor("visit(Constraint1, Object)"); }
    }

    public void ruleAction(int ruleNumber)
    {
        switch (ruleNumber)
        {
 
            //
            // Rule 1:  SemiOpt ::= $Empty
            //
            case 1: {
                setResult(null);
                break;
            } 
            //
            // Rule 2:  SemiOpt ::= ;
            //
            case 2: {
                setResult(
                    new SemiOpt(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 3:  ExternOpt ::= $Empty
            //
            case 3: {
                setResult(null);
                break;
            } 
            //
            // Rule 4:  ExternOpt ::= extern
            //
            case 4: {
                setResult(
                    new ExternOpt(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 5:  NewOpt ::= $Empty
            //
            case 5: {
                setResult(null);
                break;
            } 
            //
            // Rule 6:  NewOpt ::= new
            //
            case 6: {
                setResult(
                    new NewOpt(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 7:  PartialOpt ::= $Empty
            //
            case 7: {
                setResult(null);
                break;
            } 
            //
            // Rule 8:  PartialOpt ::= partial
            //
            case 8: {
                setResult(
                    new PartialOpt(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 9:  IdentifierOpt ::= $Empty
            //
            case 9: {
                setResult(null);
                break;
            } 
            //
            // Rule 10:  IdentifierOpt ::= identifier
            //
            case 10: {
                setResult(
                    new IdentifierOpt(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 11:  Literal ::= BooleanLiteral
            //
            case 11:
                break; 
            //
            // Rule 12:  BooleanLiteral ::= true
            //
            case 12: {
                setResult(
                    new BooleanLiteral0(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 13:  BooleanLiteral ::= false
            //
            case 13: {
                setResult(
                    new BooleanLiteral1(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 14:  CompilationUnit ::= ExternAliasDirectivesOpt UsingDirectivesOpt NamespaceMemberDeclarationsOpt
            //
            case 14: {
                setResult(
                    new CompilationUnit(getLeftIToken(), getRightIToken(),
                                        (IExternAliasDirectivesOpt)getRhsSym(1),
                                        (IUsingDirectivesOpt)getRhsSym(2),
                                        (INamespaceMemberDeclarationsOpt)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 15:  Name ::= identifier TypeArgumentListOpt
            //
            case 15: {
                setResult(
                    new Name0(getLeftIToken(), getRightIToken(),
                              (TypeArgumentList)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 16:  Name ::= Name . identifier TypeArgumentListOpt
            //
            case 16: {
                setResult(
                    new Name1(getLeftIToken(), getRightIToken(),
                              (IName)getRhsSym(1),
                              (TypeArgumentList)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 17:  Name ::= Name :: identifier TypeArgumentListOpt
            //
            case 17: {
                setResult(
                    new Name2(getLeftIToken(), getRightIToken(),
                              (IName)getRhsSym(1),
                              (TypeArgumentList)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 18:  Type ::= SimpleType
            //
            case 18:
                break; 
            //
            // Rule 19:  Type ::= NullableType
            //
            case 19:
                break; 
            //
            // Rule 20:  Type ::= ClassType
            //
            case 20:
                break; 
            //
            // Rule 21:  Type ::= ArrayType
            //
            case 21:
                break; 
            //
            // Rule 22:  Type ::= void
            //
            case 22: {
                setResult(
                    new Type(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 23:  NonNamedType ::= SimpleType
            //
            case 23:
                break; 
            //
            // Rule 24:  NonNamedType ::= NullableType
            //
            case 24:
                break; 
            //
            // Rule 25:  NonNamedType ::= object
            //
            case 25: {
                setResult(
                    new NonNamedType0(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 26:  NonNamedType ::= string
            //
            case 26: {
                setResult(
                    new NonNamedType1(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 27:  NonNamedType ::= ArrayType
            //
            case 27:
                break; 
            //
            // Rule 28:  SimpleType ::= NumericType
            //
            case 28:
                break; 
            //
            // Rule 29:  SimpleType ::= bool
            //
            case 29: {
                setResult(
                    new SimpleType(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 30:  NumericType ::= IntegralType
            //
            case 30:
                break; 
            //
            // Rule 31:  NumericType ::= FloatingPointType
            //
            case 31:
                break; 
            //
            // Rule 32:  NumericType ::= decimal
            //
            case 32: {
                setResult(
                    new NumericType(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 33:  IntegralType ::= sbyte
            //
            case 33: {
                setResult(
                    new IntegralType0(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 34:  IntegralType ::= byte
            //
            case 34: {
                setResult(
                    new IntegralType1(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 35:  IntegralType ::= short
            //
            case 35: {
                setResult(
                    new IntegralType2(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 36:  IntegralType ::= ushort
            //
            case 36: {
                setResult(
                    new IntegralType3(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 37:  IntegralType ::= int
            //
            case 37: {
                setResult(
                    new IntegralType4(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 38:  IntegralType ::= uint
            //
            case 38: {
                setResult(
                    new IntegralType5(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 39:  IntegralType ::= long
            //
            case 39: {
                setResult(
                    new IntegralType6(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 40:  IntegralType ::= ulong
            //
            case 40: {
                setResult(
                    new IntegralType7(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 41:  IntegralType ::= char
            //
            case 41: {
                setResult(
                    new IntegralType8(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 42:  FloatingPointType ::= float
            //
            case 42: {
                setResult(
                    new FloatingPointType0(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 43:  FloatingPointType ::= double
            //
            case 43: {
                setResult(
                    new FloatingPointType1(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 44:  NullableType ::= Type ?
            //
            case 44: {
                setResult(
                    new NullableType(getLeftIToken(), getRightIToken(),
                                     (IType)getRhsSym(1))
                );
                break;
            } 
            //
            // Rule 45:  ClassType ::= Name
            //
            case 45:
                break; 
            //
            // Rule 46:  ClassType ::= object
            //
            case 46: {
                setResult(
                    new ClassType0(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 47:  ClassType ::= string
            //
            case 47: {
                setResult(
                    new ClassType1(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 48:  VariableReference ::= Expression
            //
            case 48:
                break; 
            //
            // Rule 49:  ArgumentListOpt ::= $Empty
            //
            case 49: {
                setResult(null);
                break;
            } 
            //
            // Rule 50:  ArgumentListOpt ::= ArgumentList
            //
            case 50:
                break; 
            //
            // Rule 51:  ArgumentList ::= Argument
            //
            case 51:
                break; 
            //
            // Rule 52:  ArgumentList ::= ArgumentList , Argument
            //
            case 52: {
                setResult(
                    new ArgumentList(getLeftIToken(), getRightIToken(),
                                     (IArgumentList)getRhsSym(1),
                                     (IArgument)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 53:  Argument ::= Expression
            //
            case 53:
                break; 
            //
            // Rule 54:  Argument ::= ref VariableReference
            //
            case 54: {
                setResult(
                    new Argument0(getLeftIToken(), getRightIToken(),
                                  (IVariableReference)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 55:  Argument ::= out VariableReference
            //
            case 55: {
                setResult(
                    new Argument1(getLeftIToken(), getRightIToken(),
                                  (IVariableReference)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 56:  PrimaryExpression ::= ArrayCreationExpression
            //
            case 56:
                break; 
            //
            // Rule 57:  PrimaryExpression ::= PrimaryNoArrayCreationExpression
            //
            case 57:
                break; 
            //
            // Rule 58:  PrimaryExpression ::= Name
            //
            case 58:
                break; 
            //
            // Rule 59:  PrimaryNoArrayCreationExpression ::= Literal
            //
            case 59:
                break; 
            //
            // Rule 60:  PrimaryNoArrayCreationExpression ::= ParenthesizedExpression
            //
            case 60:
                break; 
            //
            // Rule 61:  PrimaryNoArrayCreationExpression ::= MemberAccess
            //
            case 61:
                break; 
            //
            // Rule 62:  PrimaryNoArrayCreationExpression ::= InvocationExpression
            //
            case 62:
                break; 
            //
            // Rule 63:  PrimaryNoArrayCreationExpression ::= ElementAccess
            //
            case 63:
                break; 
            //
            // Rule 64:  PrimaryNoArrayCreationExpression ::= ThisAccess
            //
            case 64:
                break; 
            //
            // Rule 65:  PrimaryNoArrayCreationExpression ::= BaseAccess
            //
            case 65:
                break; 
            //
            // Rule 66:  PrimaryNoArrayCreationExpression ::= PostIncrementExpression
            //
            case 66:
                break; 
            //
            // Rule 67:  PrimaryNoArrayCreationExpression ::= PostDecrementExpression
            //
            case 67:
                break; 
            //
            // Rule 68:  PrimaryNoArrayCreationExpression ::= ObjectCreationExpression
            //
            case 68:
                break; 
            //
            // Rule 69:  PrimaryNoArrayCreationExpression ::= TypeofExpression
            //
            case 69:
                break; 
            //
            // Rule 70:  PrimaryNoArrayCreationExpression ::= CheckedExpression
            //
            case 70:
                break; 
            //
            // Rule 71:  PrimaryNoArrayCreationExpression ::= UncheckedExpression
            //
            case 71:
                break; 
            //
            // Rule 72:  PrimaryNoArrayCreationExpression ::= DefaultValueExpression
            //
            case 72:
                break; 
            //
            // Rule 73:  PrimaryNoArrayCreationExpression ::= AnonymousMethodExpression
            //
            case 73:
                break; 
            //
            // Rule 74:  ParenthesizedExpression ::= ( Expression )
            //
            case 74: {
                setResult(
                    new ParenthesizedExpression(getLeftIToken(), getRightIToken(),
                                                (IExpression)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 75:  MemberAccess ::= ArrayCreationExpression . identifier TypeArgumentListOpt
            //
            case 75: {
                setResult(
                    new MemberAccess0(getLeftIToken(), getRightIToken(),
                                      (IArrayCreationExpression)getRhsSym(1),
                                      (TypeArgumentList)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 76:  MemberAccess ::= PrimaryNoArrayCreationExpression . identifier TypeArgumentListOpt
            //
            case 76: {
                setResult(
                    new MemberAccess1(getLeftIToken(), getRightIToken(),
                                      (IPrimaryNoArrayCreationExpression)getRhsSym(1),
                                      (TypeArgumentList)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 77:  MemberAccess ::= PredefinedType . identifier TypeArgumentListOpt
            //
            case 77: {
                setResult(
                    new MemberAccess2(getLeftIToken(), getRightIToken(),
                                      (IPredefinedType)getRhsSym(1),
                                      (TypeArgumentList)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 78:  PredefinedType ::= bool
            //
            case 78: {
                setResult(
                    new PredefinedType0(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 79:  PredefinedType ::= byte
            //
            case 79: {
                setResult(
                    new PredefinedType1(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 80:  PredefinedType ::= char
            //
            case 80: {
                setResult(
                    new PredefinedType2(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 81:  PredefinedType ::= decimal
            //
            case 81: {
                setResult(
                    new PredefinedType3(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 82:  PredefinedType ::= double
            //
            case 82: {
                setResult(
                    new PredefinedType4(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 83:  PredefinedType ::= float
            //
            case 83: {
                setResult(
                    new PredefinedType5(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 84:  PredefinedType ::= int
            //
            case 84: {
                setResult(
                    new PredefinedType6(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 85:  PredefinedType ::= long
            //
            case 85: {
                setResult(
                    new PredefinedType7(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 86:  PredefinedType ::= object
            //
            case 86: {
                setResult(
                    new PredefinedType8(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 87:  PredefinedType ::= sbyte
            //
            case 87: {
                setResult(
                    new PredefinedType9(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 88:  PredefinedType ::= short
            //
            case 88: {
                setResult(
                    new PredefinedType10(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 89:  PredefinedType ::= string
            //
            case 89: {
                setResult(
                    new PredefinedType11(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 90:  PredefinedType ::= uint
            //
            case 90: {
                setResult(
                    new PredefinedType12(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 91:  PredefinedType ::= ulong
            //
            case 91: {
                setResult(
                    new PredefinedType13(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 92:  PredefinedType ::= ushort
            //
            case 92: {
                setResult(
                    new PredefinedType14(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 93:  InvocationExpression ::= PrimaryExpression ( ArgumentListOpt )
            //
            case 93: {
                setResult(
                    new InvocationExpression(getLeftIToken(), getRightIToken(),
                                             (IPrimaryExpression)getRhsSym(1),
                                             (IArgumentListOpt)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 94:  ElementAccess ::= PrimaryNoArrayCreationExpression [ ExpressionList ]
            //
            case 94: {
                setResult(
                    new ElementAccess(getLeftIToken(), getRightIToken(),
                                      (IPrimaryNoArrayCreationExpression)getRhsSym(1),
                                      (IExpressionList)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 95:  ExpressionList ::= Expression
            //
            case 95:
                break; 
            //
            // Rule 96:  ExpressionList ::= ExpressionList , Expression
            //
            case 96: {
                setResult(
                    new ExpressionList(getLeftIToken(), getRightIToken(),
                                       (IExpressionList)getRhsSym(1),
                                       (IExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 97:  ThisAccess ::= this
            //
            case 97: {
                setResult(
                    new ThisAccess(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 98:  BaseAccess ::= base . identifier TypeArgumentListOpt
            //
            case 98: {
                setResult(
                    new BaseAccess0(getLeftIToken(), getRightIToken(),
                                    (TypeArgumentList)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 99:  BaseAccess ::= base [ ExpressionList ]
            //
            case 99: {
                setResult(
                    new BaseAccess1(getLeftIToken(), getRightIToken(),
                                    (IExpressionList)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 100:  PostIncrementExpression ::= PrimaryExpression ++
            //
            case 100: {
                setResult(
                    new PostIncrementExpression(getLeftIToken(), getRightIToken(),
                                                (IPrimaryExpression)getRhsSym(1))
                );
                break;
            } 
            //
            // Rule 101:  PostDecrementExpression ::= PrimaryExpression --
            //
            case 101: {
                setResult(
                    new PostDecrementExpression(getLeftIToken(), getRightIToken(),
                                                (IPrimaryExpression)getRhsSym(1))
                );
                break;
            } 
            //
            // Rule 102:  ObjectCreationExpression ::= new Type ( ArgumentListOpt )
            //
            case 102: {
                setResult(
                    new ObjectCreationExpression(getLeftIToken(), getRightIToken(),
                                                 (IType)getRhsSym(2),
                                                 (IArgumentListOpt)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 103:  ArrayCreationExpression ::= new NonArrayType [ ExpressionList ] RankSpecifiersOpt ArrayInitializerOpt
            //
            case 103: {
                setResult(
                    new ArrayCreationExpression0(getLeftIToken(), getRightIToken(),
                                                 (INonArrayType)getRhsSym(2),
                                                 (IExpressionList)getRhsSym(4),
                                                 (IRankSpecifiersOpt)getRhsSym(6),
                                                 (IArrayInitializerOpt)getRhsSym(7))
                );
                break;
            } 
            //
            // Rule 104:  ArrayCreationExpression ::= new ArrayType ArrayInitializer
            //
            case 104: {
                setResult(
                    new ArrayCreationExpression1(getLeftIToken(), getRightIToken(),
                                                 (ArrayType)getRhsSym(2),
                                                 (IArrayInitializer)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 105:  TypeofExpression ::= typeof ( Type )
            //
            case 105: {
                setResult(
                    new TypeofExpression0(getLeftIToken(), getRightIToken(),
                                          (IType)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 106:  TypeofExpression ::= typeof ( UnboundTypeName )
            //
            case 106: {
                setResult(
                    new TypeofExpression1(getLeftIToken(), getRightIToken(),
                                          (IUnboundTypeName)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 107:  UnboundTypeName ::= identifier GenericDimensionSpecifierOpt
            //
            case 107: {
                setResult(
                    new UnboundTypeName0(getLeftIToken(), getRightIToken(),
                                         (GenericDimensionSpecifier)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 108:  UnboundTypeName ::= identifier :: identifier GenericDimensionSpecifierOpt
            //
            case 108: {
                setResult(
                    new UnboundTypeName1(getLeftIToken(), getRightIToken(),
                                         (GenericDimensionSpecifier)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 109:  UnboundTypeName ::= UnboundTypeName . identifier GenericDimensionSpecifierOpt
            //
            case 109: {
                setResult(
                    new UnboundTypeName2(getLeftIToken(), getRightIToken(),
                                         (IUnboundTypeName)getRhsSym(1),
                                         (GenericDimensionSpecifier)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 110:  GenericDimensionSpecifierOpt ::= $Empty
            //
            case 110: {
                setResult(null);
                break;
            } 
            //
            // Rule 111:  GenericDimensionSpecifierOpt ::= GenericDimensionSpecifier
            //
            case 111:
                break; 
            //
            // Rule 112:  GenericDimensionSpecifier ::= < CommasOpt >
            //
            case 112: {
                setResult(
                    new GenericDimensionSpecifier(getLeftIToken(), getRightIToken(),
                                                  (ICommasOpt)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 113:  CommasOpt ::= $Empty
            //
            case 113: {
                setResult(null);
                break;
            } 
            //
            // Rule 114:  CommasOpt ::= Commas
            //
            case 114:
                break; 
            //
            // Rule 115:  Commas ::= ,
            //
            case 115: {
                setResult(
                    new Commas0(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 116:  Commas ::= Commas ,
            //
            case 116: {
                setResult(
                    new Commas1(getLeftIToken(), getRightIToken(),
                                (ICommas)getRhsSym(1))
                );
                break;
            } 
            //
            // Rule 117:  CheckedExpression ::= checked ( Expression )
            //
            case 117: {
                setResult(
                    new CheckedExpression(getLeftIToken(), getRightIToken(),
                                          (IExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 118:  UncheckedExpression ::= unchecked ( Expression )
            //
            case 118: {
                setResult(
                    new UncheckedExpression(getLeftIToken(), getRightIToken(),
                                            (IExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 119:  DefaultValueExpression ::= default ( Type )
            //
            case 119: {
                setResult(
                    new DefaultValueExpression(getLeftIToken(), getRightIToken(),
                                               (IType)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 120:  AnonymousMethodExpression ::= delegate AnonymousMethodSignatureOpt Block
            //
            case 120: {
                setResult(
                    new AnonymousMethodExpression(getLeftIToken(), getRightIToken(),
                                                  (AnonymousMethodSignature)getRhsSym(2),
                                                  (Block)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 121:  AnonymousMethodSignatureOpt ::= $Empty
            //
            case 121: {
                setResult(null);
                break;
            } 
            //
            // Rule 122:  AnonymousMethodSignatureOpt ::= AnonymousMethodSignature
            //
            case 122:
                break; 
            //
            // Rule 123:  AnonymousMethodSignature ::= ( AnonymousMethodParameterListOpt )
            //
            case 123: {
                setResult(
                    new AnonymousMethodSignature(getLeftIToken(), getRightIToken(),
                                                 (IAnonymousMethodParameterListOpt)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 124:  AnonymousMethodParameterListOpt ::= $Empty
            //
            case 124: {
                setResult(null);
                break;
            } 
            //
            // Rule 125:  AnonymousMethodParameterListOpt ::= AnonymousMethodParameterList
            //
            case 125:
                break; 
            //
            // Rule 126:  AnonymousMethodParameterList ::= AnonymousMethodParameter
            //
            case 126:
                break; 
            //
            // Rule 127:  AnonymousMethodParameterList ::= AnonymousMethodParameterList , AnonymousMethodParameter
            //
            case 127: {
                setResult(
                    new AnonymousMethodParameterList(getLeftIToken(), getRightIToken(),
                                                     (IAnonymousMethodParameterList)getRhsSym(1),
                                                     (AnonymousMethodParameter)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 128:  AnonymousMethodParameter ::= ParameterModifierOpt Type identifier
            //
            case 128: {
                setResult(
                    new AnonymousMethodParameter(getLeftIToken(), getRightIToken(),
                                                 (IParameterModifierOpt)getRhsSym(1),
                                                 (IType)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 129:  UnaryExpression ::= PrimaryExpression
            //
            case 129:
                break; 
            //
            // Rule 130:  UnaryExpression ::= + UnaryExpression
            //
            case 130: {
                setResult(
                    new UnaryExpression0(getLeftIToken(), getRightIToken(),
                                         (IUnaryExpression)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 131:  UnaryExpression ::= - UnaryExpression
            //
            case 131: {
                setResult(
                    new UnaryExpression1(getLeftIToken(), getRightIToken(),
                                         (IUnaryExpression)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 132:  UnaryExpression ::= ! UnaryExpression
            //
            case 132: {
                setResult(
                    new UnaryExpression2(getLeftIToken(), getRightIToken(),
                                         (IUnaryExpression)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 133:  UnaryExpression ::= ~ UnaryExpression
            //
            case 133: {
                setResult(
                    new UnaryExpression3(getLeftIToken(), getRightIToken(),
                                         (IUnaryExpression)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 134:  UnaryExpression ::= PreIncrementExpression
            //
            case 134:
                break; 
            //
            // Rule 135:  UnaryExpression ::= PreDecrementExpression
            //
            case 135:
                break; 
            //
            // Rule 136:  UnaryExpression ::= CastExpression
            //
            case 136:
                break; 
            //
            // Rule 137:  PreIncrementExpression ::= ++ UnaryExpression
            //
            case 137: {
                setResult(
                    new PreIncrementExpression(getLeftIToken(), getRightIToken(),
                                               (IUnaryExpression)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 138:  PreDecrementExpression ::= -- UnaryExpression
            //
            case 138: {
                setResult(
                    new PreDecrementExpression(getLeftIToken(), getRightIToken(),
                                               (IUnaryExpression)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 139:  CastExpression ::= ( NonNamedType ) UnaryExpression
            //
            case 139: {
                setResult(
                    new CastExpression(getLeftIToken(), getRightIToken(),
                                       (INonNamedType)getRhsSym(2),
                                       (IUnaryExpression)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 140:  MultiplicativeExpression ::= UnaryExpression
            //
            case 140:
                break; 
            //
            // Rule 141:  MultiplicativeExpression ::= MultiplicativeExpression * UnaryExpression
            //
            case 141: {
                setResult(
                    new MultiplicativeExpression0(getLeftIToken(), getRightIToken(),
                                                  (IMultiplicativeExpression)getRhsSym(1),
                                                  (IUnaryExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 142:  MultiplicativeExpression ::= MultiplicativeExpression / UnaryExpression
            //
            case 142: {
                setResult(
                    new MultiplicativeExpression1(getLeftIToken(), getRightIToken(),
                                                  (IMultiplicativeExpression)getRhsSym(1),
                                                  (IUnaryExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 143:  MultiplicativeExpression ::= MultiplicativeExpression % UnaryExpression
            //
            case 143: {
                setResult(
                    new MultiplicativeExpression2(getLeftIToken(), getRightIToken(),
                                                  (IMultiplicativeExpression)getRhsSym(1),
                                                  (IUnaryExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 144:  AdditiveExpression ::= MultiplicativeExpression
            //
            case 144:
                break; 
            //
            // Rule 145:  AdditiveExpression ::= AdditiveExpression + MultiplicativeExpression
            //
            case 145: {
                setResult(
                    new AdditiveExpression0(getLeftIToken(), getRightIToken(),
                                            (IAdditiveExpression)getRhsSym(1),
                                            (IMultiplicativeExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 146:  AdditiveExpression ::= AdditiveExpression - MultiplicativeExpression
            //
            case 146: {
                setResult(
                    new AdditiveExpression1(getLeftIToken(), getRightIToken(),
                                            (IAdditiveExpression)getRhsSym(1),
                                            (IMultiplicativeExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 147:  ShiftExpression ::= AdditiveExpression
            //
            case 147:
                break; 
            //
            // Rule 148:  ShiftExpression ::= ShiftExpression << AdditiveExpression
            //
            case 148: {
                setResult(
                    new ShiftExpression0(getLeftIToken(), getRightIToken(),
                                         (IShiftExpression)getRhsSym(1),
                                         (IAdditiveExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 149:  ShiftExpression ::= ShiftExpression >> AdditiveExpression
            //
            case 149: {
                setResult(
                    new ShiftExpression1(getLeftIToken(), getRightIToken(),
                                         (IShiftExpression)getRhsSym(1),
                                         (IAdditiveExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 150:  RelationalExpression ::= ShiftExpression
            //
            case 150:
                break; 
            //
            // Rule 151:  RelationalExpression ::= RelationalExpression < ShiftExpression
            //
            case 151: {
                setResult(
                    new RelationalExpression0(getLeftIToken(), getRightIToken(),
                                              (IRelationalExpression)getRhsSym(1),
                                              (IShiftExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 152:  RelationalExpression ::= RelationalExpression > ShiftExpression
            //
            case 152: {
                setResult(
                    new RelationalExpression1(getLeftIToken(), getRightIToken(),
                                              (IRelationalExpression)getRhsSym(1),
                                              (IShiftExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 153:  RelationalExpression ::= RelationalExpression <= ShiftExpression
            //
            case 153: {
                setResult(
                    new RelationalExpression2(getLeftIToken(), getRightIToken(),
                                              (IRelationalExpression)getRhsSym(1),
                                              (IShiftExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 154:  RelationalExpression ::= RelationalExpression >= ShiftExpression
            //
            case 154: {
                setResult(
                    new RelationalExpression3(getLeftIToken(), getRightIToken(),
                                              (IRelationalExpression)getRhsSym(1),
                                              (IShiftExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 155:  RelationalExpression ::= RelationalExpression is Type
            //
            case 155: {
                setResult(
                    new RelationalExpression4(getLeftIToken(), getRightIToken(),
                                              (IRelationalExpression)getRhsSym(1),
                                              (IType)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 156:  RelationalExpression ::= RelationalExpression as Type
            //
            case 156: {
                setResult(
                    new RelationalExpression5(getLeftIToken(), getRightIToken(),
                                              (IRelationalExpression)getRhsSym(1),
                                              (IType)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 157:  EqualityExpression ::= RelationalExpression
            //
            case 157:
                break; 
            //
            // Rule 158:  EqualityExpression ::= EqualityExpression == RelationalExpression
            //
            case 158: {
                setResult(
                    new EqualityExpression0(getLeftIToken(), getRightIToken(),
                                            (IEqualityExpression)getRhsSym(1),
                                            (IRelationalExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 159:  EqualityExpression ::= EqualityExpression != RelationalExpression
            //
            case 159: {
                setResult(
                    new EqualityExpression1(getLeftIToken(), getRightIToken(),
                                            (IEqualityExpression)getRhsSym(1),
                                            (IRelationalExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 160:  AndExpression ::= EqualityExpression
            //
            case 160:
                break; 
            //
            // Rule 161:  AndExpression ::= AndExpression & EqualityExpression
            //
            case 161: {
                setResult(
                    new AndExpression(getLeftIToken(), getRightIToken(),
                                      (IAndExpression)getRhsSym(1),
                                      (IEqualityExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 162:  ExclusiveOrExpression ::= AndExpression
            //
            case 162:
                break; 
            //
            // Rule 163:  ExclusiveOrExpression ::= ExclusiveOrExpression ^ AndExpression
            //
            case 163: {
                setResult(
                    new ExclusiveOrExpression(getLeftIToken(), getRightIToken(),
                                              (IExclusiveOrExpression)getRhsSym(1),
                                              (IAndExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 164:  InclusiveOrExpression ::= ExclusiveOrExpression
            //
            case 164:
                break; 
            //
            // Rule 165:  InclusiveOrExpression ::= InclusiveOrExpression | ExclusiveOrExpression
            //
            case 165: {
                setResult(
                    new InclusiveOrExpression(getLeftIToken(), getRightIToken(),
                                              (IInclusiveOrExpression)getRhsSym(1),
                                              (IExclusiveOrExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 166:  ConditionalAndExpression ::= InclusiveOrExpression
            //
            case 166:
                break; 
            //
            // Rule 167:  ConditionalAndExpression ::= ConditionalAndExpression && InclusiveOrExpression
            //
            case 167: {
                setResult(
                    new ConditionalAndExpression(getLeftIToken(), getRightIToken(),
                                                 (IConditionalAndExpression)getRhsSym(1),
                                                 (IInclusiveOrExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 168:  ConditionalOrExpression ::= ConditionalAndExpression
            //
            case 168:
                break; 
            //
            // Rule 169:  ConditionalOrExpression ::= ConditionalOrExpression || ConditionalAndExpression
            //
            case 169: {
                setResult(
                    new ConditionalOrExpression(getLeftIToken(), getRightIToken(),
                                                (IConditionalOrExpression)getRhsSym(1),
                                                (IConditionalAndExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 170:  NullCoalescingExpression ::= ConditionalOrExpression
            //
            case 170:
                break; 
            //
            // Rule 171:  NullCoalescingExpression ::= ConditionalOrExpression ?? NullCoalescingExpression
            //
            case 171: {
                setResult(
                    new NullCoalescingExpression(getLeftIToken(), getRightIToken(),
                                                 (IConditionalOrExpression)getRhsSym(1),
                                                 (INullCoalescingExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 172:  ConditionalExpression ::= NullCoalescingExpression
            //
            case 172:
                break; 
            //
            // Rule 173:  ConditionalExpression ::= NullCoalescingExpression ? Expression : Expression
            //
            case 173: {
                setResult(
                    new ConditionalExpression(getLeftIToken(), getRightIToken(),
                                              (INullCoalescingExpression)getRhsSym(1),
                                              (IExpression)getRhsSym(3),
                                              (IExpression)getRhsSym(5))
                );
                break;
            } 
            //
            // Rule 174:  Assignment ::= UnaryExpression AssignmentOperator Expression
            //
            case 174: {
                setResult(
                    new Assignment(getLeftIToken(), getRightIToken(),
                                   (IUnaryExpression)getRhsSym(1),
                                   (IAssignmentOperator)getRhsSym(2),
                                   (IExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 175:  AssignmentOperator ::= =
            //
            case 175: {
                setResult(
                    new AssignmentOperator0(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 176:  AssignmentOperator ::= +=
            //
            case 176: {
                setResult(
                    new AssignmentOperator1(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 177:  AssignmentOperator ::= -=
            //
            case 177: {
                setResult(
                    new AssignmentOperator2(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 178:  AssignmentOperator ::= *=
            //
            case 178: {
                setResult(
                    new AssignmentOperator3(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 179:  AssignmentOperator ::= /=
            //
            case 179: {
                setResult(
                    new AssignmentOperator4(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 180:  AssignmentOperator ::= %=
            //
            case 180: {
                setResult(
                    new AssignmentOperator5(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 181:  AssignmentOperator ::= &=
            //
            case 181: {
                setResult(
                    new AssignmentOperator6(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 182:  AssignmentOperator ::= |=
            //
            case 182: {
                setResult(
                    new AssignmentOperator7(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 183:  AssignmentOperator ::= ^=
            //
            case 183: {
                setResult(
                    new AssignmentOperator8(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 184:  AssignmentOperator ::= <<=
            //
            case 184: {
                setResult(
                    new AssignmentOperator9(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 185:  AssignmentOperator ::= >>=
            //
            case 185: {
                setResult(
                    new AssignmentOperator10(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 186:  ExpressionOpt ::= $Empty
            //
            case 186: {
                setResult(null);
                break;
            } 
            //
            // Rule 187:  ExpressionOpt ::= Expression
            //
            case 187:
                break; 
            //
            // Rule 188:  Expression ::= ConditionalExpression
            //
            case 188:
                break; 
            //
            // Rule 189:  Expression ::= Assignment
            //
            case 189:
                break; 
            //
            // Rule 190:  ConstantExpression ::= Expression
            //
            case 190:
                break; 
            //
            // Rule 191:  BooleanExpression ::= Expression
            //
            case 191:
                break; 
            //
            // Rule 192:  Statement ::= LabeledStatement
            //
            case 192:
                break; 
            //
            // Rule 193:  Statement ::= DeclarationStatement
            //
            case 193:
                break; 
            //
            // Rule 194:  Statement ::= EmbeddedStatement
            //
            case 194:
                break; 
            //
            // Rule 195:  EmbeddedStatement ::= Block
            //
            case 195:
                break; 
            //
            // Rule 196:  EmbeddedStatement ::= EmptyStatement
            //
            case 196:
                break; 
            //
            // Rule 197:  EmbeddedStatement ::= ExpressionStatement
            //
            case 197:
                break; 
            //
            // Rule 198:  EmbeddedStatement ::= SelectionStatement
            //
            case 198:
                break; 
            //
            // Rule 199:  EmbeddedStatement ::= IterationStatement
            //
            case 199:
                break; 
            //
            // Rule 200:  EmbeddedStatement ::= JumpStatement
            //
            case 200:
                break; 
            //
            // Rule 201:  EmbeddedStatement ::= TryStatement
            //
            case 201:
                break; 
            //
            // Rule 202:  EmbeddedStatement ::= CheckedStatement
            //
            case 202:
                break; 
            //
            // Rule 203:  EmbeddedStatement ::= UncheckedStatement
            //
            case 203:
                break; 
            //
            // Rule 204:  EmbeddedStatement ::= LockStatement
            //
            case 204:
                break; 
            //
            // Rule 205:  EmbeddedStatement ::= UsingStatement
            //
            case 205:
                break; 
            //
            // Rule 206:  EmbeddedStatement ::= YieldStatement
            //
            case 206:
                break; 
            //
            // Rule 207:  Block ::= { StatementListOpt }
            //
            case 207: {
                setResult(
                    new Block(getLeftIToken(), getRightIToken(),
                              (IStatementListOpt)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 208:  StatementListOpt ::= $Empty
            //
            case 208: {
                setResult(null);
                break;
            } 
            //
            // Rule 209:  StatementListOpt ::= StatementList
            //
            case 209:
                break; 
            //
            // Rule 210:  StatementList ::= Statement
            //
            case 210:
                break; 
            //
            // Rule 211:  StatementList ::= StatementList Statement
            //
            case 211: {
                setResult(
                    new StatementList(getLeftIToken(), getRightIToken(),
                                      (IStatementList)getRhsSym(1),
                                      (IStatement)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 212:  EmptyStatement ::= ;
            //
            case 212: {
                setResult(
                    new EmptyStatement(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 213:  LabeledStatement ::= identifier : Statement
            //
            case 213: {
                setResult(
                    new LabeledStatement(getLeftIToken(), getRightIToken(),
                                         (IStatement)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 214:  DeclarationStatement ::= LocalVariableDeclaration ;
            //
            case 214: {
                setResult(
                    new DeclarationStatement0(getLeftIToken(), getRightIToken(),
                                              (LocalVariableDeclaration)getRhsSym(1))
                );
                break;
            } 
            //
            // Rule 215:  DeclarationStatement ::= LocalConstantDeclaration ;
            //
            case 215: {
                setResult(
                    new DeclarationStatement1(getLeftIToken(), getRightIToken(),
                                              (LocalConstantDeclaration)getRhsSym(1))
                );
                break;
            } 
            //
            // Rule 216:  LocalVariableDeclaration ::= Type LocalVariableDeclarators
            //
            case 216: {
                setResult(
                    new LocalVariableDeclaration(getLeftIToken(), getRightIToken(),
                                                 (IType)getRhsSym(1),
                                                 (ILocalVariableDeclarators)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 217:  LocalVariableDeclarators ::= LocalVariableDeclarator
            //
            case 217:
                break; 
            //
            // Rule 218:  LocalVariableDeclarators ::= LocalVariableDeclarators , LocalVariableDeclarator
            //
            case 218: {
                setResult(
                    new LocalVariableDeclarators(getLeftIToken(), getRightIToken(),
                                                 (ILocalVariableDeclarators)getRhsSym(1),
                                                 (ILocalVariableDeclarator)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 219:  LocalVariableDeclarator ::= identifier
            //
            case 219: {
                setResult(
                    new LocalVariableDeclarator0(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 220:  LocalVariableDeclarator ::= identifier = LocalVariableInitializer
            //
            case 220: {
                setResult(
                    new LocalVariableDeclarator1(getLeftIToken(), getRightIToken(),
                                                 (ILocalVariableInitializer)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 221:  LocalVariableInitializer ::= Expression
            //
            case 221:
                break; 
            //
            // Rule 222:  LocalVariableInitializer ::= ArrayInitializer
            //
            case 222:
                break; 
            //
            // Rule 223:  LocalConstantDeclaration ::= const Type ConstantDeclarators
            //
            case 223: {
                setResult(
                    new LocalConstantDeclaration(getLeftIToken(), getRightIToken(),
                                                 (IType)getRhsSym(2),
                                                 (IConstantDeclarators)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 224:  ExpressionStatement ::= StatementExpression ;
            //
            case 224: {
                setResult(
                    new ExpressionStatement(getLeftIToken(), getRightIToken(),
                                            (IStatementExpression)getRhsSym(1))
                );
                break;
            } 
            //
            // Rule 225:  StatementExpression ::= InvocationExpression
            //
            case 225:
                break; 
            //
            // Rule 226:  StatementExpression ::= ObjectCreationExpression
            //
            case 226:
                break; 
            //
            // Rule 227:  StatementExpression ::= Assignment
            //
            case 227:
                break; 
            //
            // Rule 228:  StatementExpression ::= PostIncrementExpression
            //
            case 228:
                break; 
            //
            // Rule 229:  StatementExpression ::= PostDecrementExpression
            //
            case 229:
                break; 
            //
            // Rule 230:  StatementExpression ::= PreIncrementExpression
            //
            case 230:
                break; 
            //
            // Rule 231:  StatementExpression ::= PreDecrementExpression
            //
            case 231:
                break; 
            //
            // Rule 232:  SelectionStatement ::= IfStatement
            //
            case 232:
                break; 
            //
            // Rule 233:  SelectionStatement ::= ElseStatement
            //
            case 233:
                break; 
            //
            // Rule 234:  SelectionStatement ::= SwitchStatement
            //
            case 234:
                break; 
            //
            // Rule 235:  IfStatement ::= if ( BooleanExpression ) EmbeddedStatement
            //
            case 235: {
                setResult(
                    new IfStatement(getLeftIToken(), getRightIToken(),
                                    (IBooleanExpression)getRhsSym(3),
                                    (IEmbeddedStatement)getRhsSym(5))
                );
                break;
            } 
            //
            // Rule 236:  ElseStatement ::= else EmbeddedStatement
            //
            case 236: {
                setResult(
                    new ElseStatement(getLeftIToken(), getRightIToken(),
                                      (IEmbeddedStatement)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 237:  SwitchStatement ::= switch ( Expression ) SwitchBlock
            //
            case 237: {
                setResult(
                    new SwitchStatement(getLeftIToken(), getRightIToken(),
                                        (IExpression)getRhsSym(3),
                                        (SwitchBlock)getRhsSym(5))
                );
                break;
            } 
            //
            // Rule 238:  SwitchBlock ::= { SwitchSectionsOpt }
            //
            case 238: {
                setResult(
                    new SwitchBlock(getLeftIToken(), getRightIToken(),
                                    (ISwitchSectionsOpt)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 239:  SwitchSectionsOpt ::= $Empty
            //
            case 239: {
                setResult(null);
                break;
            } 
            //
            // Rule 240:  SwitchSectionsOpt ::= SwitchSections
            //
            case 240:
                break; 
            //
            // Rule 241:  SwitchSections ::= SwitchSection
            //
            case 241:
                break; 
            //
            // Rule 242:  SwitchSections ::= SwitchSections SwitchSection
            //
            case 242: {
                setResult(
                    new SwitchSections(getLeftIToken(), getRightIToken(),
                                       (ISwitchSections)getRhsSym(1),
                                       (SwitchSection)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 243:  SwitchSection ::= SwitchLabels StatementList
            //
            case 243: {
                setResult(
                    new SwitchSection(getLeftIToken(), getRightIToken(),
                                      (ISwitchLabels)getRhsSym(1),
                                      (IStatementList)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 244:  SwitchLabels ::= SwitchLabel
            //
            case 244:
                break; 
            //
            // Rule 245:  SwitchLabels ::= SwitchLabels SwitchLabel
            //
            case 245: {
                setResult(
                    new SwitchLabels(getLeftIToken(), getRightIToken(),
                                     (ISwitchLabels)getRhsSym(1),
                                     (ISwitchLabel)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 246:  SwitchLabel ::= case ConstantExpression :
            //
            case 246: {
                setResult(
                    new SwitchLabel0(getLeftIToken(), getRightIToken(),
                                     (IConstantExpression)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 247:  SwitchLabel ::= default :
            //
            case 247: {
                setResult(
                    new SwitchLabel1(getLeftIToken(), getRightIToken())
                );
                break;
            } 
            //
            // Rule 248:  IterationStatement ::= WhileStatement
            //
            case 248:
                break; 
            //
            // Rule 249:  IterationStatement ::= DoStatement
            //
            case 249:
                break; 
            //
            // Rule 250:  IterationStatement ::= ForStatement
            //
            case 250:
                break; 
            //
            // Rule 251:  IterationStatement ::= ForeachStatement
            //
            case 251:
                break; 
            //
            // Rule 252:  WhileStatement ::= while ( BooleanExpression ) EmbeddedStatement
            //
            case 252: {
                setResult(
                    new WhileStatement(getLeftIToken(), getRightIToken(),
                                       (IBooleanExpression)getRhsSym(3),
                                       (IEmbeddedStatement)getRhsSym(5))
                );
                break;
            } 
            //
            // Rule 253:  DoStatement ::= do EmbeddedStatement while ( BooleanExpression ) ;
            //
            case 253: {
                setResult(
                    new DoStatement(getLeftIToken(), getRightIToken(),
                                    (IEmbeddedStatement)getRhsSym(2),
                                    (IBooleanExpression)getRhsSym(5))
                );
                break;
            } 
            //
            // Rule 254:  ForStatement ::= for ( ForInitializerOpt ; ForConditionOpt ; ForIteratorOpt ) EmbeddedStatement
            //
            case 254: {
                setResult(
                    new ForStatement(getLeftIToken(), getRightIToken(),
                                     (IForInitializerOpt)getRhsSym(3),
                                     (IForConditionOpt)getRhsSym(5),
                                     (IForIteratorOpt)getRhsSym(7),
                                     (IEmbeddedStatement)getRhsSym(9))
                );
                break;
            } 
            //
            // Rule 255:  ForInitializerOpt ::= $Empty
            //
            case 255: {
                setResult(null);
                break;
            } 
            //
            // Rule 256:  ForInitializerOpt ::= ForInitializer
            //
            case 256:
                break; 
            //
            // Rule 257:  ForInitializer ::= LocalVariableDeclaration
            //
            case 257:
                break; 
            //
            // Rule 258:  ForInitializer ::= StatementExpressionList
            //
            case 258:
                break; 
            //
            // Rule 259:  ForConditionOpt ::= $Empty
            //
            case 259: {
                setResult(null);
                break;
            } 
            //
            // Rule 260:  ForConditionOpt ::= ForCondition
            //
            case 260:
                break; 
            //
            // Rule 261:  ForCondition ::= BooleanExpression
            //
            case 261:
                break; 
            //
            // Rule 262:  ForIteratorOpt ::= $Empty
            //
            case 262: {
                setResult(null);
                break;
            } 
            //
            // Rule 263:  ForIteratorOpt ::= ForIterator
            //
            case 263:
                break; 
            //
            // Rule 264:  ForIterator ::= StatementExpressionList
            //
            case 264:
                break; 
            //
            // Rule 265:  StatementExpressionList ::= StatementExpression
            //
            case 265:
                break; 
            //
            // Rule 266:  StatementExpressionList ::= StatementExpressionList , StatementExpression
            //
            case 266: {
                setResult(
                    new StatementExpressionList(getLeftIToken(), getRightIToken(),
                                                (IStatementExpressionList)getRhsSym(1),
                                                (IStatementExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 267:  ForeachStatement ::= foreach ( Type identifier in Expression ) EmbeddedStatement
            //
            case 267: {
                setResult(
                    new ForeachStatement(getLeftIToken(), getRightIToken(),
                                         (IType)getRhsSym(3),
                                         (IExpression)getRhsSym(6),
                                         (IEmbeddedStatement)getRhsSym(8))
                );
                break;
            } 
            //
            // Rule 268:  JumpStatement ::= BreakStatement
            //
            case 268:
                break; 
            //
            // Rule 269:  JumpStatement ::= ContinueStatement
            //
            case 269:
                break; 
            //
            // Rule 270:  JumpStatement ::= GotoStatement
            //
            case 270:
                break; 
            //
            // Rule 271:  JumpStatement ::= ReturnStatement
            //
            case 271:
                break; 
            //
            // Rule 272:  JumpStatement ::= ThrowStatement
            //
            case 272:
                break; 
            //
            // Rule 273:  BreakStatement ::= break ;
            //
            case 273: {
                setResult(
                    new BreakStatement(getLeftIToken(), getRightIToken())
                );
                break;
            } 
            //
            // Rule 274:  ContinueStatement ::= continue ;
            //
            case 274: {
                setResult(
                    new ContinueStatement(getLeftIToken(), getRightIToken())
                );
                break;
            } 
            //
            // Rule 275:  GotoStatement ::= goto identifier ;
            //
            case 275: {
                setResult(
                    new GotoStatement0(getLeftIToken(), getRightIToken())
                );
                break;
            } 
            //
            // Rule 276:  GotoStatement ::= goto case ConstantExpression ;
            //
            case 276: {
                setResult(
                    new GotoStatement1(getLeftIToken(), getRightIToken(),
                                       (IConstantExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 277:  GotoStatement ::= goto default ;
            //
            case 277: {
                setResult(
                    new GotoStatement2(getLeftIToken(), getRightIToken())
                );
                break;
            } 
            //
            // Rule 278:  ReturnStatement ::= return ExpressionOpt ;
            //
            case 278: {
                setResult(
                    new ReturnStatement(getLeftIToken(), getRightIToken(),
                                        (IExpressionOpt)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 279:  ThrowStatement ::= throw ExpressionOpt ;
            //
            case 279: {
                setResult(
                    new ThrowStatement(getLeftIToken(), getRightIToken(),
                                       (IExpressionOpt)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 280:  TryStatement ::= try Block CatchClauses
            //
            case 280: {
                setResult(
                    new TryStatement0(getLeftIToken(), getRightIToken(),
                                      (Block)getRhsSym(2),
                                      (ICatchClauses)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 281:  TryStatement ::= try Block CatchClausesOpt FinallyClause
            //
            case 281: {
                setResult(
                    new TryStatement1(getLeftIToken(), getRightIToken(),
                                      (Block)getRhsSym(2),
                                      (ICatchClausesOpt)getRhsSym(3),
                                      (FinallyClause)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 282:  CatchClausesOpt ::= $Empty
            //
            case 282: {
                setResult(null);
                break;
            } 
            //
            // Rule 283:  CatchClausesOpt ::= CatchClauses
            //
            case 283:
                break; 
            //
            // Rule 284:  CatchClauses ::= SpecificCatchClauses
            //
            case 284:
                break; 
            //
            // Rule 285:  CatchClauses ::= SpecificCatchClausesOpt GeneralCatchClause
            //
            case 285: {
                setResult(
                    new CatchClauses(getLeftIToken(), getRightIToken(),
                                     (ISpecificCatchClausesOpt)getRhsSym(1),
                                     (GeneralCatchClause)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 286:  SpecificCatchClausesOpt ::= $Empty
            //
            case 286: {
                setResult(null);
                break;
            } 
            //
            // Rule 287:  SpecificCatchClausesOpt ::= SpecificCatchClauses
            //
            case 287:
                break; 
            //
            // Rule 288:  SpecificCatchClauses ::= SpecificCatchClause
            //
            case 288:
                break; 
            //
            // Rule 289:  SpecificCatchClauses ::= SpecificCatchClauses SpecificCatchClause
            //
            case 289: {
                setResult(
                    new SpecificCatchClauses(getLeftIToken(), getRightIToken(),
                                             (ISpecificCatchClauses)getRhsSym(1),
                                             (SpecificCatchClause)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 290:  SpecificCatchClause ::= catch ( ClassType IdentifierOpt ) Block
            //
            case 290: {
                setResult(
                    new SpecificCatchClause(getLeftIToken(), getRightIToken(),
                                            (IClassType)getRhsSym(3),
                                            (IdentifierOpt)getRhsSym(4),
                                            (Block)getRhsSym(6))
                );
                break;
            } 
            //
            // Rule 291:  GeneralCatchClause ::= catch Block
            //
            case 291: {
                setResult(
                    new GeneralCatchClause(getLeftIToken(), getRightIToken(),
                                           (Block)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 292:  FinallyClause ::= finally Block
            //
            case 292: {
                setResult(
                    new FinallyClause(getLeftIToken(), getRightIToken(),
                                      (Block)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 293:  CheckedStatement ::= checked Block
            //
            case 293: {
                setResult(
                    new CheckedStatement(getLeftIToken(), getRightIToken(),
                                         (Block)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 294:  UncheckedStatement ::= unchecked Block
            //
            case 294: {
                setResult(
                    new UncheckedStatement(getLeftIToken(), getRightIToken(),
                                           (Block)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 295:  LockStatement ::= lock ( Expression ) EmbeddedStatement
            //
            case 295: {
                setResult(
                    new LockStatement(getLeftIToken(), getRightIToken(),
                                      (IExpression)getRhsSym(3),
                                      (IEmbeddedStatement)getRhsSym(5))
                );
                break;
            } 
            //
            // Rule 296:  UsingStatement ::= using ( ResourceAcquisition ) EmbeddedStatement
            //
            case 296: {
                setResult(
                    new UsingStatement(getLeftIToken(), getRightIToken(),
                                       (IResourceAcquisition)getRhsSym(3),
                                       (IEmbeddedStatement)getRhsSym(5))
                );
                break;
            } 
            //
            // Rule 297:  ResourceAcquisition ::= LocalVariableDeclaration
            //
            case 297:
                break; 
            //
            // Rule 298:  ResourceAcquisition ::= Expression
            //
            case 298:
                break; 
            //
            // Rule 299:  YieldStatement ::= yield return Expression ;
            //
            case 299: {
                setResult(
                    new YieldStatement0(getLeftIToken(), getRightIToken(),
                                        (IExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 300:  YieldStatement ::= yield break ;
            //
            case 300: {
                setResult(
                    new YieldStatement1(getLeftIToken(), getRightIToken())
                );
                break;
            } 
            //
            // Rule 301:  NamespaceDeclaration ::= namespace Name NamespaceBody SemiOpt
            //
            case 301: {
                setResult(
                    new NamespaceDeclaration(getLeftIToken(), getRightIToken(),
                                             (IName)getRhsSym(2),
                                             (NamespaceBody)getRhsSym(3),
                                             (SemiOpt)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 302:  NamespaceBody ::= { ExternAliasDirectivesOpt UsingDirectivesOpt NamespaceMemberDeclarationsOpt }
            //
            case 302: {
                setResult(
                    new NamespaceBody(getLeftIToken(), getRightIToken(),
                                      (IExternAliasDirectivesOpt)getRhsSym(2),
                                      (IUsingDirectivesOpt)getRhsSym(3),
                                      (INamespaceMemberDeclarationsOpt)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 303:  ExternAliasDirectivesOpt ::= $Empty
            //
            case 303: {
                setResult(null);
                break;
            } 
            //
            // Rule 304:  ExternAliasDirectivesOpt ::= ExternAliasDirectives
            //
            case 304:
                break; 
            //
            // Rule 305:  ExternAliasDirectives ::= ExternAliasDirective
            //
            case 305:
                break; 
            //
            // Rule 306:  ExternAliasDirectives ::= ExternAliasDirectives ExternAliasDirective
            //
            case 306: {
                setResult(
                    new ExternAliasDirectives(getLeftIToken(), getRightIToken(),
                                              (IExternAliasDirectives)getRhsSym(1),
                                              (ExternAliasDirective)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 307:  ExternAliasDirective ::= extern alias identifier ;
            //
            case 307: {
                setResult(
                    new ExternAliasDirective(getLeftIToken(), getRightIToken())
                );
                break;
            } 
            //
            // Rule 308:  UsingDirectivesOpt ::= $Empty
            //
            case 308: {
                setResult(null);
                break;
            } 
            //
            // Rule 309:  UsingDirectivesOpt ::= UsingDirectives
            //
            case 309:
                break; 
            //
            // Rule 310:  UsingDirectives ::= UsingDirective
            //
            case 310:
                break; 
            //
            // Rule 311:  UsingDirectives ::= UsingDirectives UsingDirective
            //
            case 311: {
                setResult(
                    new UsingDirectives(getLeftIToken(), getRightIToken(),
                                        (IUsingDirectives)getRhsSym(1),
                                        (IUsingDirective)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 312:  UsingDirective ::= UsingAliasDirective
            //
            case 312:
                break; 
            //
            // Rule 313:  UsingDirective ::= UsingNamespaceDirective
            //
            case 313:
                break; 
            //
            // Rule 314:  UsingAliasDirective ::= using identifier = Name ;
            //
            case 314: {
                setResult(
                    new UsingAliasDirective(getLeftIToken(), getRightIToken(),
                                            (IName)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 315:  UsingNamespaceDirective ::= using Name ;
            //
            case 315: {
                setResult(
                    new UsingNamespaceDirective(getLeftIToken(), getRightIToken(),
                                                (IName)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 316:  NamespaceMemberDeclarationsOpt ::= $Empty
            //
            case 316: {
                setResult(null);
                break;
            } 
            //
            // Rule 317:  NamespaceMemberDeclarationsOpt ::= NamespaceMemberDeclarations
            //
            case 317:
                break; 
            //
            // Rule 318:  NamespaceMemberDeclarations ::= NamespaceMemberDeclaration
            //
            case 318:
                break; 
            //
            // Rule 319:  NamespaceMemberDeclarations ::= NamespaceMemberDeclarations NamespaceMemberDeclaration
            //
            case 319: {
                setResult(
                    new NamespaceMemberDeclarations(getLeftIToken(), getRightIToken(),
                                                    (INamespaceMemberDeclarations)getRhsSym(1),
                                                    (INamespaceMemberDeclaration)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 320:  NamespaceMemberDeclaration ::= NamespaceDeclaration
            //
            case 320:
                break; 
            //
            // Rule 321:  NamespaceMemberDeclaration ::= TypeDeclaration
            //
            case 321:
                break; 
            //
            // Rule 322:  TypeDeclaration ::= ClassDeclaration
            //
            case 322:
                break; 
            //
            // Rule 323:  TypeDeclaration ::= StructDeclaration
            //
            case 323:
                break; 
            //
            // Rule 324:  TypeDeclaration ::= InterfaceDeclaration
            //
            case 324:
                break; 
            //
            // Rule 325:  TypeDeclaration ::= EnumDeclaration
            //
            case 325:
                break; 
            //
            // Rule 326:  TypeDeclaration ::= DelegateDeclaration
            //
            case 326:
                break; 
            //
            // Rule 327:  ModifiersOpt ::= $Empty
            //
            case 327: {
                setResult(null);
                break;
            } 
            //
            // Rule 328:  ModifiersOpt ::= Modifiers
            //
            case 328:
                break; 
            //
            // Rule 329:  Modifiers ::= Modifier
            //
            case 329:
                break; 
            //
            // Rule 330:  Modifiers ::= Modifiers Modifier
            //
            case 330: {
                setResult(
                    new Modifiers(getLeftIToken(), getRightIToken(),
                                  (IModifiers)getRhsSym(1),
                                  (IModifier)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 331:  Modifier ::= new
            //
            case 331: {
                setResult(
                    new Modifier0(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 332:  Modifier ::= public
            //
            case 332: {
                setResult(
                    new Modifier1(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 333:  Modifier ::= protected
            //
            case 333: {
                setResult(
                    new Modifier2(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 334:  Modifier ::= internal
            //
            case 334: {
                setResult(
                    new Modifier3(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 335:  Modifier ::= private
            //
            case 335: {
                setResult(
                    new Modifier4(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 336:  Modifier ::= abstract
            //
            case 336: {
                setResult(
                    new Modifier5(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 337:  Modifier ::= sealed
            //
            case 337: {
                setResult(
                    new Modifier6(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 338:  Modifier ::= static
            //
            case 338: {
                setResult(
                    new Modifier7(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 339:  Modifier ::= readonly
            //
            case 339: {
                setResult(
                    new Modifier8(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 340:  Modifier ::= volatile
            //
            case 340: {
                setResult(
                    new Modifier9(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 341:  Modifier ::= virtual
            //
            case 341: {
                setResult(
                    new Modifier10(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 342:  Modifier ::= override
            //
            case 342: {
                setResult(
                    new Modifier11(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 343:  Modifier ::= extern
            //
            case 343: {
                setResult(
                    new Modifier12(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 344:  ClassDeclaration ::= AttributesOpt ModifiersOpt PartialOpt class identifier TypeParameterListOpt ClassBaseOpt TypeParameterConstraintsClausesOpt ClassBody SemiOpt
            //
            case 344: {
                setResult(
                    new ClassDeclaration(getLeftIToken(), getRightIToken(),
                                         (IAttributesOpt)getRhsSym(1),
                                         (IModifiersOpt)getRhsSym(2),
                                         (PartialOpt)getRhsSym(3),
                                         (TypeParameterList)getRhsSym(6),
                                         (ClassBaseOpt)getRhsSym(7),
                                         (ITypeParameterConstraintsClausesOpt)getRhsSym(8),
                                         (ClassBody)getRhsSym(9),
                                         (SemiOpt)getRhsSym(10))
                );
                break;
            } 
            //
            // Rule 345:  ClassBaseOpt ::= $Empty
            //
            case 345: {
                setResult(null);
                break;
            } 
            //
            // Rule 346:  ClassBaseOpt ::= : ClassBase
            //
            case 346: {
                setResult(
                    new ClassBaseOpt(getLeftIToken(), getRightIToken(),
                                     (IClassBase)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 347:  ClassBase ::= ClassType
            //
            case 347:
                break; 
            //
            // Rule 348:  ClassBase ::= ClassBase , ClassType
            //
            case 348: {
                setResult(
                    new ClassBase(getLeftIToken(), getRightIToken(),
                                  (IClassBase)getRhsSym(1),
                                  (IClassType)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 349:  ClassBody ::= { ClassMemberDeclarationsOpt }
            //
            case 349: {
                setResult(
                    new ClassBody(getLeftIToken(), getRightIToken(),
                                  (IClassMemberDeclarationsOpt)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 350:  ClassMemberDeclarationsOpt ::= $Empty
            //
            case 350: {
                setResult(null);
                break;
            } 
            //
            // Rule 351:  ClassMemberDeclarationsOpt ::= ClassMemberDeclarations
            //
            case 351:
                break; 
            //
            // Rule 352:  ClassMemberDeclarations ::= ClassMemberDeclaration
            //
            case 352:
                break; 
            //
            // Rule 353:  ClassMemberDeclarations ::= ClassMemberDeclarations ClassMemberDeclaration
            //
            case 353: {
                setResult(
                    new ClassMemberDeclarations(getLeftIToken(), getRightIToken(),
                                                (IClassMemberDeclarations)getRhsSym(1),
                                                (IClassMemberDeclaration)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 354:  ClassMemberDeclaration ::= ConstantDeclaration
            //
            case 354:
                break; 
            //
            // Rule 355:  ClassMemberDeclaration ::= FieldDeclaration
            //
            case 355:
                break; 
            //
            // Rule 356:  ClassMemberDeclaration ::= MethodDeclaration
            //
            case 356:
                break; 
            //
            // Rule 357:  ClassMemberDeclaration ::= PropertyDeclaration
            //
            case 357:
                break; 
            //
            // Rule 358:  ClassMemberDeclaration ::= EventDeclaration
            //
            case 358:
                break; 
            //
            // Rule 359:  ClassMemberDeclaration ::= IndexerDeclaration
            //
            case 359:
                break; 
            //
            // Rule 360:  ClassMemberDeclaration ::= OperatorDeclaration
            //
            case 360:
                break; 
            //
            // Rule 361:  ClassMemberDeclaration ::= ConstructorDeclaration
            //
            case 361:
                break; 
            //
            // Rule 362:  ClassMemberDeclaration ::= FinalizerDeclaration
            //
            case 362:
                break; 
            //
            // Rule 363:  ClassMemberDeclaration ::= TypeDeclaration
            //
            case 363:
                break; 
            //
            // Rule 364:  ConstantDeclaration ::= AttributesOpt ModifiersOpt const Type ConstantDeclarators ;
            //
            case 364: {
                setResult(
                    new ConstantDeclaration(getLeftIToken(), getRightIToken(),
                                            (IAttributesOpt)getRhsSym(1),
                                            (IModifiersOpt)getRhsSym(2),
                                            (IType)getRhsSym(4),
                                            (IConstantDeclarators)getRhsSym(5))
                );
                break;
            } 
            //
            // Rule 365:  ConstantDeclarators ::= ConstantDeclarator
            //
            case 365:
                break; 
            //
            // Rule 366:  ConstantDeclarators ::= ConstantDeclarators , ConstantDeclarator
            //
            case 366: {
                setResult(
                    new ConstantDeclarators(getLeftIToken(), getRightIToken(),
                                            (IConstantDeclarators)getRhsSym(1),
                                            (ConstantDeclarator)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 367:  ConstantDeclarator ::= identifier = ConstantExpression
            //
            case 367: {
                setResult(
                    new ConstantDeclarator(getLeftIToken(), getRightIToken(),
                                           (IConstantExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 368:  FieldDeclaration ::= AttributesOpt ModifiersOpt Type VariableDeclarators ;
            //
            case 368: {
                setResult(
                    new FieldDeclaration(getLeftIToken(), getRightIToken(),
                                         (IAttributesOpt)getRhsSym(1),
                                         (IModifiersOpt)getRhsSym(2),
                                         (IType)getRhsSym(3),
                                         (IVariableDeclarators)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 369:  VariableDeclarators ::= VariableDeclarator
            //
            case 369:
                break; 
            //
            // Rule 370:  VariableDeclarators ::= VariableDeclarators , VariableDeclarator
            //
            case 370: {
                setResult(
                    new VariableDeclarators(getLeftIToken(), getRightIToken(),
                                            (IVariableDeclarators)getRhsSym(1),
                                            (IVariableDeclarator)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 371:  VariableDeclarator ::= identifier
            //
            case 371: {
                setResult(
                    new VariableDeclarator0(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 372:  VariableDeclarator ::= identifier = VariableInitializer
            //
            case 372: {
                setResult(
                    new VariableDeclarator1(getLeftIToken(), getRightIToken(),
                                            (IVariableInitializer)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 373:  VariableInitializer ::= Expression
            //
            case 373:
                break; 
            //
            // Rule 374:  VariableInitializer ::= ArrayInitializer
            //
            case 374:
                break; 
            //
            // Rule 375:  MethodDeclaration ::= MethodHeader MethodBody
            //
            case 375: {
                setResult(
                    new MethodDeclaration(getLeftIToken(), getRightIToken(),
                                          (MethodHeader)getRhsSym(1),
                                          (IMethodBody)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 376:  MethodHeader ::= AttributesOpt ModifiersOpt Type Name TypeParameterListOpt ( FormalParameterListOpt ) TypeParameterConstraintsClausesOpt
            //
            case 376: {
                setResult(
                    new MethodHeader(getLeftIToken(), getRightIToken(),
                                     (IAttributesOpt)getRhsSym(1),
                                     (IModifiersOpt)getRhsSym(2),
                                     (IType)getRhsSym(3),
                                     (IName)getRhsSym(4),
                                     (TypeParameterList)getRhsSym(5),
                                     (IFormalParameterListOpt)getRhsSym(7),
                                     (ITypeParameterConstraintsClausesOpt)getRhsSym(9))
                );
                break;
            } 
            //
            // Rule 377:  MethodBody ::= Block
            //
            case 377:
                break; 
            //
            // Rule 378:  MethodBody ::= ;
            //
            case 378: {
                setResult(
                    new MethodBody(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 379:  FormalParameterListOpt ::= $Empty
            //
            case 379: {
                setResult(null);
                break;
            } 
            //
            // Rule 380:  FormalParameterListOpt ::= FormalParameterList
            //
            case 380:
                break; 
            //
            // Rule 381:  FormalParameterList ::= FixedParameters
            //
            case 381:
                break; 
            //
            // Rule 382:  FormalParameterList ::= FixedParameters , ParameterArray
            //
            case 382: {
                setResult(
                    new FormalParameterList(getLeftIToken(), getRightIToken(),
                                            (IFixedParameters)getRhsSym(1),
                                            (ParameterArray)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 383:  FormalParameterList ::= ParameterArray
            //
            case 383:
                break; 
            //
            // Rule 384:  FixedParameters ::= FixedParameter
            //
            case 384:
                break; 
            //
            // Rule 385:  FixedParameters ::= FixedParameters FixedParameter
            //
            case 385: {
                setResult(
                    new FixedParameters(getLeftIToken(), getRightIToken(),
                                        (IFixedParameters)getRhsSym(1),
                                        (FixedParameter)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 386:  FixedParameter ::= AttributesOpt ParameterModifierOpt Type identifier
            //
            case 386: {
                setResult(
                    new FixedParameter(getLeftIToken(), getRightIToken(),
                                       (IAttributesOpt)getRhsSym(1),
                                       (IParameterModifierOpt)getRhsSym(2),
                                       (IType)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 387:  ParameterModifierOpt ::= $Empty
            //
            case 387: {
                setResult(null);
                break;
            } 
            //
            // Rule 388:  ParameterModifierOpt ::= ParameterModifier
            //
            case 388:
                break; 
            //
            // Rule 389:  ParameterModifier ::= ref
            //
            case 389: {
                setResult(
                    new ParameterModifier0(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 390:  ParameterModifier ::= out
            //
            case 390: {
                setResult(
                    new ParameterModifier1(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 391:  ParameterArray ::= AttributesOpt params ArrayType identifier
            //
            case 391: {
                setResult(
                    new ParameterArray(getLeftIToken(), getRightIToken(),
                                       (IAttributesOpt)getRhsSym(1),
                                       (ArrayType)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 392:  PropertyDeclaration ::= AttributesOpt ModifiersOpt Type Name { AccessorDeclarations }
            //
            case 392: {
                setResult(
                    new PropertyDeclaration(getLeftIToken(), getRightIToken(),
                                            (IAttributesOpt)getRhsSym(1),
                                            (IModifiersOpt)getRhsSym(2),
                                            (IType)getRhsSym(3),
                                            (IName)getRhsSym(4),
                                            (IAccessorDeclarations)getRhsSym(6))
                );
                break;
            } 
            //
            // Rule 393:  AccessorDeclarations ::= GetAccessorDeclaration SetAccessorDeclarationOpt
            //
            case 393: {
                setResult(
                    new AccessorDeclarations0(getLeftIToken(), getRightIToken(),
                                              (GetAccessorDeclaration)getRhsSym(1),
                                              (SetAccessorDeclaration)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 394:  AccessorDeclarations ::= SetAccessorDeclaration GetAccessorDeclarationOpt
            //
            case 394: {
                setResult(
                    new AccessorDeclarations1(getLeftIToken(), getRightIToken(),
                                              (SetAccessorDeclaration)getRhsSym(1),
                                              (GetAccessorDeclaration)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 395:  GetAccessorDeclarationOpt ::= $Empty
            //
            case 395: {
                setResult(null);
                break;
            } 
            //
            // Rule 396:  GetAccessorDeclarationOpt ::= GetAccessorDeclaration
            //
            case 396:
                break; 
            //
            // Rule 397:  GetAccessorDeclaration ::= AttributesOpt AccessorModifierOpt get AccessorBody
            //
            case 397: {
                setResult(
                    new GetAccessorDeclaration(getLeftIToken(), getRightIToken(),
                                               (IAttributesOpt)getRhsSym(1),
                                               (IAccessorModifierOpt)getRhsSym(2),
                                               (IAccessorBody)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 398:  SetAccessorDeclarationOpt ::= $Empty
            //
            case 398: {
                setResult(null);
                break;
            } 
            //
            // Rule 399:  SetAccessorDeclarationOpt ::= SetAccessorDeclaration
            //
            case 399:
                break; 
            //
            // Rule 400:  SetAccessorDeclaration ::= AttributesOpt AccessorModifierOpt set AccessorBody
            //
            case 400: {
                setResult(
                    new SetAccessorDeclaration(getLeftIToken(), getRightIToken(),
                                               (IAttributesOpt)getRhsSym(1),
                                               (IAccessorModifierOpt)getRhsSym(2),
                                               (IAccessorBody)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 401:  AccessorModifierOpt ::= $Empty
            //
            case 401: {
                setResult(null);
                break;
            } 
            //
            // Rule 402:  AccessorModifierOpt ::= AccessorModifier
            //
            case 402:
                break; 
            //
            // Rule 403:  AccessorModifier ::= protected
            //
            case 403: {
                setResult(
                    new AccessorModifier0(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 404:  AccessorModifier ::= internal
            //
            case 404: {
                setResult(
                    new AccessorModifier1(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 405:  AccessorModifier ::= private
            //
            case 405: {
                setResult(
                    new AccessorModifier2(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 406:  AccessorModifier ::= protected internal
            //
            case 406: {
                setResult(
                    new AccessorModifier3(getLeftIToken(), getRightIToken())
                );
                break;
            } 
            //
            // Rule 407:  AccessorModifier ::= internal protected
            //
            case 407: {
                setResult(
                    new AccessorModifier4(getLeftIToken(), getRightIToken())
                );
                break;
            } 
            //
            // Rule 408:  AccessorBody ::= Block
            //
            case 408:
                break; 
            //
            // Rule 409:  AccessorBody ::= ;
            //
            case 409: {
                setResult(
                    new AccessorBody(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 410:  EventDeclaration ::= AttributesOpt ModifiersOpt event Type VariableDeclarators ;
            //
            case 410: {
                setResult(
                    new EventDeclaration0(getLeftIToken(), getRightIToken(),
                                          (IAttributesOpt)getRhsSym(1),
                                          (IModifiersOpt)getRhsSym(2),
                                          (IType)getRhsSym(4),
                                          (IVariableDeclarators)getRhsSym(5))
                );
                break;
            } 
            //
            // Rule 411:  EventDeclaration ::= AttributesOpt ModifiersOpt event Type Name { EventAccessorDeclarations }
            //
            case 411: {
                setResult(
                    new EventDeclaration1(getLeftIToken(), getRightIToken(),
                                          (IAttributesOpt)getRhsSym(1),
                                          (IModifiersOpt)getRhsSym(2),
                                          (IType)getRhsSym(4),
                                          (IName)getRhsSym(5),
                                          (IEventAccessorDeclarations)getRhsSym(7))
                );
                break;
            } 
            //
            // Rule 412:  EventAccessorDeclarations ::= AddAccessorDeclaration RemoveAccessorDeclaration
            //
            case 412: {
                setResult(
                    new EventAccessorDeclarations0(getLeftIToken(), getRightIToken(),
                                                   (AddAccessorDeclaration)getRhsSym(1),
                                                   (RemoveAccessorDeclaration)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 413:  EventAccessorDeclarations ::= RemoveAccessorDeclaration AddAccessorDeclaration
            //
            case 413: {
                setResult(
                    new EventAccessorDeclarations1(getLeftIToken(), getRightIToken(),
                                                   (RemoveAccessorDeclaration)getRhsSym(1),
                                                   (AddAccessorDeclaration)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 414:  AddAccessorDeclaration ::= AttributesOpt add Block
            //
            case 414: {
                setResult(
                    new AddAccessorDeclaration(getLeftIToken(), getRightIToken(),
                                               (IAttributesOpt)getRhsSym(1),
                                               (Block)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 415:  RemoveAccessorDeclaration ::= AttributesOpt remove Block
            //
            case 415: {
                setResult(
                    new RemoveAccessorDeclaration(getLeftIToken(), getRightIToken(),
                                                  (IAttributesOpt)getRhsSym(1),
                                                  (Block)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 416:  IndexerDeclaration ::= AttributesOpt ModifiersOpt IndexerDeclarator { AccessorDeclarations }
            //
            case 416: {
                setResult(
                    new IndexerDeclaration(getLeftIToken(), getRightIToken(),
                                           (IAttributesOpt)getRhsSym(1),
                                           (IModifiersOpt)getRhsSym(2),
                                           (IIndexerDeclarator)getRhsSym(3),
                                           (IAccessorDeclarations)getRhsSym(5))
                );
                break;
            } 
            //
            // Rule 417:  IndexerDeclarator ::= Type this [ FormalParameterList ]
            //
            case 417: {
                setResult(
                    new IndexerDeclarator0(getLeftIToken(), getRightIToken(),
                                           (IType)getRhsSym(1),
                                           (IFormalParameterList)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 418:  IndexerDeclarator ::= Type Name . this [ FormalParameterList ]
            //
            case 418: {
                setResult(
                    new IndexerDeclarator1(getLeftIToken(), getRightIToken(),
                                           (IType)getRhsSym(1),
                                           (IName)getRhsSym(2),
                                           (IFormalParameterList)getRhsSym(6))
                );
                break;
            } 
            //
            // Rule 419:  OperatorDeclaration ::= AttributesOpt ModifiersOpt OperatorDeclarator OperatorBody
            //
            case 419: {
                setResult(
                    new OperatorDeclaration(getLeftIToken(), getRightIToken(),
                                            (IAttributesOpt)getRhsSym(1),
                                            (IModifiersOpt)getRhsSym(2),
                                            (IOperatorDeclarator)getRhsSym(3),
                                            (IOperatorBody)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 420:  OperatorDeclarator ::= SymbolOperatorDeclarator
            //
            case 420:
                break; 
            //
            // Rule 421:  OperatorDeclarator ::= ConversionOperatorDeclarator
            //
            case 421:
                break; 
            //
            // Rule 422:  SymbolOperatorDeclarator ::= Type operator OverloadableOperator ( FormalParameterList )
            //
            case 422: {
                setResult(
                    new SymbolOperatorDeclarator(getLeftIToken(), getRightIToken(),
                                                 (IType)getRhsSym(1),
                                                 (IOverloadableOperator)getRhsSym(3),
                                                 (IFormalParameterList)getRhsSym(5))
                );
                break;
            } 
            //
            // Rule 423:  OverloadableOperator ::= +
            //
            case 423: {
                setResult(
                    new OverloadableOperator0(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 424:  OverloadableOperator ::= -
            //
            case 424: {
                setResult(
                    new OverloadableOperator1(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 425:  OverloadableOperator ::= !
            //
            case 425: {
                setResult(
                    new OverloadableOperator2(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 426:  OverloadableOperator ::= ~
            //
            case 426: {
                setResult(
                    new OverloadableOperator3(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 427:  OverloadableOperator ::= ++
            //
            case 427: {
                setResult(
                    new OverloadableOperator4(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 428:  OverloadableOperator ::= --
            //
            case 428: {
                setResult(
                    new OverloadableOperator5(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 429:  OverloadableOperator ::= true
            //
            case 429: {
                setResult(
                    new OverloadableOperator6(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 430:  OverloadableOperator ::= false
            //
            case 430: {
                setResult(
                    new OverloadableOperator7(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 431:  OverloadableOperator ::= *
            //
            case 431: {
                setResult(
                    new OverloadableOperator8(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 432:  OverloadableOperator ::= /
            //
            case 432: {
                setResult(
                    new OverloadableOperator9(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 433:  OverloadableOperator ::= %
            //
            case 433: {
                setResult(
                    new OverloadableOperator10(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 434:  OverloadableOperator ::= &
            //
            case 434: {
                setResult(
                    new OverloadableOperator11(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 435:  OverloadableOperator ::= |
            //
            case 435: {
                setResult(
                    new OverloadableOperator12(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 436:  OverloadableOperator ::= ^
            //
            case 436: {
                setResult(
                    new OverloadableOperator13(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 437:  OverloadableOperator ::= <<
            //
            case 437: {
                setResult(
                    new OverloadableOperator14(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 438:  OverloadableOperator ::= >>
            //
            case 438: {
                setResult(
                    new OverloadableOperator15(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 439:  OverloadableOperator ::= ==
            //
            case 439: {
                setResult(
                    new OverloadableOperator16(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 440:  OverloadableOperator ::= !=
            //
            case 440: {
                setResult(
                    new OverloadableOperator17(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 441:  OverloadableOperator ::= >
            //
            case 441: {
                setResult(
                    new OverloadableOperator18(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 442:  OverloadableOperator ::= <
            //
            case 442: {
                setResult(
                    new OverloadableOperator19(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 443:  OverloadableOperator ::= >=
            //
            case 443: {
                setResult(
                    new OverloadableOperator20(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 444:  OverloadableOperator ::= <=
            //
            case 444: {
                setResult(
                    new OverloadableOperator21(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 445:  ConversionOperatorDeclarator ::= implicit operator Type ( Type identifier )
            //
            case 445: {
                setResult(
                    new ConversionOperatorDeclarator0(getLeftIToken(), getRightIToken(),
                                                      (IType)getRhsSym(3),
                                                      (IType)getRhsSym(5))
                );
                break;
            } 
            //
            // Rule 446:  ConversionOperatorDeclarator ::= explicit operator Type ( Type identifier )
            //
            case 446: {
                setResult(
                    new ConversionOperatorDeclarator1(getLeftIToken(), getRightIToken(),
                                                      (IType)getRhsSym(3),
                                                      (IType)getRhsSym(5))
                );
                break;
            } 
            //
            // Rule 447:  OperatorBody ::= Block
            //
            case 447:
                break; 
            //
            // Rule 448:  OperatorBody ::= ;
            //
            case 448: {
                setResult(
                    new OperatorBody(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 449:  ConstructorDeclaration ::= AttributesOpt ModifiersOpt ConstructorDeclarator ConstructorBody
            //
            case 449: {
                setResult(
                    new ConstructorDeclaration(getLeftIToken(), getRightIToken(),
                                               (IAttributesOpt)getRhsSym(1),
                                               (IModifiersOpt)getRhsSym(2),
                                               (ConstructorDeclarator)getRhsSym(3),
                                               (IConstructorBody)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 450:  ConstructorDeclarator ::= identifier ( FormalParameterListOpt ) ConstructorInitializerOpt
            //
            case 450: {
                setResult(
                    new ConstructorDeclarator(getLeftIToken(), getRightIToken(),
                                              (IFormalParameterListOpt)getRhsSym(3),
                                              (IConstructorInitializerOpt)getRhsSym(5))
                );
                break;
            } 
            //
            // Rule 451:  ConstructorInitializerOpt ::= $Empty
            //
            case 451: {
                setResult(null);
                break;
            } 
            //
            // Rule 452:  ConstructorInitializerOpt ::= ConstructorInitializer
            //
            case 452:
                break; 
            //
            // Rule 453:  ConstructorInitializer ::= base ( ArgumentListOpt )
            //
            case 453: {
                setResult(
                    new ConstructorInitializer0(getLeftIToken(), getRightIToken(),
                                                (IArgumentListOpt)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 454:  ConstructorInitializer ::= this ( ArgumentListOpt )
            //
            case 454: {
                setResult(
                    new ConstructorInitializer1(getLeftIToken(), getRightIToken(),
                                                (IArgumentListOpt)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 455:  ConstructorBody ::= Block
            //
            case 455:
                break; 
            //
            // Rule 456:  ConstructorBody ::= ;
            //
            case 456: {
                setResult(
                    new ConstructorBody(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 457:  FinalizerDeclaration ::= AttributesOpt ExternOpt ~ identifier ( ) FinalizerBody
            //
            case 457: {
                setResult(
                    new FinalizerDeclaration(getLeftIToken(), getRightIToken(),
                                             (IAttributesOpt)getRhsSym(1),
                                             (ExternOpt)getRhsSym(2),
                                             (IFinalizerBody)getRhsSym(7))
                );
                break;
            } 
            //
            // Rule 458:  FinalizerBody ::= Block
            //
            case 458:
                break; 
            //
            // Rule 459:  FinalizerBody ::= ;
            //
            case 459: {
                setResult(
                    new FinalizerBody(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 460:  StructDeclaration ::= AttributesOpt ModifiersOpt PartialOpt struct identifier TypeParameterListOpt StructInterfacesOpt TypeParameterConstraintsClausesOpt StructBody SemiOpt
            //
            case 460: {
                setResult(
                    new StructDeclaration(getLeftIToken(), getRightIToken(),
                                          (IAttributesOpt)getRhsSym(1),
                                          (IModifiersOpt)getRhsSym(2),
                                          (PartialOpt)getRhsSym(3),
                                          (TypeParameterList)getRhsSym(6),
                                          (StructInterfacesOpt)getRhsSym(7),
                                          (ITypeParameterConstraintsClausesOpt)getRhsSym(8),
                                          (StructBody)getRhsSym(9),
                                          (SemiOpt)getRhsSym(10))
                );
                break;
            } 
            //
            // Rule 461:  StructInterfacesOpt ::= $Empty
            //
            case 461: {
                setResult(null);
                break;
            } 
            //
            // Rule 462:  StructInterfacesOpt ::= : StructInterfaces
            //
            case 462: {
                setResult(
                    new StructInterfacesOpt(getLeftIToken(), getRightIToken(),
                                            (IStructInterfaces)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 463:  StructInterfaces ::= ClassType
            //
            case 463:
                break; 
            //
            // Rule 464:  StructInterfaces ::= StructInterfaces , ClassType
            //
            case 464: {
                setResult(
                    new StructInterfaces(getLeftIToken(), getRightIToken(),
                                         (IStructInterfaces)getRhsSym(1),
                                         (IClassType)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 465:  StructBody ::= { StructMemberDeclarationsOpt }
            //
            case 465: {
                setResult(
                    new StructBody(getLeftIToken(), getRightIToken(),
                                   (IStructMemberDeclarationsOpt)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 466:  StructMemberDeclarationsOpt ::= $Empty
            //
            case 466: {
                setResult(null);
                break;
            } 
            //
            // Rule 467:  StructMemberDeclarationsOpt ::= StructMemberDeclarations
            //
            case 467:
                break; 
            //
            // Rule 468:  StructMemberDeclarations ::= StructMemberDeclaration
            //
            case 468:
                break; 
            //
            // Rule 469:  StructMemberDeclarations ::= StructMemberDeclarations StructMemberDeclaration
            //
            case 469: {
                setResult(
                    new StructMemberDeclarations(getLeftIToken(), getRightIToken(),
                                                 (IStructMemberDeclarations)getRhsSym(1),
                                                 (IStructMemberDeclaration)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 470:  StructMemberDeclaration ::= ConstantDeclaration
            //
            case 470:
                break; 
            //
            // Rule 471:  StructMemberDeclaration ::= FieldDeclaration
            //
            case 471:
                break; 
            //
            // Rule 472:  StructMemberDeclaration ::= MethodDeclaration
            //
            case 472:
                break; 
            //
            // Rule 473:  StructMemberDeclaration ::= PropertyDeclaration
            //
            case 473:
                break; 
            //
            // Rule 474:  StructMemberDeclaration ::= EventDeclaration
            //
            case 474:
                break; 
            //
            // Rule 475:  StructMemberDeclaration ::= IndexerDeclaration
            //
            case 475:
                break; 
            //
            // Rule 476:  StructMemberDeclaration ::= OperatorDeclaration
            //
            case 476:
                break; 
            //
            // Rule 477:  StructMemberDeclaration ::= ConstructorDeclaration
            //
            case 477:
                break; 
            //
            // Rule 478:  StructMemberDeclaration ::= TypeDeclaration
            //
            case 478:
                break; 
            //
            // Rule 479:  ArrayType ::= NonArrayType RankSpecifiers
            //
            case 479: {
                setResult(
                    new ArrayType(getLeftIToken(), getRightIToken(),
                                  (INonArrayType)getRhsSym(1),
                                  (IRankSpecifiers)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 480:  NonArrayType ::= SimpleType
            //
            case 480:
                break; 
            //
            // Rule 481:  NonArrayType ::= NullableType
            //
            case 481:
                break; 
            //
            // Rule 482:  NonArrayType ::= ClassType
            //
            case 482:
                break; 
            //
            // Rule 483:  RankSpecifiersOpt ::= $Empty
            //
            case 483: {
                setResult(null);
                break;
            } 
            //
            // Rule 484:  RankSpecifiersOpt ::= RankSpecifiers
            //
            case 484:
                break; 
            //
            // Rule 485:  RankSpecifiers ::= RankSpecifier
            //
            case 485:
                break; 
            //
            // Rule 486:  RankSpecifiers ::= RankSpecifiers RankSpecifier
            //
            case 486: {
                setResult(
                    new RankSpecifiers(getLeftIToken(), getRightIToken(),
                                       (IRankSpecifiers)getRhsSym(1),
                                       (RankSpecifier)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 487:  RankSpecifier ::= [ DimSeparatorsOpt ]
            //
            case 487: {
                setResult(
                    new RankSpecifier(getLeftIToken(), getRightIToken(),
                                      (IDimSeparatorsOpt)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 488:  DimSeparatorsOpt ::= $Empty
            //
            case 488: {
                setResult(null);
                break;
            } 
            //
            // Rule 489:  DimSeparatorsOpt ::= DimSeparators
            //
            case 489:
                break; 
            //
            // Rule 490:  DimSeparators ::= ,
            //
            case 490: {
                setResult(
                    new DimSeparators0(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 491:  DimSeparators ::= DimSeparators ,
            //
            case 491: {
                setResult(
                    new DimSeparators1(getLeftIToken(), getRightIToken(),
                                       (IDimSeparators)getRhsSym(1))
                );
                break;
            } 
            //
            // Rule 492:  ArrayInitializerOpt ::= $Empty
            //
            case 492: {
                setResult(null);
                break;
            } 
            //
            // Rule 493:  ArrayInitializerOpt ::= ArrayInitializer
            //
            case 493:
                break; 
            //
            // Rule 494:  ArrayInitializer ::= { VariableInitializerListOpt }
            //
            case 494: {
                setResult(
                    new ArrayInitializer0(getLeftIToken(), getRightIToken(),
                                          (IVariableInitializerListOpt)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 495:  ArrayInitializer ::= { VariableInitializerList , }
            //
            case 495: {
                setResult(
                    new ArrayInitializer1(getLeftIToken(), getRightIToken(),
                                          (IVariableInitializerList)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 496:  VariableInitializerListOpt ::= $Empty
            //
            case 496: {
                setResult(null);
                break;
            } 
            //
            // Rule 497:  VariableInitializerListOpt ::= VariableInitializerList
            //
            case 497:
                break; 
            //
            // Rule 498:  VariableInitializerList ::= VariableInitializer
            //
            case 498:
                break; 
            //
            // Rule 499:  VariableInitializerList ::= VariableInitializerList , VariableInitializer
            //
            case 499: {
                setResult(
                    new VariableInitializerList(getLeftIToken(), getRightIToken(),
                                                (IVariableInitializerList)getRhsSym(1),
                                                (IVariableInitializer)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 500:  InterfaceDeclaration ::= AttributesOpt ModifiersOpt PartialOpt interface identifier TypeParameterListOpt InterfaceBaseOpt TypeParameterConstraintsClausesOpt InterfaceBody SemiOpt
            //
            case 500: {
                setResult(
                    new InterfaceDeclaration(getLeftIToken(), getRightIToken(),
                                             (IAttributesOpt)getRhsSym(1),
                                             (IModifiersOpt)getRhsSym(2),
                                             (PartialOpt)getRhsSym(3),
                                             (TypeParameterList)getRhsSym(6),
                                             (IInterfaceBaseOpt)getRhsSym(7),
                                             (ITypeParameterConstraintsClausesOpt)getRhsSym(8),
                                             (InterfaceBody)getRhsSym(9),
                                             (SemiOpt)getRhsSym(10))
                );
                break;
            } 
            //
            // Rule 501:  InterfaceBaseOpt ::= $Empty
            //
            case 501: {
                setResult(null);
                break;
            } 
            //
            // Rule 502:  InterfaceBaseOpt ::= InterfaceBase
            //
            case 502:
                break; 
            //
            // Rule 503:  InterfaceBase ::= Name
            //
            case 503:
                break; 
            //
            // Rule 504:  InterfaceBase ::= InterfaceBase , Name
            //
            case 504: {
                setResult(
                    new InterfaceBase(getLeftIToken(), getRightIToken(),
                                      (IInterfaceBase)getRhsSym(1),
                                      (IName)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 505:  InterfaceBody ::= { InterfaceMemberDeclarationsOpt }
            //
            case 505: {
                setResult(
                    new InterfaceBody(getLeftIToken(), getRightIToken(),
                                      (IInterfaceMemberDeclarationsOpt)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 506:  InterfaceMemberDeclarationsOpt ::= $Empty
            //
            case 506: {
                setResult(null);
                break;
            } 
            //
            // Rule 507:  InterfaceMemberDeclarationsOpt ::= InterfaceMemberDeclarations
            //
            case 507:
                break; 
            //
            // Rule 508:  InterfaceMemberDeclarations ::= InterfaceMemberDeclaration
            //
            case 508:
                break; 
            //
            // Rule 509:  InterfaceMemberDeclarations ::= InterfaceMemberDeclarations InterfaceMemberDeclaration
            //
            case 509: {
                setResult(
                    new InterfaceMemberDeclarations(getLeftIToken(), getRightIToken(),
                                                    (IInterfaceMemberDeclarations)getRhsSym(1),
                                                    (IInterfaceMemberDeclaration)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 510:  InterfaceMemberDeclaration ::= InterfaceMethodDeclaration
            //
            case 510:
                break; 
            //
            // Rule 511:  InterfaceMemberDeclaration ::= InterfacePropertyDeclaration
            //
            case 511:
                break; 
            //
            // Rule 512:  InterfaceMemberDeclaration ::= InterfaceEventDeclaration
            //
            case 512:
                break; 
            //
            // Rule 513:  InterfaceMemberDeclaration ::= InterfaceIndexerDeclaration
            //
            case 513:
                break; 
            //
            // Rule 514:  InterfaceMethodDeclaration ::= AttributesOpt NewOpt Type identifier TypeParameterListOpt ( FormalParameterListOpt ) TypeParameterConstraintsClausesOpt ;
            //
            case 514: {
                setResult(
                    new InterfaceMethodDeclaration(getLeftIToken(), getRightIToken(),
                                                   (IAttributesOpt)getRhsSym(1),
                                                   (NewOpt)getRhsSym(2),
                                                   (IType)getRhsSym(3),
                                                   (TypeParameterList)getRhsSym(5),
                                                   (IFormalParameterListOpt)getRhsSym(7),
                                                   (ITypeParameterConstraintsClausesOpt)getRhsSym(9))
                );
                break;
            } 
            //
            // Rule 515:  InterfacePropertyDeclaration ::= AttributesOpt NewOpt Type identifier { InterfaceAccessors }
            //
            case 515: {
                setResult(
                    new InterfacePropertyDeclaration(getLeftIToken(), getRightIToken(),
                                                     (IAttributesOpt)getRhsSym(1),
                                                     (NewOpt)getRhsSym(2),
                                                     (IType)getRhsSym(3),
                                                     (IInterfaceAccessors)getRhsSym(6))
                );
                break;
            } 
            //
            // Rule 516:  InterfaceAccessors ::= AttributesOpt get ;
            //
            case 516: {
                setResult(
                    new InterfaceAccessors0(getLeftIToken(), getRightIToken(),
                                            (IAttributesOpt)getRhsSym(1))
                );
                break;
            } 
            //
            // Rule 517:  InterfaceAccessors ::= AttributesOpt set ;
            //
            case 517: {
                setResult(
                    new InterfaceAccessors1(getLeftIToken(), getRightIToken(),
                                            (IAttributesOpt)getRhsSym(1))
                );
                break;
            } 
            //
            // Rule 518:  InterfaceAccessors ::= AttributesOpt get ; AttributesOpt set ;
            //
            case 518: {
                setResult(
                    new InterfaceAccessors2(getLeftIToken(), getRightIToken(),
                                            (IAttributesOpt)getRhsSym(1),
                                            (IAttributesOpt)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 519:  InterfaceAccessors ::= AttributesOpt set ; AttributesOpt get ;
            //
            case 519: {
                setResult(
                    new InterfaceAccessors3(getLeftIToken(), getRightIToken(),
                                            (IAttributesOpt)getRhsSym(1),
                                            (IAttributesOpt)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 520:  InterfaceEventDeclaration ::= AttributesOpt NewOpt event Type identifier ;
            //
            case 520: {
                setResult(
                    new InterfaceEventDeclaration(getLeftIToken(), getRightIToken(),
                                                  (IAttributesOpt)getRhsSym(1),
                                                  (NewOpt)getRhsSym(2),
                                                  (IType)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 521:  InterfaceIndexerDeclaration ::= AttributesOpt NewOpt Type this [ FormalParameterList ] { InterfaceAccessors }
            //
            case 521: {
                setResult(
                    new InterfaceIndexerDeclaration(getLeftIToken(), getRightIToken(),
                                                    (IAttributesOpt)getRhsSym(1),
                                                    (NewOpt)getRhsSym(2),
                                                    (IType)getRhsSym(3),
                                                    (IFormalParameterList)getRhsSym(6),
                                                    (IInterfaceAccessors)getRhsSym(9))
                );
                break;
            } 
            //
            // Rule 522:  EnumDeclaration ::= AttributesOpt ModifiersOpt enum identifier EnumBaseOpt EnumBody SemiOpt
            //
            case 522: {
                setResult(
                    new EnumDeclaration(getLeftIToken(), getRightIToken(),
                                        (IAttributesOpt)getRhsSym(1),
                                        (IModifiersOpt)getRhsSym(2),
                                        (EnumBase)getRhsSym(5),
                                        (IEnumBody)getRhsSym(6),
                                        (SemiOpt)getRhsSym(7))
                );
                break;
            } 
            //
            // Rule 523:  EnumBaseOpt ::= $Empty
            //
            case 523: {
                setResult(null);
                break;
            } 
            //
            // Rule 524:  EnumBaseOpt ::= EnumBase
            //
            case 524:
                break; 
            //
            // Rule 525:  EnumBase ::= : IntegralType
            //
            case 525: {
                setResult(
                    new EnumBase(getLeftIToken(), getRightIToken(),
                                 (IIntegralType)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 526:  EnumBody ::= { EnumMemberDeclarationsOpt }
            //
            case 526: {
                setResult(
                    new EnumBody0(getLeftIToken(), getRightIToken(),
                                  (IEnumMemberDeclarationsOpt)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 527:  EnumBody ::= { EnumMemberDeclarations , }
            //
            case 527: {
                setResult(
                    new EnumBody1(getLeftIToken(), getRightIToken(),
                                  (IEnumMemberDeclarations)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 528:  EnumMemberDeclarationsOpt ::= $Empty
            //
            case 528: {
                setResult(null);
                break;
            } 
            //
            // Rule 529:  EnumMemberDeclarationsOpt ::= EnumMemberDeclarations
            //
            case 529:
                break; 
            //
            // Rule 530:  EnumMemberDeclarations ::= EnumMemberDeclaration
            //
            case 530:
                break; 
            //
            // Rule 531:  EnumMemberDeclarations ::= EnumMemberDeclarations , EnumMemberDeclaration
            //
            case 531: {
                setResult(
                    new EnumMemberDeclarations(getLeftIToken(), getRightIToken(),
                                               (IEnumMemberDeclarations)getRhsSym(1),
                                               (IEnumMemberDeclaration)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 532:  EnumMemberDeclaration ::= AttributesOpt identifier
            //
            case 532: {
                setResult(
                    new EnumMemberDeclaration0(getLeftIToken(), getRightIToken(),
                                               (IAttributesOpt)getRhsSym(1))
                );
                break;
            } 
            //
            // Rule 533:  EnumMemberDeclaration ::= AttributesOpt identifier = ConstantExpression
            //
            case 533: {
                setResult(
                    new EnumMemberDeclaration1(getLeftIToken(), getRightIToken(),
                                               (IAttributesOpt)getRhsSym(1),
                                               (IConstantExpression)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 534:  DelegateDeclaration ::= AttributesOpt ModifiersOpt delegate Type identifier TypeParameterListOpt ( FormalParameterListOpt ) TypeParameterConstraintsClausesOpt ;
            //
            case 534: {
                setResult(
                    new DelegateDeclaration(getLeftIToken(), getRightIToken(),
                                            (IAttributesOpt)getRhsSym(1),
                                            (IModifiersOpt)getRhsSym(2),
                                            (IType)getRhsSym(4),
                                            (TypeParameterList)getRhsSym(6),
                                            (IFormalParameterListOpt)getRhsSym(8),
                                            (ITypeParameterConstraintsClausesOpt)getRhsSym(10))
                );
                break;
            } 
            //
            // Rule 535:  AttributesOpt ::= $Empty
            //
            case 535: {
                setResult(null);
                break;
            } 
            //
            // Rule 536:  AttributesOpt ::= Attributes
            //
            case 536:
                break; 
            //
            // Rule 537:  Attributes ::= AttributeSections
            //
            case 537:
                break; 
            //
            // Rule 538:  AttributeSections ::= AttributeSection
            //
            case 538:
                break; 
            //
            // Rule 539:  AttributeSections ::= AttributeSections AttributeSection
            //
            case 539: {
                setResult(
                    new AttributeSections(getLeftIToken(), getRightIToken(),
                                          (IAttributeSections)getRhsSym(1),
                                          (IAttributeSection)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 540:  AttributeSection ::= [ AttributeTargetSpecifierOpt AttributeList ]
            //
            case 540: {
                setResult(
                    new AttributeSection0(getLeftIToken(), getRightIToken(),
                                          (AttributeTargetSpecifier)getRhsSym(2),
                                          (IAttributeList)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 541:  AttributeSection ::= [ AttributeTargetSpecifierOpt AttributeList , ]
            //
            case 541: {
                setResult(
                    new AttributeSection1(getLeftIToken(), getRightIToken(),
                                          (AttributeTargetSpecifier)getRhsSym(2),
                                          (IAttributeList)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 542:  AttributeTargetSpecifierOpt ::= $Empty
            //
            case 542: {
                setResult(null);
                break;
            } 
            //
            // Rule 543:  AttributeTargetSpecifierOpt ::= AttributeTargetSpecifier
            //
            case 543:
                break; 
            //
            // Rule 544:  AttributeTargetSpecifier ::= AttributeTarget :
            //
            case 544: {
                setResult(
                    new AttributeTargetSpecifier(getLeftIToken(), getRightIToken(),
                                                 (IAttributeTarget)getRhsSym(1))
                );
                break;
            } 
            //
            // Rule 545:  AttributeTarget ::= identifier
            //
            case 545: {
                setResult(
                    new AttributeTarget(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 546:  AttributeTarget ::= Keyword
            //
            case 546:
                break; 
            //
            // Rule 547:  Keyword ::= abstract
            //
            case 547: {
                setResult(
                    new Keyword0(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 548:  Keyword ::= add
            //
            case 548: {
                setResult(
                    new Keyword1(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 549:  Keyword ::= alias
            //
            case 549: {
                setResult(
                    new Keyword2(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 550:  Keyword ::= as
            //
            case 550: {
                setResult(
                    new Keyword3(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 551:  Keyword ::= base
            //
            case 551: {
                setResult(
                    new Keyword4(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 552:  Keyword ::= bool
            //
            case 552: {
                setResult(
                    new Keyword5(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 553:  Keyword ::= break
            //
            case 553: {
                setResult(
                    new Keyword6(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 554:  Keyword ::= byte
            //
            case 554: {
                setResult(
                    new Keyword7(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 555:  Keyword ::= case
            //
            case 555: {
                setResult(
                    new Keyword8(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 556:  Keyword ::= catch
            //
            case 556: {
                setResult(
                    new Keyword9(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 557:  Keyword ::= char
            //
            case 557: {
                setResult(
                    new Keyword10(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 558:  Keyword ::= checked
            //
            case 558: {
                setResult(
                    new Keyword11(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 559:  Keyword ::= class
            //
            case 559: {
                setResult(
                    new Keyword12(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 560:  Keyword ::= const
            //
            case 560: {
                setResult(
                    new Keyword13(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 561:  Keyword ::= continue
            //
            case 561: {
                setResult(
                    new Keyword14(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 562:  Keyword ::= decimal
            //
            case 562: {
                setResult(
                    new Keyword15(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 563:  Keyword ::= default
            //
            case 563: {
                setResult(
                    new Keyword16(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 564:  Keyword ::= delegate
            //
            case 564: {
                setResult(
                    new Keyword17(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 565:  Keyword ::= do
            //
            case 565: {
                setResult(
                    new Keyword18(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 566:  Keyword ::= double
            //
            case 566: {
                setResult(
                    new Keyword19(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 567:  Keyword ::= else
            //
            case 567: {
                setResult(
                    new Keyword20(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 568:  Keyword ::= enum
            //
            case 568: {
                setResult(
                    new Keyword21(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 569:  Keyword ::= event
            //
            case 569: {
                setResult(
                    new Keyword22(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 570:  Keyword ::= explicit
            //
            case 570: {
                setResult(
                    new Keyword23(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 571:  Keyword ::= extern
            //
            case 571: {
                setResult(
                    new Keyword24(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 572:  Keyword ::= false
            //
            case 572: {
                setResult(
                    new Keyword25(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 573:  Keyword ::= finally
            //
            case 573: {
                setResult(
                    new Keyword26(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 574:  Keyword ::= fixed
            //
            case 574: {
                setResult(
                    new Keyword27(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 575:  Keyword ::= float
            //
            case 575: {
                setResult(
                    new Keyword28(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 576:  Keyword ::= for
            //
            case 576: {
                setResult(
                    new Keyword29(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 577:  Keyword ::= foreach
            //
            case 577: {
                setResult(
                    new Keyword30(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 578:  Keyword ::= get
            //
            case 578: {
                setResult(
                    new Keyword31(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 579:  Keyword ::= goto
            //
            case 579: {
                setResult(
                    new Keyword32(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 580:  Keyword ::= if
            //
            case 580: {
                setResult(
                    new Keyword33(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 581:  Keyword ::= implicit
            //
            case 581: {
                setResult(
                    new Keyword34(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 582:  Keyword ::= in
            //
            case 582: {
                setResult(
                    new Keyword35(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 583:  Keyword ::= int
            //
            case 583: {
                setResult(
                    new Keyword36(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 584:  Keyword ::= interface
            //
            case 584: {
                setResult(
                    new Keyword37(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 585:  Keyword ::= internal
            //
            case 585: {
                setResult(
                    new Keyword38(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 586:  Keyword ::= is
            //
            case 586: {
                setResult(
                    new Keyword39(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 587:  Keyword ::= lock
            //
            case 587: {
                setResult(
                    new Keyword40(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 588:  Keyword ::= long
            //
            case 588: {
                setResult(
                    new Keyword41(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 589:  Keyword ::= namespace
            //
            case 589: {
                setResult(
                    new Keyword42(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 590:  Keyword ::= new
            //
            case 590: {
                setResult(
                    new Keyword43(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 591:  Keyword ::= null
            //
            case 591: {
                setResult(
                    new Keyword44(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 592:  Keyword ::= object
            //
            case 592: {
                setResult(
                    new Keyword45(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 593:  Keyword ::= operator
            //
            case 593: {
                setResult(
                    new Keyword46(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 594:  Keyword ::= out
            //
            case 594: {
                setResult(
                    new Keyword47(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 595:  Keyword ::= override
            //
            case 595: {
                setResult(
                    new Keyword48(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 596:  Keyword ::= params
            //
            case 596: {
                setResult(
                    new Keyword49(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 597:  Keyword ::= partial
            //
            case 597: {
                setResult(
                    new Keyword50(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 598:  Keyword ::= private
            //
            case 598: {
                setResult(
                    new Keyword51(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 599:  Keyword ::= protected
            //
            case 599: {
                setResult(
                    new Keyword52(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 600:  Keyword ::= public
            //
            case 600: {
                setResult(
                    new Keyword53(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 601:  Keyword ::= readonly
            //
            case 601: {
                setResult(
                    new Keyword54(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 602:  Keyword ::= ref
            //
            case 602: {
                setResult(
                    new Keyword55(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 603:  Keyword ::= remove
            //
            case 603: {
                setResult(
                    new Keyword56(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 604:  Keyword ::= return
            //
            case 604: {
                setResult(
                    new Keyword57(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 605:  Keyword ::= sbyte
            //
            case 605: {
                setResult(
                    new Keyword58(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 606:  Keyword ::= sealed
            //
            case 606: {
                setResult(
                    new Keyword59(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 607:  Keyword ::= set
            //
            case 607: {
                setResult(
                    new Keyword60(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 608:  Keyword ::= short
            //
            case 608: {
                setResult(
                    new Keyword61(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 609:  Keyword ::= sizeof
            //
            case 609: {
                setResult(
                    new Keyword62(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 610:  Keyword ::= stackalloc
            //
            case 610: {
                setResult(
                    new Keyword63(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 611:  Keyword ::= static
            //
            case 611: {
                setResult(
                    new Keyword64(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 612:  Keyword ::= string
            //
            case 612: {
                setResult(
                    new Keyword65(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 613:  Keyword ::= struct
            //
            case 613: {
                setResult(
                    new Keyword66(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 614:  Keyword ::= switch
            //
            case 614: {
                setResult(
                    new Keyword67(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 615:  Keyword ::= this
            //
            case 615: {
                setResult(
                    new Keyword68(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 616:  Keyword ::= throw
            //
            case 616: {
                setResult(
                    new Keyword69(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 617:  Keyword ::= true
            //
            case 617: {
                setResult(
                    new Keyword70(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 618:  Keyword ::= try
            //
            case 618: {
                setResult(
                    new Keyword71(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 619:  Keyword ::= typeof
            //
            case 619: {
                setResult(
                    new Keyword72(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 620:  Keyword ::= uint
            //
            case 620: {
                setResult(
                    new Keyword73(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 621:  Keyword ::= ulong
            //
            case 621: {
                setResult(
                    new Keyword74(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 622:  Keyword ::= unchecked
            //
            case 622: {
                setResult(
                    new Keyword75(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 623:  Keyword ::= unsafe
            //
            case 623: {
                setResult(
                    new Keyword76(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 624:  Keyword ::= ushort
            //
            case 624: {
                setResult(
                    new Keyword77(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 625:  Keyword ::= using
            //
            case 625: {
                setResult(
                    new Keyword78(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 626:  Keyword ::= virtual
            //
            case 626: {
                setResult(
                    new Keyword79(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 627:  Keyword ::= void
            //
            case 627: {
                setResult(
                    new Keyword80(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 628:  Keyword ::= volatile
            //
            case 628: {
                setResult(
                    new Keyword81(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 629:  Keyword ::= where
            //
            case 629: {
                setResult(
                    new Keyword82(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 630:  Keyword ::= while
            //
            case 630: {
                setResult(
                    new Keyword83(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 631:  Keyword ::= yield
            //
            case 631: {
                setResult(
                    new Keyword84(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 632:  AttributeList ::= Attribute
            //
            case 632:
                break; 
            //
            // Rule 633:  AttributeList ::= AttributeList , Attribute
            //
            case 633: {
                setResult(
                    new AttributeList(getLeftIToken(), getRightIToken(),
                                      (IAttributeList)getRhsSym(1),
                                      (Attribute)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 634:  Attribute ::= AttributeName AttributeArgumentsOpt
            //
            case 634: {
                setResult(
                    new Attribute(getLeftIToken(), getRightIToken(),
                                  (IAttributeName)getRhsSym(1),
                                  (IAttributeArgumentsOpt)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 635:  AttributeName ::= Name
            //
            case 635:
                break; 
            //
            // Rule 636:  AttributeArgumentsOpt ::= $Empty
            //
            case 636: {
                setResult(null);
                break;
            } 
            //
            // Rule 637:  AttributeArgumentsOpt ::= AttributeArguments
            //
            case 637:
                break; 
            //
            // Rule 638:  AttributeArguments ::= ( PositionalArgumentListOpt )
            //
            case 638: {
                setResult(
                    new AttributeArguments0(getLeftIToken(), getRightIToken(),
                                            (IPositionalArgumentListOpt)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 639:  AttributeArguments ::= ( PositionalArgumentList , NamedArgumentList )
            //
            case 639: {
                setResult(
                    new AttributeArguments1(getLeftIToken(), getRightIToken(),
                                            (IPositionalArgumentList)getRhsSym(2),
                                            (INamedArgumentList)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 640:  AttributeArguments ::= ( NamedArgumentList )
            //
            case 640: {
                setResult(
                    new AttributeArguments2(getLeftIToken(), getRightIToken(),
                                            (INamedArgumentList)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 641:  PositionalArgumentListOpt ::= $Empty
            //
            case 641: {
                setResult(null);
                break;
            } 
            //
            // Rule 642:  PositionalArgumentListOpt ::= PositionalArgumentList
            //
            case 642:
                break; 
            //
            // Rule 643:  PositionalArgumentList ::= PositionalArgument
            //
            case 643:
                break; 
            //
            // Rule 644:  PositionalArgumentList ::= PositionalArgumentList , PositionalArgument
            //
            case 644: {
                setResult(
                    new PositionalArgumentList(getLeftIToken(), getRightIToken(),
                                               (IPositionalArgumentList)getRhsSym(1),
                                               (IPositionalArgument)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 645:  PositionalArgument ::= AttributeArgumentExpression
            //
            case 645:
                break; 
            //
            // Rule 646:  NamedArgumentList ::= NamedArgument
            //
            case 646:
                break; 
            //
            // Rule 647:  NamedArgumentList ::= NamedArgumentList , NamedArgument
            //
            case 647: {
                setResult(
                    new NamedArgumentList(getLeftIToken(), getRightIToken(),
                                          (INamedArgumentList)getRhsSym(1),
                                          (NamedArgument)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 648:  NamedArgument ::= identifier = AttributeArgumentExpression
            //
            case 648: {
                setResult(
                    new NamedArgument(getLeftIToken(), getRightIToken(),
                                      (IAttributeArgumentExpression)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 649:  AttributeArgumentExpression ::= Expression
            //
            case 649:
                break; 
            //
            // Rule 650:  TypeParameterListOpt ::= $Empty
            //
            case 650: {
                setResult(null);
                break;
            } 
            //
            // Rule 651:  TypeParameterListOpt ::= TypeParameterList
            //
            case 651:
                break; 
            //
            // Rule 652:  TypeParameterList ::= < TypeParameters >
            //
            case 652: {
                setResult(
                    new TypeParameterList(getLeftIToken(), getRightIToken(),
                                          (ITypeParameters)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 653:  TypeParameters ::= AttributesOpt TypeParameter
            //
            case 653: {
                setResult(
                    new TypeParameters0(getLeftIToken(), getRightIToken(),
                                        (IAttributesOpt)getRhsSym(1),
                                        (TypeParameter)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 654:  TypeParameters ::= TypeParameters , AttributesOpt TypeParameter
            //
            case 654: {
                setResult(
                    new TypeParameters1(getLeftIToken(), getRightIToken(),
                                        (ITypeParameters)getRhsSym(1),
                                        (IAttributesOpt)getRhsSym(3),
                                        (TypeParameter)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 655:  TypeParameter ::= identifier
            //
            case 655: {
                setResult(
                    new TypeParameter(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 656:  TypeArgumentListOpt ::= $Empty
            //
            case 656: {
                setResult(null);
                break;
            } 
            //
            // Rule 657:  TypeArgumentListOpt ::= TypeArgumentList
            //
            case 657:
                break; 
            //
            // Rule 658:  TypeArgumentList ::= < TypeArguments >
            //
            case 658: {
                setResult(
                    new TypeArgumentList(getLeftIToken(), getRightIToken(),
                                         (ITypeArguments)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 659:  TypeArguments ::= TypeArgument
            //
            case 659:
                break; 
            //
            // Rule 660:  TypeArguments ::= TypeArguments , TypeArgument
            //
            case 660: {
                setResult(
                    new TypeArguments(getLeftIToken(), getRightIToken(),
                                      (ITypeArguments)getRhsSym(1),
                                      (ITypeArgument)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 661:  TypeArgument ::= Type
            //
            case 661:
                break; 
            //
            // Rule 662:  TypeParameterConstraintsClausesOpt ::= $Empty
            //
            case 662: {
                setResult(null);
                break;
            } 
            //
            // Rule 663:  TypeParameterConstraintsClausesOpt ::= TypeParameterConstraintsClauses
            //
            case 663:
                break; 
            //
            // Rule 664:  TypeParameterConstraintsClauses ::= TypeParameterConstraintsClause
            //
            case 664:
                break; 
            //
            // Rule 665:  TypeParameterConstraintsClauses ::= TypeParameterConstraintsClauses TypeParameterConstraintsClause
            //
            case 665: {
                setResult(
                    new TypeParameterConstraintsClauses(getLeftIToken(), getRightIToken(),
                                                        (ITypeParameterConstraintsClauses)getRhsSym(1),
                                                        (TypeParameterConstraintsClause)getRhsSym(2))
                );
                break;
            } 
            //
            // Rule 666:  TypeParameterConstraintsClause ::= where TypeParameter : TypeParameterConstraints
            //
            case 666: {
                setResult(
                    new TypeParameterConstraintsClause(getLeftIToken(), getRightIToken(),
                                                       (TypeParameter)getRhsSym(2),
                                                       (ITypeParameterConstraints)getRhsSym(4))
                );
                break;
            } 
            //
            // Rule 667:  TypeParameterConstraints ::= Constraints
            //
            case 667:
                break; 
            //
            // Rule 668:  TypeParameterConstraints ::= ConstructorConstraint
            //
            case 668:
                break; 
            //
            // Rule 669:  TypeParameterConstraints ::= Constraint , ConstructorConstraint
            //
            case 669: {
                setResult(
                    new TypeParameterConstraints(getLeftIToken(), getRightIToken(),
                                                 (IConstraint)getRhsSym(1),
                                                 (ConstructorConstraint)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 670:  Constraints ::= Constraint
            //
            case 670:
                break; 
            //
            // Rule 671:  Constraints ::= Constraints , Constraint
            //
            case 671: {
                setResult(
                    new Constraints(getLeftIToken(), getRightIToken(),
                                    (IConstraints)getRhsSym(1),
                                    (IConstraint)getRhsSym(3))
                );
                break;
            } 
            //
            // Rule 672:  Constraint ::= ClassType
            //
            case 672:
                break; 
            //
            // Rule 673:  Constraint ::= class
            //
            case 673: {
                setResult(
                    new Constraint0(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 674:  Constraint ::= struct
            //
            case 674: {
                setResult(
                    new Constraint1(getRhsIToken(1))
                );
                break;
            } 
            //
            // Rule 675:  ConstructorConstraint ::= new ( )
            //
            case 675: {
                setResult(
                    new ConstructorConstraint(getLeftIToken(), getRightIToken())
                );
                break;
            }
    
            default:
                break;
        }
        return;
    }
}

