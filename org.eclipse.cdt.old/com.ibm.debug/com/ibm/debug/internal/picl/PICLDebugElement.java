package com.ibm.debug.internal.picl;

////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2001, 2002 International Business Machines Corporation. All rights reserved.
// This program and the accompanying materials are made available under the terms of
// the Common Public License which accompanies this distribution.
//
// com/ibm/debug/internal/picl/PICLDebugElement.java, eclipse, eclipse-dev, 20011129
// Version 1.22 (last modified 11/29/01 14:15:43)
////////////////////////////////////////////////////////////////////////////////

/**
 * Note: This class/interface is part of an interim API that is still under
 * development and expected to change significantly before reaching stability.
 * It is being made available at this early stage to solicit feedback from
 * pioneering adopters on the understanding that any code that uses this API
 * will almost certainly be broken (repeatedly) as the API evolves.
 */

import com.ibm.debug.model.DebugEngine;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.eclipse.core.runtime.PlatformObject;
import org.eclipse.debug.core.DebugEvent;
import org.eclipse.debug.core.DebugException;
import org.eclipse.debug.core.DebugPlugin;
import org.eclipse.debug.core.IBreakpointManager;
import org.eclipse.debug.core.ILaunch;
import org.eclipse.debug.core.model.IDebugElement;
import org.eclipse.debug.core.model.IDebugTarget;
import org.eclipse.debug.core.model.IProcess;
import org.eclipse.debug.core.model.ISourceLocator;
import org.eclipse.debug.core.model.IStackFrame;
import org.eclipse.debug.core.model.IThread;
import org.eclipse.debug.internal.core.DebugCoreUtils;
/**
 * Provides a default implementation for <code>IDebugElement</code>.
 * <p>Note that the code assumes that all the <code>IDebugElement</code>s in
 * the hierarchy are <code>DebugElement</code>s (i.e. you can't mix
 * <code>DebugElement</code>s and other implementations of <code>IDebugElement</code>
 * in the same tree).
 */
public abstract class PICLDebugElement extends PlatformObject implements IDebugElement {

	/**
	 * Register group type.
	 * TODO: This should be moved to IDebugElement
	 * @see IRegisterGroup
	 */
	public static final int REGISTER_GROUP = 0x0014;

	/**
	 * Register type.
	 * TODO: This should be moved to IDebugElement
	 * @see IRegister
	 */
	public static final int REGISTER = 0x0018;

	/**
	 * Register group parent type.
	 * TODO: This should be moved to IDebugElement
	 */
	public static final int REGISTER_GROUP_PARENT = 0x0020;

	/**
	 * Module type.
	 * TODO: This should be moved to IDebugElement
	 */
	public static final int MODULE = 0x0021;

	/**
	 * Part/object/compile unit type.
	 * TODO: This should be moved to IDebugElement
	 */
	public static final int PART = 0x0022;

	/**
	 * Module parent type.
	 * TODO: This should be moved to IDebugElement
	 */
	public static final int MODULE_PARENT = 0x0024;

	/**
	 * Monitor parent type.
	 * TODO: This should be moved to IDebugElement
	 */
	public static final int MONITOR_PARENT = 0x0028;

	/**
	 * Storage parent type.
	 * TODO: This should be moved to IDebugElement
	 */
	public static final int STORAGE_PARENT = 0x0030;

	/**
	 * Storage monitor type.
	 * TODO: This should be moved to IDebugElement
	 */
	public static final int STORAGE = 0x0031;

	/**
	 * File in a debuggable part type.
	 * TODO: This should be moved to IDebugElement
	 */
	public static final int VIEWFILE = 0x0032;

	/**
	 * Function type.
	 * TODO: This should be moved to IDebugElement
	 */
	public static final int FUNCTION = 0x0034;



	// Resource String keys
	private static final String DEBUG_ELEMENT= "debug_element.";
	private static final String DEBUG_TARGET= DEBUG_ELEMENT + "debug_target";
	private static final String STACK_FRAME= DEBUG_ELEMENT + "stack_frame";
	private static final String VARIABLE= DEBUG_ELEMENT + "variable";
	private static final String THREAD= DEBUG_ELEMENT + "thread";
	private static final String UNKNOWN= DEBUG_ELEMENT + "unknown";
	protected static final String COMM_FAILURE= "picl.common.comm_failure";


	/**
	 * Shared, immutable empty collection used for efficiency.
	 */
	protected static List fgEmptyChildren= Collections.EMPTY_LIST;
	/**
	 * This element's parent, or <code>null</code> if this
	 * element does not have a parent.
	 */
	protected IDebugElement fParent= null;
	/**
	 * A collection of the children of this element.
	 */
	protected List fChildren= null;
	/**
	 * This element's type - one of the constants defined
	 * in <code>IDebugElementTypeConstants</code>.
	 */
	protected int fType= 0;

	/**
	 * Flag that tracks if <code>doCleanup()</code> has been called on this debug element.
	 */
	protected boolean fDoneCleanup= false;

	/**
	 * The latest exception generated by a request
	 */
	protected DebugException fRequestException = null;

	/**
	 * Creates a <code>PICLDebugElement</code> with the given parent and type.
	 */
	public PICLDebugElement(IDebugElement parent, int type) {
		super();
		fChildren= fgEmptyChildren;
		fType= type;
		fParent= parent;
	}

	/**
	 * Adds this child to the collection of children for this element.
	 * Fires a creation event for the child.
	 */
	public void addChild(IDebugElement child) {
		boolean added= false;
		if (fChildren == fgEmptyChildren) {
			fChildren= new ArrayList();
			fChildren.add(child);
			added= true;
		} else {
			if (!fChildren.contains(child)) {
				fChildren.add(child);
				added= true;
			}
		}

		if (added) {
			((PICLDebugElement) child).fireCreationEvent();
		}
	}

	/**
	 * Fire a debug event marking the creation of this element.
	 */
	public void fireCreationEvent() {
		fireEvent(new DebugEvent(this, DebugEvent.CREATE));
		PICLUtils.logEvent("CREATION",this);
	}

	/**
	 * Fire a debug event marking change to this element.
	 */
	public void fireChangeEvent() {
		fireEvent(new DebugEvent(this, DebugEvent.CHANGE));
		PICLUtils.logEvent("CHANGE",this);
	}


	/**
	 * Fire a debug event
	 */
	private void fireEvent(DebugEvent event) {
		if(getDebugPlugin() != null)
			getDebugPlugin().fireDebugEvent(event);
	}

	/**
	 * Fire a debug event marking the RESUME of this element.
	 */
	public void fireResumeEvent() {
		fireResumeEvent(-1);
	}

	/**
	 * Fire a debug event marking the SUSPEND of this element.
	 */
	public void fireSuspendEvent() {
		fireSuspendEvent(-1);
	}

	/**
	 * Fire a debug event marking the RESUME of this element with
	 * the associated detail.
	 */
	public void fireResumeEvent(int detail) {
		fireEvent(new DebugEvent(this, DebugEvent.RESUME, detail));
		PICLUtils.logEvent("RESUME",this);
	}

	/**
	 * Fire a debug event marking the SUSPEND of this element with
	 * the associated detail.
	 */
	public void fireSuspendEvent(int detail) {
		fireEvent(new DebugEvent(this, DebugEvent.SUSPEND, detail));
		PICLUtils.logEvent("SUSPEND",this);
	}

	/**
	 * Fire a debug event marking the termination of this element.
	 */
	public void fireTerminateEvent() {
		fireEvent(new DebugEvent(this, DebugEvent.TERMINATE));
		PICLUtils.logEvent("TERMINATION", this);
	}


	/**
	 * Returns the first ancestor of this <code>PICLDebugElement</code> of the given type.
	 * If this <code>PICLDebugElement</code> is itself of the given type, return it.
	 */
	protected IDebugElement getAncestorOfType(int type) {
		IDebugElement current= this;
		while (current != null && current.getElementType() != type) {
			current= current.getParent();
		}
		return current;
	}

	/**
	 * Convenience method to get the breakpoint manager
	 */
	public IBreakpointManager getBreakpointManager() {
		try{ //18582
			return getDebugPlugin().getBreakpointManager();
		}catch(Exception e){ return null;}

	}

	/**
	 * @see IDebugElement
	 */
	public IDebugElement[] getChildren() throws DebugException {
		//     returned list as an Array of IDebugElements
		List list = null;
		if (fChildren == null)
			list = Collections.EMPTY_LIST;
		else
			list = fChildren;

		return (IDebugElement[])list.toArray(new IDebugElement[list.size()]);
	}

	/**
	 * Override this method if the debug element uses getChildren() to force a
	 * retrieval from the engine.
	 * This allows callers to get children without making requests to expand them
	 */
	public IDebugElement[] getChildrenNoExpand() throws DebugException {
		return getChildren();
	}


	/**
	 * 	Returns children as a List
	 */
	public List getChildrenAsList() {
		return fChildren;
	}

	/**
	 * @see IDebugElement
	 */
	public IDebugTarget getDebugTarget() {
		return (IDebugTarget) getAncestorOfType(IDebugElement.DEBUG_TARGET);

	}

	/**
	 * This provides some simple properties and forwards requests for other properties
	 * to the extender manager.
	 */
	public Object getAdapter(Class adapter) {
		if (adapter == IDebugElement.class) {
			return this;
		}

		return super.getAdapter(adapter);
	}

	/**
	 * @see IDebugElement
	 */
	public int getElementType() {
		return fType;
	}

	/**
	 * Returns a label that can be used by ModelPresentation for display purposes
	 * @param indicates whether label should be long or short.  True == long format.
	 * @return a String that represents the name/state etc. of this debug element
	 */
	public abstract String getLabel(boolean qualified);

	/**
	 * @see IProcess
	 */
	public ILaunch getLaunch() {
		return getDebugPlugin().getLaunchManager().findLaunch(getDebugTarget());
	}

	/**
	 * @see IDebugElement
	 */
	public IDebugElement getParent() {
		return fParent;
	}

	/**
	 * @see IDebugElement
	 */
	public IProcess getProcess() {
		return getDebugTarget().getProcess();
	}

	/**
	 * Returns the <code>ISourceLocator</code> for the debug element
	 */
	public ISourceLocator getSourceLocator() {
		ILaunch launch= getLaunch();
		if (launch == null) {
			return null;
		}

		return launch.getSourceLocator();
	}

	/**
	 * @see IDebugElement
	 */
	public IStackFrame getStackFrame() {
		return (IStackFrame) getAncestorOfType(IDebugElement.STACK_FRAME);
	}

	/**
	 * @see IDebugElement
	 */
	public IThread getThread() {
		return (IThread) getAncestorOfType(IDebugElement.THREAD);
	}

	/**
	 * Returns a <code>String</code> representing the type of this <code>PICLDebugElement</code>.
	 */
	protected String getTypeString() {
		switch (fType) {
			case IDebugElement.DEBUG_TARGET :
				return DebugCoreUtils.getResourceString(DEBUG_TARGET);
			case IDebugElement.STACK_FRAME :
				return DebugCoreUtils.getResourceString(STACK_FRAME);
			case IDebugElement.THREAD :
				return DebugCoreUtils.getResourceString(THREAD);
			case IDebugElement.VARIABLE :
				return DebugCoreUtils.getResourceString(VARIABLE);
			default :
				return DebugCoreUtils.getResourceString(UNKNOWN);
		}
	}

	/**
	 * @see IDebugElement
	 */
	public boolean hasChildren() {
		return !fChildren.isEmpty();
	}

	/**
	 * Removes all of the children from this element.
	 */
	public void removeAllChildren() {
		Iterator itr= fChildren.iterator();
		fChildren= fgEmptyChildren;
		while (itr.hasNext()) {
			PICLDebugElement child= (PICLDebugElement) itr.next();
			removeChild(child);
		}
	}

// The following code is the only piece from the original PICLDebugElement that was different
// from the DebugElement implementation
//
//
//	/**
//	 * @see DebugElement
//	 * Overidden here to <em>just</em> remove the child, and not also fire a terminate event.
//	 */
//	 this came from the original PICLDebugElement
//
//
//	public void removeChild(IDebugElement child) {
//		fChildren.remove(child);
//	}


	/**
	 * Removes this child from the collection of children for this element.
	 * Fires a termination event for the child.
	 * This is marked as final because cleanup depends on the order of operations in this method.
	 */
	public final void removeChild(IDebugElement child) {

		// first call the child to clean itself up and then remove it
		((PICLDebugElement)child).doCleanup();

		fChildren.remove(child);

		((PICLDebugElement)child).fireTerminateEvent();
	}

	/**
	 * Returns a <code>String</code> that represents the value of this object.
	 */
	public String toString() {
		return getLabel(true);
	}

	/**
	 * Convenience method to log internal errors
	 */
	public static void logError(Exception e) {
		PICLUtils.logError(e);
	}

		/**
	 * @see IDebugElement
	 */
	public DebugPlugin getDebugPlugin() {
		return DebugPlugin.getDefault();
	}

	/**
	 * Returns the debug engine this element is contained in.
	 */
	protected DebugEngine getDebugEngine() {
		return ((PICLDebugElement) getParent()).getDebugEngine();

	}
	/**
	 * Perform a request.
	 */
	public void performRequest(IPICLRequest request) throws DebugException {
		// Should be in a seperate thread
		PICLRequestOperation op= new PICLRequestOperation(request, getDebugEngine());
		op.execute();
	}

	/**
	 * Fires a resume or suspend event.
	 */
	protected void setIsRunning(boolean running) {
		setIsRunning(running, -1);
	}

	/**
	 * Fires a resume or suspend event with the associated detail.
	 */
	protected void setIsRunning(boolean running, int detail) {
		if (running) {
			fireResumeEvent(detail);
		} else {
			fireSuspendEvent(detail);
		}
	}

	/**
	 * Cleans up this debug element when it's no longer needed.  This mostly involves
	 * dereferencing held objects and deregistering as an event listener, then cleaning
	 * up any children.
	 */
	protected synchronized void doCleanup() {
		// Don't cleanup more than once
		if (haveDoneCleanup()) {
			return;
		}

		// Cleanup all children.  Because this is done before the call to 'doCleanupDetails()',
		// we are in effect performing a depth first traversal of the PICLDebugElement hierarchy.
		// To avoid the ConcurrentModificationException, use a copy of the list.
		List list = getChildrenAsList();
		if (list.size() > 0) {
			// make a copy of the list to iterate through
			PICLDebugElement[] children = new PICLDebugElement[list.size()];
			for (int i = 0; i < children.length; i++) {
				children[i] = (PICLDebugElement)list.get(i);
			}
			for (int i = 0; i < children.length; i++) {
				PICLDebugElement child= children[i];
				removeChild(child);
			}
		}

		// Concrete debug element (e.g. thread or stack frame) specific cleanup
		doCleanupDetails();

		// Set flag so we don't do this again
	 	fDoneCleanup= true;
	}

	/**
	 * Cleanup activities particular to the implementing subclass.
	 */
	 protected abstract void doCleanupDetails();

	/**
	 * Accessor for the fDoneCleanup property.
	 */
	protected boolean haveDoneCleanup() {
		return fDoneCleanup;
	}

	/**
	 * @see IDebugElement
	 */
	public String getModelIdentifier() {
		return IPICLDebugConstants.PICL_MODEL_IDENTIFIER;
	}

}
