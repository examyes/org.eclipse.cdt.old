package com.ibm.debug.model;

////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, 2001, 2002 International Business Machines Corporation. All rights reserved.
// This program and the accompanying materials are made available under the terms of
// the Common Public License which accompanies this distribution.
//
// com/ibm/debug/model/ViewFile.java, java-model, eclipse-dev, 20011129
// Version 1.84.1.3 (last modified 11/29/01 14:15:36)
////////////////////////////////////////////////////////////////////////////////

/**
 * Note: This class/interface is part of an interim API that is still under
 * development and expected to change significantly before reaching stability.
 * It is being made available at this early stage to solicit feedback from
 * pioneering adopters on the understanding that any code that uses this API
 * will almost certainly be broken (repeatedly) as the API evolves.
 */

import com.ibm.debug.epdc.*;
import com.ibm.debug.util.*;
import com.ibm.debug.util.FileSystem;    // User our util.FileSystem, not java.io.FileSystem
import java.util.Vector;
import java.util.Hashtable;
import java.util.Enumeration;
import java.io.*;

/**
 * The ViewFile class represents a file within a view. In a source view, the
 * ViewFile objects typically correspond directly to the source files used
 * in the compilation unit (part), while in a disassembly view, the ViewFile
 * object(s) correspond to some artificial "file" that was generated by the
 * debug engine. In either case, the ViewFile object is the means through which
 * lines of text in the view can be retrieved.
 * @see View#files()
 */

public class ViewFile extends DebugModelObject
{
  ViewFile(View owningView, int index, EViews epdcFile)
  {
    if (Model.TRACE.EVT && Model.traceInfo())
      Model.TRACE.evt(3, "Creating ViewFile : Index=" + index + " Name=" + epdcFile.name());

    _owningView = owningView;

    _maximumCacheSize = _owningView.part().module().process().debugEngine().getMaximumViewFileCacheSize();
    _index = index;
    change(epdcFile);
  }

  ViewFile(View owningView, int index)
  {
    if (Model.TRACE.DBG && Model.traceInfo())
      Model.TRACE.dbg(2, "Creating ViewFile");

    _owningView = owningView;

    _maximumCacheSize = _owningView.part().module().process().debugEngine().getMaximumViewFileCacheSize();
    _index = index;
  }

  void change(EViews epdcFile)
  {
    _epdcFile = epdcFile;
  }

  public void addEventListener(ViewFileEventListener eventListener)
  {
    if (Model.TRACE.DBG && Model.traceInfo())
      Model.TRACE.dbg(3, "ViewFile.addEventListener(" + eventListener + ")");

    _eventListeners.addElement(eventListener);
  }

  public void removeEventListener(ViewFileEventListener eventListener)
  {
    if (Model.TRACE.DBG && Model.traceInfo())
      Model.TRACE.dbg(3, "ViewFile.removeEventListener(" + eventListener + ")");

    _eventListeners.removeElement(eventListener);
  }

  /**
   * Ask the debug engine to search the file for the given string. Note that
   * the ViewFile object will remember the last search string passed to it
   * so that clients can subsequently call findNext and findAgain to search
   * for the same string again.
   * @param string The search string.
   * @param startingLine The starting line for the search.
   * @param startingColumn The starting column for the search.
   * @param caseSensitive If 'true', the search will be case sensitive,
   * otherwise it will be case insensitive.
   * @return A Location object (which includes a column number) indicating
   * where in the file the string was found. If the request could not be
   * sent to the debug engine, or if the string was not found, null will be
   * returned.
   * @see ViewFile#findNext
   * @see ViewFile#findAgain
   * @exception java.io.IOException If there is a problem communicating
   * with the debug engine.
   */

  public Location findString(String string,
                             int startingLine,
                             int startingColumn,
                             boolean caseSensitive)
  throws java.io.IOException
  {
    if (Model.TRACE.DBG && Model.traceInfo())
      Model.TRACE.dbg(2, "ViewFile[" + baseFileName() + "].findString(" +
                         string +
                         ", " + startingLine +
                         ", " + startingColumn + ")");

    if (string == null || string.length() == 0)
        return null;

    _searchString = string;
    _caseSensitiveSearch = caseSensitive;
    _lastFindLocation = null;

    if (_epdcFile.verificationLocal() && _owningView.isSourceView())
    {
        int[] position = _fileUtility.findString(string, startingLine, startingColumn,caseSensitive);
        if (position != null)
            return _lastFindLocation = new Location(this,
                                                    position[0],
                                                    position[1]);
        return null;
    }

    DebugEngine debugEngine = _owningView.part().module().process().debugEngine();

    int numberOfLinesToSearch = getNumberOfLines();

    if (!debugEngine.prepareForEPDCRequest(EPDC.Remote_StringFind,
                                           DebugEngine.sendReceiveSynchronously))
       return null;

    EStdView epdcLocation = (new Location(this, startingLine)).getEStdView();

    if (!debugEngine.processEPDCRequest(new EReqStringFind(epdcLocation,
                                                           string,
                                                           numberOfLinesToSearch,
                                                           startingColumn,
                                                           caseSensitive
                                                          ),
                                        DebugEngine.sendReceiveSynchronously))
       return null;

    ERepStringFind reply = (ERepStringFind)debugEngine.getMostRecentReply();

    // NOTE: We're assuming that if the reply contains a msg (with or without
    // an error return code) then the find failed. Hopefully all engines are
    // consistent in this regard:

    if (reply == null || reply.getReturnCode() != EPDC.ExecRc_OK || reply.messageText() != null)
       return null;
    else
       return _lastFindLocation = new Location(this,
                                               reply.getLineNumber(),
                                               reply.getColumnNumber());
  }

  /**
   * Find the next occurence of the string that was most recently passed to
   * findString. This method will use the same case sensitivity as was
   * specified on the last call to findString and will search for the string
   * starting 1 column past the last location at which the string was found.
   * If the starting column is greater than the length of lines in the file,
   * a starting column of 1 will be used and the starting line number will
   * be increased by 1. If increasing the starting line number results in
   * a line number which is greater than the last line in the file,
   * the search will wrap to the beginning of the file.
   * @return A Location object (which includes a column number) indicating
   * where in the file the string was found. If the request could not be
   * sent to the debug engine, or if the string was not found, null will be
   * returned.
   * @see ViewFile#findString
   * @see ViewFile#findAgain
   * @exception java.io.IOException If there is a problem communicating
   * with the debug engine.
   */

  public Location findNext()
  throws java.io.IOException
  {
    if (_searchString == null || _lastFindLocation == null)
       return null;

    int startingLine = _lastFindLocation.lineNumber();
    int startingColumn = _lastFindLocation.getColumnNumber() + 1;

    if (startingColumn > recordLength())
    {
       startingColumn = 1;

       if (++startingLine > lastLineNumber())
          startingLine = firstLineNumber();
    }

    return findString(_searchString, startingLine, startingColumn, _caseSensitiveSearch);
  }

  /**
   * Find the string that was most recently passed to findString. The search
   * will be done starting from the given location and using the same
   * case sensitivity that was specified on the last call to findString.
   * @param startingLine The starting line for the search.
   * @param startingColumn The starting column for the search.
   * @return A Location object (which includes a column number) indicating
   * where in the file the string was found. If the request could not be
   * sent to the debug engine, or if the string was not found, null will be
   * returned.
   * @see ViewFile#findString
   * @see ViewFile#findNext
   * @exception java.io.IOException If there is a problem communicating
   * with the debug engine.
   */

  public Location findAgain(int startingLine, int startingColumn)
  throws java.io.IOException
  {
    if (_searchString == null)
       return null;

    return findString(_searchString, startingLine, startingColumn, _caseSensitiveSearch);
  }

  /**
   * Retrieve the most recent search string passed to findString. Will return
   * null if findString has not been called.
   */

  public String getSearchString()
  {
    return _searchString;
  }

  /**
   * Get the location at which the current search string was last found in
   * this file. Will return null if the current search string was not found.
   */

  public Location getLastSearchStringLocation()
  {
    return _lastFindLocation;
  }

  /**
   * Get the case sensitivity currently being used to perform searches.
   * @return 'true' if searches are case sensitive, false otherwise.
   */

  public boolean getSearchCaseSensitivity()
  {
    return _caseSensitiveSearch;
  }

  /**
   * Returns a Vector of LocationBreakpoint objects representing the
   * breakpoints that are set in this file on the given line. Will return
   * null if there are no bkps set on the given line.
   */

  public Vector getBreakpoints(int lineNumber)
  {
    if (_breakpoints == null || _breakpoints.isEmpty())
       return null;

    return (Vector)_breakpoints.get(new Integer(lineNumber));
  }

  /**
   * Returns a Vector of LocationBreakpoint objects representing all of the
   * breakpoints that are set in this file. Will return
   * null if there are no bkps set in the file.
   */

  public Vector getBreakpoints()
  {
    if (_breakpoints == null || _breakpoints.isEmpty())
       return null;

    Enumeration allBreakpoints = _breakpoints.elements();

    Vector result = new Vector();

    while (allBreakpoints.hasMoreElements())
    {
      Vector breakpointsOnALine = (Vector)allBreakpoints.nextElement();

      for (int i = 0; i < breakpointsOnALine.size(); i++)
      {
          LocationBreakpoint bkp = (LocationBreakpoint)breakpointsOnALine.elementAt(i);

          if (bkp != null)
             result.addElement(bkp);
      }
    }

    return result;
  }

  void breakpointAdded(LocationBreakpoint bkp, int lineNumber)
  {
    if (Model.TRACE.DBG && Model.traceInfo())
       Model.TRACE.dbg(2, "In ViewFile.breakpointAdded");

    if (_breakpoints == null)
    {
       _breakpoints = new Hashtable();

       if (Model.TRACE.DBG && Model.traceInfo())
          Model.TRACE.dbg(3, "New hashtable created");
    }

    Integer lineNumberKey = new Integer(lineNumber);

    addObjectToHashtable(bkp, _breakpoints, lineNumberKey);

    if (Model.TRACE.DBG && Model.traceInfo())
       Model.TRACE.dbg(3, "Queuing breakpoint added event for ViewFile");

    // Add an event to notify listeners that a bkp was added to the ViewFile:

    DebugEngine debugEngine = _owningView.part().module().process().debugEngine();

    int requestCode = debugEngine.getMostRecentReply().getReplyCode();

    debugEngine.getEventManager().addEvent(new BreakpointAddedEvent(this,
                                                                    bkp,
                                                                    requestCode),
                                           _eventListeners
                                          );
  }

  void breakpointRemoved(LocationBreakpoint bkp, int lineNumber)
  {
    if (Model.TRACE.DBG && Model.traceInfo())
       Model.TRACE.dbg(2, "In ViewFile.breakpointRemoved");

    if (_breakpoints == null)
       return;  // TODO: This shouldn't happen so use trace facility here
                //       to print "something is wrong" message

    Integer lineNumberKey = new Integer(lineNumber);

    removeObjectFromHashtable(bkp, _breakpoints, lineNumberKey);
  }

  /**
   * A list of Function objects are retrieved here.
   * @see Function
   */

   public Vector getFunctions()
   throws java.io.IOException
   {
      if (Model.TRACE.DBG && Model.traceInfo())
        Model.TRACE.dbg(2, "ViewFile[" + baseFileName() + "].getFunctions()");

      Part part = _owningView.part();
      if (!part.functionsHaveBeenRetrieved()) //make sure the list of functions are not retrieved already
      {
         DebugEngine debugEngine = part.module().process().debugEngine();

         /*
            Ask picl for the list of entries, and create Function objects from EPDC reply.
            Add the list to our vector.

            Call EReqEntrySearch() with part id for a list of entry points in a part.
            Note that the ERepEntrySearch() returns all func

            EPDC reply will be processed through EPDCReplyProcessor. Function objects will
            be constructed there, and added to corresponding view files.

         */
         //EPDC.CaseSensitive is now defined in EPDC.java
         //Change is made to match "Model Implementation Guidelines"
         if (debugEngine.prepareForEPDCRequest(EPDC.Remote_EntrySearch, DebugEngine.sendReceiveSynchronously))
         {
            if (Model.TRACE.EVT && Model.traceInfo())
              Model.TRACE.evt(2, "Sending EPDC request Remote_EntrySearch");

            debugEngine.processEPDCRequest(new EReqEntrySearch(part.id(),
                                                            null,
                                                            0,
                                                            EPDC.CaseSensitive),
                                          DebugEngine.sendReceiveSynchronously);

            // Functions returned by the EntrySearch may not have complete
            // location information. In this case, the functions will have been
            // added to the process as "unresolved" functions. We now call
            // resolveFunctions in order to get the location information for the
            // functions: (See defect 10658.)

            debugEngine.process().resolveFunctions();
         }

        part.setFunctionsHaveBeenRetrieved(true);  //set _functionsHaveBeenRetrieved flag on
      }

      return _functions;
   }

   /**
    * Add a Function
    */
   void addFunction(Function function)
   {
      if (_functions == null)
         _functions = new Vector();

      _functions.addElement(function);

      // setVectorElementToObject(function, _functions, function.getId());
   }

/*
  Function getFunction(int index)
  throws java.io.IOException
  {
     return getFunction(index, true);
  }

  Function getFunction(int index, boolean retrieve)
  throws java.io.IOException
  {
    if (retrieve)
       getFunctions(); // Make sure we've asked the DE for them

    if (_functions == null)
      return null;

    try
    {
      return (Function)(_functions.elementAt(index));
    }
    catch (ArrayIndexOutOfBoundsException excp)
    {
      return null;
    }
  }
*/

  /**
   * Get the view containing this file.
   */

  public View view()
  {
    return _owningView;
  }

  /**
   * Get the length of every line in the file, including any padding that
   * may have been done by the debug engine to make all lines the same length.
   * The debug engine will ensure that
   * each line is exactly this length by padding shorter lines with blanks,
   * if necessary. If the view has a prefix area, this length will include
   * that prefix area.
   * @return The length of every line in the file. Will return -1 if the
   * request could not be sent to the debug engine.
   * @see View#prefixLength()
   * @exception java.io.IOException If there is a problem communicating
   * with the debug engine.
   */

  public int recordLength()
  throws java.io.IOException
  {
    verify();

    if (_epdcFile == null)
       return -1;
    else
       return _epdcFile.recordLength();
  }

  /**
   * Get the line number of the first line in the file (will usually be 1).
   * This is significant when asking the debug engine to retrieve lines of
   * text from the file.
   * @return The line number of the first line in the file. Will return -1 if the
   * request could not be sent to the debug engine.
   *  @exception java.io.IOException If there is a problem communicating
   *  with the debug engine.
   */

  public int firstLineNumber()
  throws java.io.IOException
  {
    verify();

    if (_epdcFile == null)
       return -1;
    else
       return _epdcFile.firstLineNumber();
  }

  /**
   * Get the line number of the last line in the file.
   * This is significant when asking the debug engine to retrieve lines of
   * text from the file.
   * @return The line number of the last line in the file. Will return -1 if the
   * request could not be sent to the debug engine.
   *  @exception java.io.IOException If there is a problem communicating
   *  with the debug engine.
   */

  public int lastLineNumber()
  throws java.io.IOException
  {
    verify();

    if (_epdcFile == null)
       return -1;
    else
       return _epdcFile.lastLineNumber();
  }

  /**
   * Get the number of lines in the file. This is simply lastLineNumber() -
   * firstLineNumber() + 1.
   *  @exception java.io.IOException If there is a problem communicating
   *  with the debug engine.
   */

  public int getNumberOfLines()
  throws java.io.IOException
  {
    return lastLineNumber() - firstLineNumber() + 1;
  }

  /**
   * Get the name of the file. This is a fully qualified name, including
   * path information. This name may have been generated by the debug engine.
   */

  public String name()
  throws java.io.IOException
  {
    if (_epdcFile == null || _epdcFile.name() == null)
       verify();

    if (_epdcFile == null)
       return null;
    else
       return _epdcFile.name();
  }

  /** Get the base name of the file without path qualification.
   * This name may have been generated by the debug engine.
   */

  public String baseFileName()
  throws java.io.IOException
  {
    if (_epdcFile == null || _epdcFile.baseFileName() == null)
       verify();

    if (_epdcFile == null)
       return null;
    else
       return _epdcFile.baseFileName();
  }

  /**
   * Get the file index
   */

  int index()
  {
    return _index;
  }


  /**
   *  Determine if the name of the file can be overridden so that lines
   *  of text will be retrieved from a different file.
   *  A return value of 'true' indicates that the debug engine will allow us
   *  to specify the name of a file that is to be used in place of the
   *  original file named in the debug info in the executable. The view will
   *  then be built using that new file instead of the original one. Files in
   *  a source view can usually be overridden while those in a disassembly
   *  view cannot.
   *  @see ViewFile#overrideFileName
   */

  public boolean fileNameCanBeOverridden()
  throws java.io.IOException
  {
    _owningView.part().verify();

    if (_epdcFile == null)
       return false;
    else
       return _epdcFile.fileNameCanBeOverridden();
  }

 /**
  *  Tell the debug engine to retrieve lines of source from the file with
  *  the given name, instead of from the file named in the part's debug
  *  information.
  *  @return 'true' if the file name was successfully overridden, 'false'
  *  otherwise. If the debug engine could not find the specified file
  *  (or rejects the request for any other reason), or if the frontend
  *  could not file the file (in case of the local source file), an
  *  'errorOccurred' event will be fired as part of processing the reply to
  *  this request.
  *  @exception java.io.IOException If there is a problem communicating
  *  with the debug engine.
  *  @see ViewFile#fileNameCanBeOverridden
  */

  public boolean overrideFileName(String newFileName)
  throws java.io.IOException
  {
    if (Model.TRACE.DBG && Model.traceInfo())
      Model.TRACE.dbg(3, "ViewFile[" + baseFileName() + "].overrideFileName(" + newFileName + ")");

    // In case of a local source file, the errorOccurred event will be saved
    // by the engine, but the Model will keep track of it through the use
    // of _fileNotFoundError flag. The engine will only fire that event if
    // the file cannot be found either by the engine or the frontend.
    _fileNotFoundError = true;

    // A new path will be specified to look up this view file. Therefore,
    // turn off the ATTEMPTED_FE attribute so that the frontend will have a
    // chance of finding it as well as the backend.

    // If this is for "Change Text file", do not change the view attributes
    // of the file, if the file that is going to be overriden is already
    // verified. If we reset the view attributes, and then cannot change the
    // text to the desired text, the debug engine might not be able to find
    // the original file, because we have clobbered the view attributes of
    // the original file.

    if (!_epdcFile.hasBeenVerified())
        setLocalSourceInfo(null, false);

    Part part = _owningView.part();

    DebugEngine debugEngine = part.module().process().debugEngine();

    if (!debugEngine.prepareForEPDCRequest(EPDC.Remote_PartSet,
                                           DebugEngine.sendReceiveSynchronously))
       return false;

    if (!fileNameCanBeOverridden())
    {
       debugEngine.cancelEPDCRequest(EPDC.Remote_PartSet);
       return false;
    }

    if (Model.TRACE.EVT && Model.traceInfo())
      Model.TRACE.evt(2, "Sending EPDC request Remote_PartSet");

    if (!debugEngine.processEPDCRequest(new EReqPartSet(newFileName,
                                                        part.id(),
                                                        _owningView.index(),
                                                        _index
                                                       ),
                                        DebugEngine.sendReceiveSynchronously))
       return false;

    ERepPartSet reply = (ERepPartSet)debugEngine.getMostRecentReply();

    if (reply == null)
       return false;

    if (reply.getReturnCode() != EPDC.ExecRc_OK)
    {
        findLocalSourceFile();

        // Only if the frontend was not able to find the file either send
        // the file not found error event.
        if (_fileNotFoundError)
        {
            fireFileNotFoundErrorEvent();
            return false;
        }
    }

    purgeCache();
    return true;

    // Note: After successfully overriding the file name we are expecting a
    // Part change packet with this file marked as "Verified".
  }

  /**
   * Ask the debug engine to verify that the actual file represented by this
   * ViewFile object exists, can be opened, etc. Because verifying a file
   * can be an expensive operation, as an optimization the debug
   * engine does not automatically verify every file referred to in the
   * program's debug information. Instead, it is left up to the FE to ask the
   * DE to verify only those files that will actually be used e.g. those
   * files from which we need to retrieve source lines to show to the user.
   */

  public boolean verify()
  throws java.io.IOException
  {
    Part part = _owningView.part();

    // Only ask the DE to verify the file if we have not already done so:
    // TODO: More error checking:
    if (_epdcFile == null ||
        (!_epdcFile.hasBeenVerified() && !_epdcFile.verificationAttempted()))
        part.verify(_index);

    // If the DE cannot find the file ask the FE to locate the file
    if (_epdcFile != null &&
        (_epdcFile.verificationAttempted() &&
         (!_epdcFile.verificationAttemptedFE() || localSourcePathChanged()) &&
         !_epdcFile.hasBeenVerified()))
    {
        findLocalSourceFile();

        // Check if errorOccurred event has been saved by the debug engine.
        // If so, add and fire the event from the engine.
        if (_fileNotFoundError)
            fireFileNotFoundErrorEvent();
    }

    if (_epdcFile == null || !_epdcFile.hasBeenVerified())
       return false;
    else
       return true;
  }

   /**
    * Check if errorOccurred event has been saved by the debug engine and the
    * file has not been found by the frontend either. If so, add and fire the
    * event from the engine.
    */
   void fireFileNotFoundErrorEvent()
   {
     DebugEngine debugEngine = _owningView.part().module().process().debugEngine();
     debugEngine.fireErrorOccurredEventForFileNotFound();
   }

  /**
   * Collect the list of the search paths from the engine and the UI and
   * build the search path list. Then go through the list and attempt to
   * find the file in the frontend.
   * The frontend will provide the path list for the local source file
   * by using DebugEngine.setLocalSourcePath method.
   * variable, the information will be hardcoded here.
   */
  void findLocalSourceFile()
  throws java.io.IOException
  {
    Vector combinedList = new Vector();

    String[] BEList = getLocalSourcePathListFromEngine();

    // Get the local source path list from the engine if the frontend has
    // provided that.
    DebugEngine debugEngine = _owningView.part().module().process().debugEngine();
    _localSourcePath = debugEngine.getLocalSourcePath();
    FileSystem fileSystem = new FileSystem(_localSourcePath);

    // Each path in the list could be the fully qualified path (the path and the
    // name) or just the path of the file
    combinedList = fileSystem.buildPathList(BEList, _epdcFile.baseFileName());

    boolean localSourceNotFound = true;
    for (int j = 0; j < combinedList.size(); j++)
    {
         if (combinedList.elementAt(j) != null)
         {
             String name = (String)(combinedList.elementAt(j));

             if (fileSystem.readFile(name))
             {
                 // have found the file, update the file info and
                 // get out of this loop
                 setLocalSourceInfo(fileSystem, true);
                 localSourceNotFound = false;
                 break;
             }
         }
    }

    // If the file is not found by the frontend set the ATTEMPTED_FE bit on
    // to indicate that the frontend has tried to locate the file as well as
    // the backend.
    if (localSourceNotFound)
        setLocalSourceInfo(null, true);
  }

  /**
   * Set a breakpoint in this file at the given line number.
   * In this method, no module, part, or source file name needs to be
   * specified. Because all the user needs to set a breakpoint is to
   * double click on a line number that belongs to a source view. If the user
   * needs to specify any of these file names, or defer the breakpoint until
   * a module is loaded, another method from the DebuggeeProcess object
   * will be invoked to set the breakpoint.
   * @param isEnabled The attributes of a breakpoint which can be set
   * within a ViewFile object are 'enable' or 'disable'. Therefore, if the
   * parameter is set to true the breakpoint attribute with be 'enable'
   * and 'disable' otherwise.
   * @param lineNumber The line at which the breakpoint is to be set.
   * @param stopEvery the number of times the breakpoint should stop
   * the execution when the breakpoint is hit
   * @param from the breakpoint should stop execution if the number of
   * times the breakpoint is hit is greater that 'from'.
   * @param to the breakpoint should stop execution if the number of
   * times the breakpoint is hit is less than 'to'.
   * @param expr the conditional expression for this breakpoint
   * @param threadID The id of the DebuggeeThread object in which the
   * breakpoint is to be evaluated. If the value of zero is passed as
   * the thread id, the evaluation will be for every possible thread
   * available.
   * @param sendReceiveControlFlags A set of flags which specify the mode
   * in which this request is to be performed. There is a set of constants
   * in DebugEngine which define the possible values for this argument.
   * For example, a value of DebugEngine.sendReceiveDefault means that the
   * request is to be done asynchronously, while a value of
   * DebugEngine.sendRequestDefault
   * means that the request is to be performed synchronously.
   * <p>When done asynchronously,
   * this method will return immediately after sending the request to the
   * debug engine without waiting for a response from
   * the debug engine. The response to the request will be
   * received on a separate thread and client code will be notified of the
   * the response via the event listener mechanism.
   * @return 'true' if the set breakpoint request was successfully sent to
   * the debug engine, 'false' otherwise. Note that a return value of 'true'
   * does not imply that the debug engine was able to set the breakpoint but
   * rather simply that the request was successfully sent to the debug engine.
   * Whether or not the breakpoint was actually set by the debug engine will
   * be indicated via the event listener mechanism.
   *  @exception java.io.IOException If there is a problem communicating
   *  with the debug engine.
   */

  public boolean setBreakpoint(boolean isEnabled,
                        int lineNumber,
                        int stopEvery, int from, int to,
                        String expr,
                        int threadID,
                        int sendReceiveControlFlags)
  throws java.io.IOException
  {
    return setBreakpoint(isEnabled,
                         lineNumber,
                         stopEvery, from, to,
                         expr,
                         threadID,
                         sendReceiveControlFlags,
                         null);
  }

  public boolean setBreakpoint(boolean isEnabled,
                               int lineNumber,
                               int stopEvery, int from, int to,
                               String expr,
                               int threadID,
                               int sendReceiveControlFlags,
                               Object property)
  throws java.io.IOException
  {
    DebugEngine debugEngine = _owningView.part().module().process().debugEngine(
);

    // If the statement breakpoint is supported and the user has provide a
    // line number assume that the statement number is the same as the line
    //  number. Otherwise, set the statement number to be null.
    String stmtNumber = null;

    if (debugEngine.getCapabilities().getBreakpointCapabilities().statementBreakpointSupported())
    {
        stmtNumber = Integer.toString(lineNumber);
    }

    return setBreakpoint(isEnabled, lineNumber, stopEvery, from, to, expr,
                         threadID, stmtNumber, sendReceiveControlFlags, property);
  }

  boolean setBreakpoint(boolean isEnabled,
                        int lineNumber,
                        int stopEvery, int from, int to,
                        String expr,
                        int threadID,
                        String stmtNumber,
                        int sendReceiveControlFlags)
  throws java.io.IOException
  {
    return setBreakpoint(isEnabled, lineNumber, stopEvery, from, to, expr,
                         threadID, stmtNumber, sendReceiveControlFlags, null);
  }

  boolean setBreakpoint(boolean isEnabled,
                        int lineNumber,
                        int stopEvery, int from, int to,
                        String expr,
                        int threadID,
                        String stmtNumber,
                        int sendReceiveControlFlags,
                        Object property)
  throws java.io.IOException
  {
    if (Model.TRACE.DBG && Model.traceInfo())
        Model.TRACE.dbg(2, "ViewFile[" + baseFileName() + "].setBreakpoint(Line#" + lineNumber + ")");

    Part part = _owningView.part();

    DebuggeeProcess process = part.module().process();

    // We can't set line bkps in a view that is not line breakpoint capable
    // (i.e. in dasm or mixed view when the debug engine is C++), so we'll
    // set an address bkp:

    if (!_owningView.isLineBreakpointCapable() && (_owningView.isDisassemblyView() || _owningView.isMixedView()))
    {
       // Get the line so we can get the address from its prefix area, then
       // use the address to set an address bkp.

       // If we can't get the line from the engine, return false:

       if (!getLinesFromEngine(lineNumber, 1))
          return false;

       Line line = getLineFromCache(lineNumber);

       // TODO: If we got the line from the engine then we should be able
       // to get it from the cache, but we'll check for null here just in
       // case. We should print a Trace message in this situation:

       if (line == null)
          return false;

       String address = line.getPrefix();

       if (address == null)
          return false;

       // TODO: Pass a thread to setAddressBreakpoint instead of null:

       return process.setAddressBreakpoint(isEnabled,
                                           address,
                                           null, // location
                                           stopEvery,
                                           from,
                                           to,
                                           expr,
                                           threadID, // thread
                                           sendReceiveControlFlags
                                          );
    }


    DebugEngine debugEngine = process.debugEngine();

    EStdView epdcContext = new EStdView(part.id(),
                                        _owningView.index(),
                                        _index,
                                        lineNumber);

    if (!debugEngine.prepareForEPDCRequest(EPDC.Remote_BreakpointLocation,
                                           sendReceiveControlFlags))
       return false;

    if (Model.checkFCTBit)
    {
        if (!debugEngine.getCapabilities().getBreakpointCapabilities().lineBreakpointsSupported() ||
            !_owningView.viewInformation().isLineBreakpointCapable())
        {
            debugEngine.cancelEPDCRequest(EPDC.Remote_BreakpointLocation);
            return false;
        }
    }

    EEveryClause clause = null;

    // If no values have been specified for the every clause create one
    // with a set of defaults.
    if (!(stopEvery == 0 && from == 0 && to == 0))
        clause = new EEveryClause(stopEvery, to, from);

    short attribute = (isEnabled) ? EPDC.BkpEnable : (short)0;

    EStdExpression2 conditionalExpr = null;
    if (expr != null)
        conditionalExpr = new EStdExpression2(epdcContext, expr, threadID, 0);

    if (Model.TRACE.EVT && Model.traceInfo())
      Model.TRACE.evt(2, "Sending EPDC request Remote_BreakpointLocation");

    if (!debugEngine.processEPDCRequest(new EReqBreakpointLine
                                            (attribute,
                                             clause,
                                             null,
                                             null,
                                             null,
                                             null,
                                             conditionalExpr,
                                             threadID,
                                             stmtNumber,
                                             epdcContext),
                                        sendReceiveControlFlags,
                                        property))
       return false;
    else
       return true;
  }

  /**
   * This is the default method for setting a breakpoint in a file at a
   * given line number. This method will call the overriding setBreakpoint
   * method with a preset value for a number of parameters of the method.
   * The parameters include:
   * isEnabled, stopEvery, from, to, and expr
   * @param lineNumber The line at which the breakpoint is to be set.
   * @param sendReceiveControlFlags the flag indicating the state in which the
   * request is to be sent(synchronized, asynchronized).
   * @return 'true' if the set breakpoint request was successfully sent to
   * the debug engine, 'false' otherwise. Note that a return value of 'true'
   * does not imply that the debug engine was able to set the breakpoint but
   * rather simply that the request was successfully sent to the debug engine.
   * Whether or not the breakpoint was actually set by the debug engine will
   * be indicated via the event listener mechanism.
   * @exception java.io.IOException if there is a communication problem
   * with the debug engine, this exception occurs.
   */
  public boolean setBreakpoint(int lineNumber, int sendReceiveControlFlags)
  throws java.io.IOException
  {
    if (Model.TRACE.DBG && Model.traceInfo())
      Model.TRACE.dbg(2, "ViewFile.setBreakpoint(" + lineNumber + ")");

    return setBreakpoint(true, lineNumber, 0, 0, 0, null, 0,
                         sendReceiveControlFlags);
  }

  private LineCacheSegment getSegmentContainingLine(int lineNumber, int startingIndex)
  {
    if (Model.TRACE.DBG && Model.traceInfo())
       Model.TRACE.dbg(4, "In ViewFile.getSegmentContainingLine(" +
                          lineNumber + ", " + startingIndex + ")");

     int indexOfSegmentContainingLine = getIndexOfSegmentContainingLine(lineNumber, startingIndex);

     if (indexOfSegmentContainingLine == -1)
     {
        if (Model.TRACE.DBG && Model.traceInfo())
           Model.TRACE.dbg(4, "Line not found in cache!");

        return null;
     }
     else
     {
        if (Model.TRACE.DBG && Model.traceInfo())
           Model.TRACE.dbg(4, "Line was found in cache");

        return (LineCacheSegment)_lineCacheSegments.elementAt(indexOfSegmentContainingLine);
     }
  }

  /**
   * @return The index in the _lineCacheSegments Vector of the segment which
   * contains this line. Returns -1 if no segment contains the line.
   */

  private int getIndexOfSegmentContainingLine(int lineNumber, int startingIndex)
  {
    if (Model.TRACE.DBG && Model.traceInfo())
       Model.TRACE.dbg(4, "In ViewFile.getIndexOfSegmentContainingLine(" +
                          lineNumber + ", " + startingIndex + ")");

    if (_lineCacheSegments == null)
    {
       if (Model.TRACE.DBG && Model.traceInfo())
          Model.TRACE.dbg(4, "Line not in cache because ViewFile._lineCacheSegments is null");

        return -1;
    }

    // Loop until we find the segment containing the line OR we find a segment
    // whose first line # is > lineNumber (in which case we know that the
    // cache does not contain the line and we can stop looking):

    for (int i = startingIndex; i < _lineCacheSegments.size(); i++)
    {
        // If the line is in the segment, return i:

        if (((LineCacheSegment)_lineCacheSegments.elementAt(i)).containsLine(lineNumber))
        {
           if (Model.TRACE.DBG && Model.traceInfo())
              Model.TRACE.dbg(4, "Line is in cache segment #" + i);

           return i;
        }

        // If line not in cache, return -1:

        if (((LineCacheSegment)_lineCacheSegments.elementAt(i)).getLineNumberOfFirstLineInSegment() > lineNumber)
        {
           if (Model.TRACE.DBG && Model.traceInfo())
              Model.TRACE.dbg(4, "Line is not in cache - found segment with starting line number > requested line number");

           return -1;
        }
    }

    if (Model.TRACE.DBG && Model.traceInfo())
       Model.TRACE.dbg(4, "Line is not in cache - reached end of segments vector");

    return -1;
  }

  /**
   * Retrieve a single line from the cache of lines saved in the Model.
   * This method will only return lines that are in the cache - it will
   * not ask the debug engine for the line if it is not in the cache.
   * @param lineNumber The line number of the line to be
   * retrieved. This must be >= firstLineNumber() and <= lastLineNumber().
   * @return A Line object representing the requested line. This
   * method will return null if the requested line is not in the
   * cache. In this case, the client should call getLinesFromEngine to
   * add the required line(s) to the cache, and then call this method again to
   * retrieve the line from the cache.
   */

  public synchronized Line getLineFromCache(int lineNumber)
  {
    if (Model.TRACE.DBG && Model.traceInfo())
       Model.TRACE.dbg(4, "In ViewFile.getLineFromCache(" +
                          lineNumber + ")");

    LineCacheSegment segmentContainingLine = getSegmentContainingLine(lineNumber, 0);

    if (segmentContainingLine == null)
       return null;
    else
       return segmentContainingLine.getLine(lineNumber);
  }

  /**
   * Retrieve a set of lines from the cache of lines saved in the Model.
   * This method will only return lines that are in the cache - it will
   * not ask the debug engine for the lines if they are not in the cache.
   * @param startingLineNumber The line number of the first line to be
   * retrieved. This must be >= firstLineNumber() and <= lastLineNumber().
   * @param numberOfLines The number of lines to be retrieved. This arg
   * must be > 0. Also, startingLineNumber + numberOfLines - 1 must not
   * be greater than the line number of the last line in the file - if you
   * ask this method to retrieve lines beyond the end of the file it will
   * return null.
   * @return A Vector of Line objects representing the requested lines. This
   * method will return null if not all of the requested lines are in the
   * cache. In this case, the client should call getLinesFromEngine to
   * add the required lines to the cache, and then call this method again to
   * retrieve those lines from the cache.
   * @see ViewFile#getLinesFromEngine
   */

  public synchronized Vector getLinesFromCache(int startingLineNumber, int numberOfLines)
  {
    if (Model.TRACE.DBG && Model.traceInfo())
       Model.TRACE.dbg(4, "In ViewFile.getLinesFromCache(" +
                          startingLineNumber + ", " + numberOfLines + ")");

    // Find the segment containing the 1st line:

    LineCacheSegment segmentContainingFirstLine = getSegmentContainingLine(startingLineNumber, 0);

    if (segmentContainingFirstLine == null)
       return null;

    int endingLineNumber = startingLineNumber + numberOfLines - 1;

    if (segmentContainingFirstLine.containsLine(endingLineNumber))
    {
       if (Model.TRACE.DBG && Model.traceInfo())
          Model.TRACE.dbg(4, "Line " + startingLineNumber + " and line " +
                              endingLineNumber + " are both in the cache and in same segment");

       return segmentContainingFirstLine.getLinesInRange(startingLineNumber,
                                                         endingLineNumber
                                                        );
    }
    else
    {
      if (Model.TRACE.DBG && Model.traceInfo())
         Model.TRACE.dbg(4, "Line " + startingLineNumber + " is in cache but line " +
                             endingLineNumber + " is not in same segment");

      return null;
    }
  }

  /**
   * Ensure that the Model's cache contains the given set of lines. The Model
   * will retrieve lines from the engine if it does not have all of the
   * requested lines in the cache already. This method is intended to be
   * called prior to calling getLinesFromCache.
   * @param startingLineNumber The line number of the first line to be
   * retrieved from the engine (if necessary). This number must be less than
   * or equal to lastLineNumber(). If this number is less than firstLineNumber(),
   * this method will implicitly use firstLineNumber() instead i.e. the
   * method will ensure that startingLineNumber is not before the beginning
   * of the file.
   * @param numberOfLines The number of lines to retrieve from the debug
   * engine (if necessary). If startingLineNumber + numberOfLines - 1 is
   * greater than lastLineNumber(), this method will adjust numberOfLines so
   * that we do not try and ask the engine for lines beyond the end of the
   * file.
   * @return 'true' if the request was successfully sent to the debug
   * engine or the cache already contains all of the requested lines, 'false'
   * if the cache does not contain all of the requested lines and they could
   * not be retrieved from the debug engine.
   * @exception java.io.IOException If there is a problem communicating with
   * the debug engine.
   * @see ViewFile#getLinesFromCache
   */

  public synchronized boolean getLinesFromEngine(int startingLineNumber, int numberOfLines)
  throws java.io.IOException
  {
    if (Model.TRACE.DBG && Model.traceInfo())
       Model.TRACE.dbg(4, "In ViewFile.getLinesFromEngine(" +
                          startingLineNumber + ", " + numberOfLines + ")");

    int i;

    if (startingLineNumber < firstLineNumber())
       startingLineNumber = firstLineNumber();

    int endingLineNumber = startingLineNumber + numberOfLines - 1;

    if (endingLineNumber > lastLineNumber())
       endingLineNumber = lastLineNumber();

    // Start out assuming we don't have any of the requested lines in the
    // cache. We'll adjust firstLineToRetrieveFromEngine and/or
    // lastLineToRetrieveFromEngine later if we discover that the cache
    // actually does contain the first and/or last requested line:

    int firstLineToRetrieveFromEngine = startingLineNumber;
    int lastLineToRetrieveFromEngine = endingLineNumber;

    // Loop through all segments looking for the ones containing the first
    // requested line and the last requested line:

    for (i = 0; i < _lineCacheSegments.size(); i++)
    {
        LineCacheSegment lineCacheSegment = (LineCacheSegment)_lineCacheSegments.elementAt(i);

        if (lineCacheSegment.containsLine(startingLineNumber))
        {
           // If we find a segment which contains both the first and last
           // requested line then we're done:

           if (lineCacheSegment.containsLine(endingLineNumber))
           {
              if (Model.TRACE.DBG && Model.traceInfo())
                 Model.TRACE.dbg(4, "Cache already contains lines - not fetching any from engine");

              return true;
           }

           firstLineToRetrieveFromEngine = lineCacheSegment.
                                           getLineNumberOfLastLineInSegment() + 1;
        }
        else
        if (lineCacheSegment.containsLine(endingLineNumber))
        {
	   lastLineToRetrieveFromEngine = lineCacheSegment.
					  getLineNumberOfFirstLineInSegment() - 1;
           break;
        }
        else
        if (lineCacheSegment.containsLinesInRange(startingLineNumber, endingLineNumber))
        {
           // Any segment which contains lines in the range we are looking for
           // but does NOT contain either the first or last line must be
           // deleted from the Vector of segments - the lines in this segment
           // will be re-read from the engine (since we want to avoid the
           // alternative which is reading from the engine twice - once for
           // lines before this segment and again for the lines after this
           // segment):

           if (Model.TRACE.DBG && Model.traceInfo())
           {
              Model.TRACE.dbg(4, "Removing lines from cache which will be re-read from engine");
              Model.TRACE.dbg(4, "Lines to be removed: " +
                                 ((LineCacheSegment)_lineCacheSegments.elementAt(i)).getLineNumberOfFirstLineInSegment() +
                                 " to " +
                                 ((LineCacheSegment)_lineCacheSegments.elementAt(i)).getLineNumberOfLastLineInSegment());
              Model.TRACE.dbg(4, "Old cache size = " + _currentCacheSize);
           }

           _currentCacheSize -= ((LineCacheSegment)_lineCacheSegments.elementAt(i)).size();

           if (Model.TRACE.DBG && Model.traceInfo())
              Model.TRACE.dbg(4, "New cache size = " + _currentCacheSize);

           _lineCacheSegments.removeElementAt(i--);
        }
        else
        if (lineCacheSegment.getLineNumberOfFirstLineInSegment() > endingLineNumber)
        {
           // If this segment has a starting line number which is greater than the
           // last line we are looking for then we can stop looking:

           break;
        }
    }

    // Determine how many lines we need to retrieve from the engine:

    int numberOfLinesToRetrieveFromEngine = lastLineToRetrieveFromEngine - firstLineToRetrieveFromEngine + 1;

    // Create a new segment and retrieve lines from the engine into it:

    LineCacheSegment newSegment = new LineCacheSegment();
/*
    if (!addLinesFromEngine(firstLineToRetrieveFromEngine,
                            numberOfLinesToRetrieveFromEngine,
                            newSegment.getAllLines()))
*/

    if (!newSegment.addLinesFromEngine(firstLineToRetrieveFromEngine,
                                  numberOfLinesToRetrieveFromEngine))
       return false;

    // Insert new segment at the right slot:

    for (i = 0; i < _lineCacheSegments.size(); i++)
    {
	LineCacheSegment lineCacheSegment = (LineCacheSegment)_lineCacheSegments.elementAt(i);

	if (lineCacheSegment.getLineNumberOfFirstLineInSegment() >
	    firstLineToRetrieveFromEngine)
	   break;

    }

    if (Model.TRACE.DBG && Model.traceInfo())
       Model.TRACE.dbg(4, "Inserting new cache segment at index " + i);

    _lineCacheSegments.insertElementAt(newSegment, i);
    _currentCacheSize += numberOfLinesToRetrieveFromEngine;

    if (Model.TRACE.DBG && Model.traceInfo())
       Model.TRACE.dbg(4, "New cache size = " + _currentCacheSize);

    // Now see if the new segment can be merged with the ones before and
    // after it:

    int indexOfNextSegment = i + 1;

    if (indexOfNextSegment != _lineCacheSegments.size())
    {
       LineCacheSegment nextSegment = (LineCacheSegment)_lineCacheSegments.elementAt(indexOfNextSegment);

       if (nextSegment.isAContinuationOf(newSegment))
       {
	  newSegment.mergeWith(nextSegment);
	  _lineCacheSegments.removeElementAt(indexOfNextSegment);
       }
    }

    if (i != 0)
    {
       LineCacheSegment previousSegment = (LineCacheSegment)_lineCacheSegments.elementAt(i-1);

       if (newSegment.isAContinuationOf(previousSegment))
       {
	  previousSegment.mergeWith(newSegment);
	  _lineCacheSegments.removeElementAt(i);
       }
    }

    // Finally, if we've exceeded the maximum size of the cache, try to
    // purge some lines:

    for (i = 0; i < _lineCacheSegments.size() && _currentCacheSize > _maximumCacheSize; i++)
    {
	LineCacheSegment lineCacheSegment = (LineCacheSegment)_lineCacheSegments.elementAt(i);

        int oldSize = lineCacheSegment.size();

        lineCacheSegment.removeLinesNotInRange(startingLineNumber,
                                               endingLineNumber,
                                               _currentCacheSize - _maximumCacheSize);

        _currentCacheSize -= (oldSize - lineCacheSegment.size());

        if (lineCacheSegment.size() == 0)
           _lineCacheSegments.removeElementAt(i--);
    }

    if (Model.TRACE.DBG && Model.traceInfo())
       Model.TRACE.dbg(4, "After purging excess lines, new cache size = " + _currentCacheSize);

    return true;
  }

  /**
   * Not recommended for large files. This is equivalent to the call
   * getLinesFromEngine(firstLineNumber(), lastLineNumber()).
   */

  public boolean getAllLinesFromEngine()
  throws java.io.IOException
  {
    return getLinesFromEngine(firstLineNumber(), lastLineNumber());
  }

  // Wanted this to be a method within LineCacheSegment but the compiler
  // seems to have a bug wherein I can't have a method in an inner class
  // which declares that it throws an exception. (Note: This bug has been fixed in
  // JDK 1.1.5):

/*
  private boolean addLinesFromEngine(int startLine, int numberOfLines, Vector lineCache)
  throws java.io.IOException
  {
    if (Model.TRACE.DBG)
       Model.TRACE.dbg(4, "ViewFile.LineCacheSegment.addLinesFromEngineToVector(" + startLine + ", " + numberOfLines + ")");

    Part part = _owningView.part();

    DebugEngine debugEngine = part.module().process().debugEngine();

    // If we have not yet attempted to verify the view file, do so. Because
    // this is being done synchronously, after the attempt to verify we
    // should have an updated _epdcFile member.

    verify();

    if (!debugEngine.prepareForEPDCRequest(EPDC.Remote_PartGet,
					   DebugEngine.sendReceiveSynchronously))
       return false;

    // TODO: If a view file cannot be verified we want to give the user a
    // a chance to override the file name. However, beware - the above verify
    // might have failed because the DE was busy, not because the file
    // really couldn't be verified.

    if (!_epdcFile.hasBeenVerified())
    {
       debugEngine.cancelEPDCRequest(EPDC.Remote_PartGet);
       return false;
    }

    if (Model.TRACE.DBG)
      Model.TRACE.dbg(2, "Sending EPDC request Remote_PartGet");

    if (!debugEngine.processEPDCRequest(new EReqPartGet(part.id(),
							_owningView.index(),
							_index,
							startLine,
							numberOfLines
						       ),
					DebugEngine.sendReceiveSynchronously))
       return false;

    ERepPartGet reply = (ERepPartGet)debugEngine.getMostRecentReply();

    if (reply == null)
       return false;

    Vector epdcLines = reply.sourceLines();

    if (epdcLines.size() == 0)
       return false;

    for (int i = 0; i < epdcLines.size(); i++)
	lineCache.addElement(new Line(this,
				       startLine + i,
				       (EStdSourceLine)epdcLines.elementAt(i)
				      )
			     );

    return true;
  }
*/

  /**
   * Get the list of paths the engine used to look for the view file. This
   * method should only be used when locating a local source file.
   * @return The array of search path list generated by the engine
   * @exception java.io.IOException If there is a problem communicating
   * with the debug engine.
   */
  public String[] getLocalSourcePathListFromEngine()
  throws java.io.IOException
  {
    if (Model.TRACE.DBG && Model.traceInfo())
        Model.TRACE.dbg(3, "ViewFile.getLocalSourcePathListFromEngine()");

    DebugEngine debugEngine = _owningView.part().module().process().debugEngine();

    if (!debugEngine.prepareForEPDCRequest(EPDC.Remote_ViewSearchPath,
                                          DebugEngine.sendReceiveSynchronously))
        return null;

    if (Model.checkFCTBit)
    {
        if (!debugEngine.getCapabilities().getFileCapabilities().localSourceFilesSupported())
        {
            debugEngine.cancelEPDCRequest(EPDC.Remote_ViewSearchPath);
            return null;
        }
    }

    if (Model.TRACE.EVT && Model.traceInfo())
        Model.TRACE.evt(2, "Sending EPDC request Remote_ViewSearchPath");

    EReqViewSearchPath request = new EReqViewSearchPath(_owningView.part().id(),
                                                        _owningView.index(),
                                                        _index);

    if (!debugEngine.processEPDCRequest(request,
                                        DebugEngine.sendReceiveSynchronously))
        return null;

    ERepViewSearchPath reply = (ERepViewSearchPath)debugEngine.getMostRecentReply();

    if (reply == null || reply.getReturnCode() != EPDC.ExecRc_OK)
        return null;

    return reply.filePaths();
  }

  /**
   * Update the local source information for the part that represents this
   * view file. This method will be used when the file has been found on the
   * frontend and now the part needs to be updated in the engine. The
   * local source file information can be obtained from the FileUtility class.
   * @param fileUtility The object that represent the frontend found view file.
   * If this object is null, it indicates that the file was not found in the
   * frontend.
   * @param addFEAttempted When the value of this boolean variable is true
   * the ATTEMPTED_FE bit will be added to the list of view file attributes
   * to indicate that the attempt by the frontend to locate the file has been
   * done. Please note that the ATTEMPTED_FE bit does not necessarily imply
   * that the file was found by the frontend. If the value is false, the
   * ATTEMPTED_FE bit will be turned off to allow that fronend to locate the
   * file in case the user has provided a different search path.
   */
  boolean setLocalSourceInfo(FileUtility fileUtility, boolean addFEAttempted)
  throws java.io.IOException
  {
    if (Model.TRACE.DBG && Model.traceInfo())
        Model.TRACE.dbg(3, "ViewFile.setLocalSourceInfo()");

    DebugEngine debugEngine = _owningView.part().module().process().debugEngine();

    if (!debugEngine.prepareForEPDCRequest(EPDC.Remote_ViewFileInfoSet,
                                          DebugEngine.sendReceiveSynchronously))
        return false;

    // Retrieve the attributes from the engine
    int viewAttr = _epdcFile.getAttributes();

    if (addFEAttempted)
        viewAttr |= EPDC.VIEW_VERIFY_ATTEMPTED_FE;
    else
        viewAttr ^= EPDC.VIEW_VERIFY_ATTEMPTED_FE;

    EViews view = null;
    int recordLength = _epdcFile.recordLength();
    int startLine = _epdcFile.firstLineNumber();
    int endLine = _epdcFile.lastLineNumber();
    String name = null;
    String baseFileName = null;

    // We have found the file in the frontend
    if (fileUtility != null)
    {
        recordLength = fileUtility.getRecordLength();
        startLine = fileUtility.getFirstLine();
        endLine = fileUtility.getLastLine();
        name = fileUtility.getSourceFileName();
        baseFileName = fileUtility.getBaseFileName();

        // Update the attributes with the new set of attributes
        viewAttr |= EPDC.VIEW_VERIFIED | EPDC.VIEW_LOCAL;

        // If this is a java source file, do not allow the view to be switched
        // from source to any of the other views
        if (_owningView.isSourceView() && !_epdcFile.viewCanBeSwitched())
            viewAttr |= EPDC.VIEW_NO_SWITCH;
    }

    view = new EViews(recordLength, startLine, endLine, name, baseFileName, viewAttr);

    EReqViewFileInfoSet request = new EReqViewFileInfoSet(_owningView.part().id(),
                                                          _owningView.index(),
                                                          (short)_index,
                                                          view);

    if (Model.TRACE.EVT && Model.traceInfo())
        Model.TRACE.evt(2, "Sending EPDC request Remote_ViewFileInfoSet");

    if (!debugEngine.processEPDCRequest(request,
                                        DebugEngine.sendReceiveSynchronously))
        return false;

    _fileUtility = fileUtility;

    // When the file is found by the frontend we will not issue the file not
    // found error that we saved.
    if (_fileUtility != null)
        _fileNotFoundError = false;

    return true;
  }

  FileUtility getMixedViewFileUtility()
  throws java.io.IOException
  {
    ViewFile sourceViewFile = null;
    View[] views = _owningView.part().views();

    for (int i = 1; i < views.length; i++)
    {
         if (views[i] != null && views[i].isSourceView())
         {
             sourceViewFile = views[i].file(_index);
             break;
         }
    }

    return sourceViewFile.getFileUtility();
  }

  FileUtility getFileUtility()
  {
    return _fileUtility;
  }

  void purgeCache()
  {
    if (_lineCacheSegments != null)
       _lineCacheSegments.removeAllElements();

    _currentCacheSize = 0;
  }

  boolean localSourcePathChanged()
  {
    DebugEngine debugEngine = _owningView.part().module().process().debugEngine();
    String path = debugEngine.getLocalSourcePath();

    if (path != null && !path.equals(_localSourcePath))
        return true;

    return false;
  }

  /**
   * Remove references so they can be gc'ed.
   */
  void cleanup()
  {
    _owningView = null;
    _epdcFile = null;
    if (_functions != null)
       _functions.removeAllElements();
    _lineCacheSegments.removeAllElements();
    if (_breakpoints != null)
       _breakpoints.clear();
    _eventListeners.removeAllElements();
    _searchString = null;
    _lastFindLocation = null;
    _fileUtility = null;
    _localSourcePath = null;
  }


  // *******************
  // *** INNER CLASS ***
  // *******************

  private class LineCacheSegment
  {
    boolean addLinesFromEngine(int startLine, int numberOfLines)
    throws java.io.IOException
    {
      if (Model.TRACE.DBG)
	 Model.TRACE.dbg(4, "ViewFile.LineCacheSegment.addLinesFromEngineToVector(" + startLine + ", " + numberOfLines + ")");

      Part part = _owningView.part();

      DebugEngine debugEngine = part.module().process().debugEngine();

      // If we have not yet attempted to verify the view file, do so. Because
      // this is being done synchronously, after the attempt to verify we
      // should have an updated _epdcFile member.

      verify();

      if (!debugEngine.prepareForEPDCRequest(EPDC.Remote_PartGet,
					     DebugEngine.sendReceiveSynchronously))
	 return false;

      // TODO: If a view file cannot be verified we want to give the user a
      // a chance to override the file name. However, beware - the above verify
      // might have failed because the DE was busy, not because the file
      // really couldn't be verified.

      if (!_epdcFile.hasBeenVerified())
      {
	 debugEngine.cancelEPDCRequest(EPDC.Remote_PartGet);
	 return false;
      }

      if (Model.TRACE.DBG)
	Model.TRACE.dbg(2, "Sending EPDC request Remote_PartGet");

      ERepPartGet reply =
            (ERepPartGet) debugEngine.processEPDCRequestWithReply(
                                         new EReqPartGet(part.id(),
                                                         _owningView.index(),
                                                         _index,
                                                         startLine,
                                                         numberOfLines),
                                         DebugEngine.sendReceiveSynchronously);

      if (reply == null || reply.getReturnCode() != EPDC.ExecRc_OK)
	 return false;

      Vector epdcLines = reply.sourceLines();

      if (epdcLines.size() == 0)
	 return false;

      Line line = null;
      EStdSourceLine sourceLine = null;

      // If this is a local source file, get the requested lines of the local
      // source from the FileUtility object.
      String[] text = null;
      int firstLine = startLine;
      if (_epdcFile.verificationLocal())
      {
          int numberOfLinesToRead = numberOfLines;
          FileUtility fileUtility = _fileUtility;

          // If the view is mixed, get the fileUtility object from the
          // the source ViewFile.
          if (_owningView.isMixedView())
          {
              fileUtility = getMixedViewFileUtility();
              numberOfLinesToRead = fileUtility.getLastLine();
              firstLine = fileUtility.getFirstLine();
          }
          text = new String[numberOfLinesToRead];
          text = fileUtility.getLines(firstLine, numberOfLinesToRead);
      }

      int index = 0;
      int prefixLength = _owningView.prefixLength();
      for (int i = 0; i < epdcLines.size(); i++)
      {
           sourceLine = (EStdSourceLine)epdcLines.elementAt(i);
           if (sourceLine.isLocal())
           {
               // The prefix without the whitespaces is the line number
               // of the source view of the ViewFile. We need to calculate
               // because its value will be an index into the lines saved
               // by the FileUtility object.
               String prefix = sourceLine.lineText().substring(0, prefixLength).trim();
               try
               {
                 index = Integer.parseInt(prefix);
               }
               catch(NumberFormatException excp)
               {
                 System.out.println("NumberFormatException Occurred");
                 return false;
               }

               sourceLine.setLineTextWithPrefix(text[index-firstLine], prefixLength);
           }

           line = new Line(ViewFile.this, startLine + i, sourceLine);

           _lineCache.addElement(line);
      }

      return true;
    }

    boolean containsLine(int lineNumber)
    {
      return getLineNumberOfFirstLineInSegment() <= lineNumber &&
             getLineNumberOfLastLineInSegment() >= lineNumber;
    }

    boolean containsLinesInRange(int startingLineNumber, int endingLineNumber)
    {
      return startingLineNumber <= getLineNumberOfLastLineInSegment() &&
             endingLineNumber >= getLineNumberOfFirstLineInSegment();
    }

    // Assumes that the caller has already called containsLine(int lineNumber)
    // to verify that this segment actually does contain the line:

    Line getLine(int lineNumber)
    {
       int index = lineNumber - getLineNumberOfFirstLineInSegment();

       return (Line)_lineCache.elementAt(index);
    }

    /**
     * If this segment contains any lines within the given range, add them
     * to the Vector:
     */

    Vector getLinesInRange(int startingLineNumber, int endingLineNumber)
    {
      if (!containsLinesInRange(startingLineNumber, endingLineNumber))
         return null;

      int startingIndex = startingLineNumber - getLineNumberOfFirstLineInSegment();

      if (startingIndex < 0)
         startingIndex = 0;

      Vector lines = new Vector();

      for (int i = startingIndex; i < _lineCache.size(); i++)
      {
          Line line = (Line)_lineCache.elementAt(i);

          if (line.lineNumberWithinFile() > endingLineNumber)
             break;

          lines.addElement(line);
      }

      return lines;
    }

    private Vector getAllLines()
    {
      return _lineCache;
    }

    void removeLinesNotInRange(int startingLineNumber,
                               int endingLineNumber,
                               int maxNumberOfLinesToRemove)
    {
       if (Model.TRACE.DBG)
          Model.TRACE.dbg(4, "ViewFile.LineCacheSegment.removeLinesNotInRange(" +
                              startingLineNumber + ", " +
                              endingLineNumber + ", " +
                              maxNumberOfLinesToRemove + ")");

       if (!containsLinesInRange(startingLineNumber, endingLineNumber))
       {
          // If the segment does not contain any of the lines in the range then
          // we can get rid of as many as we need to. The number of lines
          // to purge will be either maxNumberOfLinesToRemove or size(),
          // whichever is smaller:

          if (maxNumberOfLinesToRemove >= size())
             _lineCache.setSize(0);
          else
             _lineCache.setSize(size() - maxNumberOfLinesToRemove);
       }
       else
       {
         // If the segment contains the last line in the range then we can
         // remove any lines after it:

         int numberOfLinesLeftToPurge = maxNumberOfLinesToRemove;

         if (containsLine(endingLineNumber))
         {
            int numberOfLinesBeyondEndOfRange = getLineNumberOfLastLineInSegment() -
                                                endingLineNumber;

            if (numberOfLinesBeyondEndOfRange > 0)
               if (numberOfLinesBeyondEndOfRange >= maxNumberOfLinesToRemove)
               {
                  _lineCache.setSize(size() - maxNumberOfLinesToRemove);
                  numberOfLinesLeftToPurge = 0;
               }
               else
               {
                  _lineCache.setSize(size() - numberOfLinesBeyondEndOfRange);
                  numberOfLinesLeftToPurge -= numberOfLinesBeyondEndOfRange;
               }
         }

         // If there are still lines to remove and the segment contains
         // the first line in the range then we can remove lines before
         // the first line. This is done as a last resort since it is the
         // least efficient way to free up room:

         if (containsLine(startingLineNumber))
            while (((Line)_lineCache.firstElement()).lineNumberWithinFile() < startingLineNumber &&
                   numberOfLinesLeftToPurge > 0)
            {
                _lineCache.removeElementAt(0);
                --numberOfLinesLeftToPurge;
            }
       }
    }

    /**
     * Return true if the first line of this segment is 1 greater than the
     * last line of the given segment, otherwise return false.
     */

    boolean isAContinuationOf(LineCacheSegment lineCacheSegment)
    {
      return lineCacheSegment.getLineNumberOfLastLineInSegment() + 1 ==
             getLineNumberOfFirstLineInSegment();
    }

    void mergeWith(LineCacheSegment lineCacheSegment)
    {
      if (Model.TRACE.DBG)
      {
         Model.TRACE.dbg(4, "ViewFile.LineCacheSegment.mergeWith(LineCacheSegment)");
         Model.TRACE.dbg(4, "Merging segment with last line# " +
                             getLineNumberOfLastLineInSegment() +
                            " with segment whose first line number is: " +
                             lineCacheSegment.getLineNumberOfFirstLineInSegment());
      }

      Vector lines = lineCacheSegment.getAllLines();

      for (int i = 0; i < lines.size(); i++)
          _lineCache.addElement(lines.elementAt(i));
    }

    int getLineNumberOfFirstLineInSegment()
    {
      return ((Line)_lineCache.firstElement()).lineNumberWithinFile();
    }

    int getLineNumberOfLastLineInSegment()
    {
      return ((Line)_lineCache.lastElement()).lineNumberWithinFile();
    }

    int size()
    {
      return _lineCache.size();
    }

    private Vector _lineCache = new Vector();
  }

  // **************************
  // *** END OF INNER CLASS ***
  // **************************

  private View _owningView;
  private EViews _epdcFile;
  private int _index;

  private Vector _functions;  //stores the list of functions

  private Vector _lineCacheSegments = new Vector();
  private int _currentCacheSize = 0;
  private int _maximumCacheSize;

  private Hashtable _breakpoints;
  private Vector _eventListeners = new Vector();

  private String _searchString;
  private Location _lastFindLocation;
  private boolean _caseSensitiveSearch;

  private FileUtility _fileUtility;

  private boolean _fileNotFoundError = false;
  private String _localSourcePath = null;
}
